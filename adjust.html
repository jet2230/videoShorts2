<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adjust Theme - YouTube Shorts Creator</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a15 0%, #1a1a2e 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .back-link {
            color: #00ff9d;
            text-decoration: none;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .container {
            display: grid;
            grid-template-columns: 7fr 3fr;
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }

        .panel {
            background: rgba(30, 30, 45, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
        }

        .panel h2 {
            color: #00ff9d;
            font-size: 16px;
            margin-bottom: 16px;
        }

        /* Video containers */
        .video-wrapper {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 16/9;
            margin-bottom: 16px;
        }

        .buffer-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            font-family: monospace;
            z-index: 10;
            pointer-events: none;
        }

        .autosave-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 255, 157, 0.9);
            color: #000;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .autosave-indicator.show {
            opacity: 1;
        }

        .autosave-indicator.saving {
            background: rgba(255, 193, 7, 0.9);
        }

        .preview-autosave {
            top: 10px;
            right: 10px;
            left: auto;
        }

        /* Custom Video Controls */
        .video-controls-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
            pointer-events: none;
        }

        .video-wrapper:hover .video-controls-overlay {
            opacity: 1;
            pointer-events: auto;
        }

        .controls-progress {
            width: 100%;
            margin-bottom: 8px;
            position: relative;
        }

        .seekbar {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        /* Seekbar with theme range marked in red */
        .seekbar.theme-marked {
            background: linear-gradient(to right,
                rgba(255, 255, 255, 0.3) var(--theme-start),
                rgba(244, 67, 54, 0.85) var(--theme-start),
                rgba(244, 67, 54, 0.85) var(--theme-end),
                rgba(255, 255, 255, 0.3) var(--theme-end)
            );
        }

        /* Theme marker flag */
        .theme-marker {
            position: absolute;
            top: -30px;
            left: 0;
            transform: translateX(-50%);
            pointer-events: none;
            transition: left 0.2s;
        }

        .theme-marker-flag {
            position: relative;
            background: rgba(244, 67, 54, 0.9);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            font-weight: 500;
        }

        .theme-marker-flag::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid rgba(244, 67, 54, 0.9);
        }

        .seekbar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }

        .seekbar::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .controls-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .control-icon {
            background: none;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            padding: 4px 8px;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .control-icon:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .control-jump {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .control-jump:hover {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
        }

        .time-display {
            color: #fff;
            font-size: 13px;
            font-family: monospace;
            flex-grow: 1;
        }

        .volume-slider {
            width: 80px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        .volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* Theme clip preview - 9:16 aspect ratio for YouTube Shorts */
        .preview-wrapper {
            aspect-ratio: 9/16;
            max-height: 500px;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Preview video should crop to fill the 9:16 frame */
        #preview-video {
            object-fit: cover;
        }

        /* Hide native VTT subtitles for preview video (we use custom overlay) */
        #preview-video::cue {
            background-color: transparent !important;
            color: transparent !important;
            text-shadow: none !important;
        }
        #preview-video::cue-background {
            background-color: transparent !important;
        }

        /* Preview seekbar container */
        .preview-seekbar-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 10px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .preview-wrapper:hover .preview-seekbar-container {
            opacity: 1;
            pointer-events: auto;
        }

        .preview-controls-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .preview-time-row {
            display: flex;
            justify-content: center;
        }

        .preview-control-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #00ff9d;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .preview-control-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        .preview-seekbar {
            flex-grow: 1;
        }

        .preview-time-display {
            font-size: 13px;
            color: #00ff9d;
            font-family: monospace;
        }

        /* Subtitle overlay */
        .subtitle-overlay {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 80%;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        .subtitle-overlay.draggable {
            pointer-events: auto;
            cursor: move;
            z-index: 30; /* Above controls (z-index 20) but not too high */
        }

        .subtitle-text {
            display: inline-block;
            padding: 6px 16px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 6px;
            line-height: 1.4;
        }

        /* Shorts 9:16 crop overlay */
        .shorts-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .shorts-crop-area {
            width: 56.25%;
            height: 100%;
            border: 3px solid rgba(0, 255, 157, 0.8);
            background: rgba(0, 255, 157, 0.1);
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.3);
        }

        .shorts-crop-area::before {
            content: '9:16';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 157, 0.9);
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        /* Timeline */
        .timeline-container {
            margin-top: 16px;
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        /* Video buffer controls (on sides of video) */
        .video-buffer-btn {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #00ff9d;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
            pointer-events: auto;
        }

        .video-buffer-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        /* Buffer button containers */
        .video-buffer-controls-left,
        .video-buffer-controls-right {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 30;
        }

        .video-buffer-controls-left {
            left: 10px;
        }

        .video-buffer-controls-right {
            right: 10px;
        }

        /* Position buffer buttons inside video on edges */
        .video-buffer-btn.video-buffer-left {
            position: static;
            transform: none;
        }

        .video-buffer-btn.video-buffer-right {
            position: static;
            transform: none;
        }

        .buffer-label {
            font-size: 12px;
            color: #aaa;
        }

        .reset-timeline-btn {
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255, 87, 34, 0.5);
            background: rgba(255, 87, 34, 0.1);
            color: #ff5722;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .reset-timeline-btn:hover {
            background: rgba(255, 87, 34, 0.2);
            border-color: rgba(255, 87, 34, 0.8);
            transform: translateY(-1px);
        }

        .reset-timeline-btn:active {
            transform: translateY(0);
            background: rgba(255, 87, 34, 0.3);
        }

        .timeline-track {
            position: relative;
            height: 60px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            overflow: hidden;
        }

        /* Buffer range band (shows the buffered portion of the video) */
        .buffer-range {
            position: absolute;
            height: 100%;
            background: rgba(100, 150, 200, 0.2);
            border-radius: 6px;
        }

        .theme-box {
            position: absolute;
            height: 100%;
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.5), rgba(255, 87, 34, 0.5));
            border: 2px solid #f44336;
            border-radius: 6px;
            cursor: default;
            transition: border-color 0.2s;
        }

        .theme-box.highlight-left {
            border-left: 4px solid #ff9800;
        }

        .theme-box.highlight-right {
            border-right: 4px solid #ff9800;
        }

        .theme-box-handle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: #f44336;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: ew-resize;
            z-index: 10;
            transition: background 0.2s, border-color 0.2s;
        }

        .theme-box-handle:hover {
            background: #ff9800 !important;
            border-color: #fff !important;
        }

        .theme-box-handle.left {
            left: -8px; /* Position outside left edge */
        }

        .theme-box-handle.right {
            right: -8px; /* Position outside right edge */
        }

        .theme-box-content {
            position: absolute;
            top: 50%;
            left: 20px;
            right: 20px;
            transform: translateY(-50%);
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .time-markers {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 11px;
            color: #aaa;
        }

        /* Time start marker inside timeline */
        .time-start-marker-inside {
            position: absolute;
            bottom: 4px;
            left: 8px;
            font-size: 11px;
            color: #00ff9d;
            font-weight: 500;
            pointer-events: none;
            z-index: 5;
        }

        /* Time end marker inside timeline */
        .time-end-marker-inside {
            position: absolute;
            bottom: 4px;
            right: 8px;
            font-size: 11px;
            color: #00ff9d;
            font-weight: 500;
            pointer-events: none;
            z-index: 5;
        }

        /* Info display */
        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #aaa;
            font-size: 13px;
        }

        .info-value {
            font-weight: 600;
            font-size: 14px;
        }

        #folder-location {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: inline-block;
            vertical-align: bottom;
            cursor: help;
        }

        #folder-location:hover {
            overflow: visible;
            white-space: normal;
            word-wrap: break-word;
        }

        .duration-value {
            color: #00ff9d;
            font-size: 18px;
        }

        /* Subtitle editor */
        .subtitle-editor {
            margin-top: 20px;
        }

        .lock-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .lock-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        .lock-btn.locked {
            background: rgba(255, 152, 0, 0.2);
            border-color: #ff9800;
        }

        .subtitle-section {
            margin-bottom: 20px;
        }

        .subtitle-section h3 {
            font-size: 14px;
            color: #00ff9d;
            margin-bottom: 12px;
        }

        .form-row {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }

        .form-group {
            flex: 1;
        }

        .form-group label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 6px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #00ff9d;
        }

        .form-group input[type="color"] {
            height: 40px;
            padding: 4px;
        }

        .subtitle-text-area {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            /* Don't set color here - let inline styles work */
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
        }

        .subtitle-text-area:focus {
            outline: none;
            border-color: #00ff9d;
        }

        .subtitle-text-area:empty:before {
            content: attr(data-placeholder);
            color: rgba(255, 255, 255, 0.4);
        }

        .subtitle-text-area strong {
            font-weight: bold;
        }

        .subtitle-text-area em {
            font-style: italic;
        }

        .rich-text-toolbar {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .toolbar-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toolbar-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        .toolbar-btn.active {
            background: rgba(0, 255, 157, 0.3);
            border-color: #00ff9d;
        }

        /* Buttons */
        .buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00bfff, #00ff9d);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 255, 157, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Loading and messages */
        .loading {
            text-align: center;
            padding: 60px 20px;
            color: #aaa;
        }

        .error {
            background: rgba(255, 59, 48, 0.2);
            border: 1px solid rgba(255, 59, 48, 0.5);
            border-radius: 8px;
            padding: 16px;
            color: #ff6b6b;
        }

        .success {
            background: rgba(0, 255, 157, 0.2);
            border: 1px solid rgba(0, 255, 157, 0.5);
            border-radius: 8px;
            padding: 16px;
            color: #00ff9d;
        }

        .hidden {
            display: none !important;
        }

        /* Custom tooltip for directory location */
        .custom-tooltip {
            position: relative;
            display: inline-block;
        }

        .custom-tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-5px);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background-color: #1e1e1e;
            margin: 5% auto;
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header h2 {
            margin: 0;
            font-size: 20px;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover,
        .close:focus {
            color: #fff;
        }

        .modal-body {
            padding: 20px;
        }

        .subtitle-cue-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .cue-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 8px;
            font-size: 13px;
            color: #aaa;
        }

        .cue-time-input {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            width: 90px;
        }

        .cue-textarea {
            width: 100%;
            min-height: 60px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
        }

        .cue-textarea:focus {
            outline: none;
            border-color: #00ff9d;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            padding: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Time extension controls */
        .time-extension-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            margin: 16px 0;
            padding: 12px 16px;
            background: rgba(0, 255, 157, 0.08);
            border: 1px solid rgba(0, 255, 157, 0.2);
            border-radius: 8px;
        }

        .extension-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .extension-divider {
            color: #aaa;
            font-size: 14px;
            margin: 0 4px;
        }

        .extension-label {
            color: #00ff9d;
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
        }

        .extension-time-input {
            background: rgba(30, 30, 45, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 13px;
            padding: 6px 8px;
            font-family: monospace;
            width: 115px;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s;
        }

        /* Make the time input spinner icon white */
        .extension-time-input::-webkit-calendar-picker-indicator {
            filter: invert(1);
            cursor: pointer;
        }

        .extension-time-input::-webkit-calendar-picker-indicator:hover {
            filter: invert(1) brightness(1.2);
        }

        .extension-time-input:hover {
            border-color: rgba(0, 255, 157, 0.4);
        }

        .extension-time-input:focus {
            outline: none;
            border-color: #00ff9d;
            background: rgba(30, 30, 45, 1);
        }

        .time-separator {
            color: #aaa;
            font-size: 12px;
        }

        .extension-apply-btn {
            background: rgba(0, 255, 157, 0.15);
            border: 1px solid rgba(0, 255, 157, 0.4);
            border-radius: 4px;
            color: #00ff9d;
            font-size: 12px;
            font-weight: 500;
            padding: 6px 14px;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s, transform 0.1s;
        }

        .extension-apply-btn:hover {
            background: rgba(0, 255, 157, 0.25);
            border-color: #00ff9d;
        }

        .extension-apply-btn:active {
            transform: scale(0.96);
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="index.html" class="back-link">
            <span>‚Üê</span> Back to Main
        </a>
        <div style="flex-grow: 1; text-align: center;">
            <h1 style="margin: 0; font-size: 18px;" id="header-title">Adjust Theme</h1>
            <p style="margin: 0; font-size: 13px; color: #aaa;" id="header-theme-name"></p>
        </div>
        <div></div>
    </div>

    <div id="loading" class="loading">Loading theme details...</div>
    <div id="error" class="error hidden"></div>

    <div id="content" class="container hidden">
        <!-- Left Panel: Original Video + Timeline -->
        <div class="panel">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                <h2 style="margin: 0;">Original Video</h2>
                <div style="display: flex; gap: 16px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="subtitles-toggle" checked style="width: 18px; height: 18px;">
                        <span style="font-size: 13px; color: #aaa;">Show Subtitles</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="overlay-toggle" style="width: 18px; height: 18px;">
                        <span style="font-size: 13px; color: #aaa;">Show 9:16 Crop Overlay</span>
                    </label>
                </div>
            </div>

            <div class="video-wrapper">
                <video id="original-video">
                    <track id="subtitle-track" kind="subtitles" srclang="en" label="English" default>
                </video>
                <div id="shorts-overlay" class="shorts-overlay hidden">
                    <div class="shorts-crop-area"></div>
                </div>
                <div class="buffer-info" id="buffer-info">Buffer range: 00:00:00 - 00:00:00</div>
                <div class="autosave-indicator" id="autosave-indicator"></div>

                <!-- Custom Video Controls -->
                <div class="video-controls-overlay">
                    <div class="controls-progress">
                        <input type="range" id="seekbar" class="seekbar" min="0" max="100" value="0" step="0.1">
                        <div id="theme-marker" class="theme-marker">
                            <div class="theme-marker-flag">Theme length: <span id="theme-duration-text">00:00</span></div>
                        </div>
                    </div>
                    <div class="controls-row">
                        <button id="play-pause-btn" class="control-icon">‚ñ∂</button>
                        <button id="jump-start-btn" class="control-jump" title="Jump to theme start">‚èÆ Start</button>
                        <button id="jump-end-btn" class="control-jump" title="Jump to theme end">End ‚è≠</button>
                        <span id="time-display" class="time-display">00:00 / 00:00</span>
                        <input type="range" id="volume-slider" class="volume-slider" min="0" max="1" value="1" step="0.1">
                    </div>
                </div>

                <!-- Video buffer controls inside video -->
                <div class="video-buffer-controls-left">
                    <button id="video-buffer-decrease-left" class="video-buffer-btn" title="Reduce buffer by 1 min">‚àí</button>
                    <button id="video-buffer-increase-left" class="video-buffer-btn" title="Increase buffer by 1 min">+</button>
                </div>
                <div class="video-buffer-controls-right">
                    <button id="video-buffer-decrease-right" class="video-buffer-btn" title="Reduce buffer by 1 min">‚àí</button>
                    <button id="video-buffer-increase-right" class="video-buffer-btn" title="Increase buffer by 1 min">+</button>
                </div>
            </div>

            <div class="timeline-container">
                <div class="timeline-header">
                    <span class="buffer-label" id="buffer-display">L: ¬±5min | R: ¬±5min</span>
                    <button id="reset-timeline-btn" class="reset-timeline-btn" title="Reset to original theme time range">‚Ü∫ Reset to Original</button>
                </div>
                <div class="timeline-track" id="timeline-track">
                    <div class="buffer-range" id="buffer-range">
                        <div class="theme-box" id="theme-box">
                            <div class="theme-box-handle left" id="handle-left"></div>
                            <div class="theme-box-content" id="theme-box-content">00:30 - 01:30</div>
                            <div class="theme-box-handle right" id="handle-right"></div>
                        </div>
                    </div>
                    <span class="time-start-marker-inside" id="time-start-marker">00:00</span>
                    <span class="time-end-marker-inside" id="time-end-marker">00:00</span>
                </div>
                <div class="time-markers">
                </div>
            </div>

            <!-- Manual time extension inputs -->
            <div class="time-extension-controls">
                <div class="extension-input-group">
                    <label class="extension-label">Ext Left</label>
                    <button id="apply-ext-left" class="extension-apply-btn">Apply</button>
                </div>
                <input type="time" id="ext-left-end" class="extension-time-input" step="1" min="00:00:00" max="01:00:00">
                <div class="extension-divider">|</div>
                <input type="time" id="ext-right-end" class="extension-time-input" step="1" min="00:00:00" max="01:00:00">
                <div class="extension-input-group">
                    <button id="apply-ext-right" class="extension-apply-btn">Apply</button>
                    <label class="extension-label">Ext Right</label>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <div class="info-row">
                    <span class="info-label">Theme</span>
                    <span class="info-value" id="theme-number">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Theme Name</span>
                    <span class="info-value" id="theme-name" style="color: #00ff9d; cursor: pointer;" contenteditable="true" title="Click to edit">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Start Time</span>
                    <span class="info-value" id="display-start">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">End Time</span>
                    <span class="info-value" id="display-end">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Duration</span>
                    <span class="info-value duration-value" id="display-duration">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Directory location</span>
                    <span class="info-value" id="folder-location" title="">-</span>
                </div>
            </div>
        </div>

        <!-- Right Panel: Theme Clip Preview + Subtitle Editor -->
        <div class="panel">
            <h2>Theme Clip Preview (9:16 Shorts)</h2>
            <div class="video-wrapper preview-wrapper">
                <video id="preview-video" loop playsinline>
                    <track id="preview-subtitle-track" kind="subtitles" srclang="en" label="English" default>
                </video>
                <div class="subtitle-overlay" id="subtitle-overlay">
                    <span class="subtitle-text" id="subtitle-preview-text">Preview subtitles</span>
                </div>
                <div class="autosave-indicator preview-autosave" id="preview-autosave-indicator"></div>

                <!-- Custom controls for preview video -->
                <div class="preview-seekbar-container">
                    <div class="preview-controls-row">
                        <button id="preview-play-btn" class="preview-control-btn">‚ñ∂</button>
                        <input type="range" id="preview-seekbar" class="seekbar preview-seekbar" min="0" max="100" value="0" step="0.1">
                    </div>
                    <div class="preview-time-row">
                        <span id="preview-time-display" class="preview-time-display">00:00 / 00:00</span>
                    </div>
                </div>
            </div>

            <div class="subtitle-editor">
                <div class="subtitle-section">
                    <div style="display: flex; align-items: center; justify-content: space-between;">
                        <h3>Subtitle Text</h3>
                        <div style="display: flex; gap: 8px;">
                            <button id="edit-all-subs-btn" class="lock-btn" title="Edit all subtitles for this theme">üìù Edit All</button>
                            <button id="lock-video-btn" class="lock-btn" title="Lock video controls">
                                <span id="lock-icon">üîì</span>
                            </button>
                        </div>
                    </div>
                    <div class="rich-text-toolbar">
                        <button class="toolbar-btn" data-style="bold" onclick="toggleStyle('bold')"><b>Bold</b></button>
                        <button class="toolbar-btn" data-style="italic" onclick="toggleStyle('italic')"><i>Italic</i></button>
                        <button class="toolbar-btn" data-style="color" onclick="applyColor('#ff0000')">üî¥ Red</button>
                        <button class="toolbar-btn" data-style="color" onclick="applyColor('#00ff00')">üü¢ Green</button>
                        <button class="toolbar-btn" data-style="color" onclick="applyColor('#00ffff')">üîµ Cyan</button>
                        <button class="toolbar-btn" data-style="color" onclick="applyColor('#ffff00')">üü° Yellow</button>
                        <button class="toolbar-btn" data-style="size" onclick="applySize(1.2)">A+</button>
                        <button class="toolbar-btn" data-style="size" onclick="applySize(0.8)">a-</button>
                        <button class="toolbar-btn" onclick="removeFormatting()" style="margin-left: auto;">üóë Clear Format</button>
                    </div>
                    <div class="subtitle-text-area" id="subtitle-text" contenteditable="true" data-placeholder="Edit subtitle text here..."></div>
                </div>

                <div class="subtitle-section">
                    <h3>Global Subtitle Settings</h3>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Font Family</label>
                            <select id="subtitle-font">
                                <option value="Arial">Arial</option>
                                <option value="Calibri">Calibri</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Verdana">Verdana</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Font Size (px)</label>
                            <input type="number" id="subtitle-size" value="16" min="12" max="72">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Text Color</label>
                            <input type="color" id="subtitle-color" value="#ffffff">
                        </div>
                        <div class="form-group">
                            <label>Background Color</label>
                            <input type="color" id="subtitle-bg" value="#000000">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Position</label>
                            <select id="subtitle-position">
                                <option value="bottom">Bottom</option>
                                <option value="middle">Middle</option>
                                <option value="top">Top</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Background Opacity</label>
                            <input type="range" id="subtitle-bg-opacity" min="0" max="100" value="70">
                        </div>
                    </div>
                </div>
            </div>

            <div class="buttons">
                <button class="btn btn-secondary" id="preview-btn">‚ñ∂ Preview Theme Clip</button>
                <button class="btn btn-primary" id="save-btn">Save Changes</button>
            </div>

            <div id="message" style="margin-top: 16px;"></div>
        </div>
    </div>

    <!-- Subtitle Editor Modal -->
    <div id="subtitle-modal" class="modal">
        <div class="modal-content" style="max-width: 800px; max-height: 80vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <h2>Edit All Subtitles</h2>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body" style="flex: 1; overflow-y: auto;">
                <div id="subtitle-cues-container"></div>
            </div>
            <div class="modal-footer" style="padding: 16px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: flex-end; gap: 12px;">
                <button id="cancel-subs-btn" class="btn btn-secondary">Cancel</button>
                <button id="save-subs-btn" class="btn btn-primary">Save Subtitles</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let themeData = null;
        let fullVideoDuration = 0;  // Full video duration
        let bufferedDuration = 0;   // Buffered range duration (for timeline)
        let videoPath = '';
        let startSeconds = 0;
        let endSeconds = 0;
        let originalStartSeconds = 0;  // Original theme time from themes.md (for reset)
        let originalEndSeconds = 0;    // Original theme time from themes.md (for reset)
        let bufferLeftSeconds = 300; // 5 minutes buffer before theme
        let bufferRightSeconds = 300; // 5 minutes buffer after theme
        let isDragging = null;
        let dragStartX = 0;
        let dragStartValue = 0;
        let dragStartValueEnd = 0;
        let videoControlsLocked = false; // Video controls lock state

        // DOM Elements
        const originalVideo = document.getElementById('original-video');
        const previewVideo = document.getElementById('preview-video');
        const previewSeekbar = document.getElementById('preview-seekbar');
        const previewPlayBtn = document.getElementById('preview-play-btn');
        const themeBox = document.getElementById('theme-box');
        const handleLeft = document.getElementById('handle-left');
        const handleRight = document.getElementById('handle-right');
        const timelineTrack = document.getElementById('timeline-track');
        const bufferRange = document.getElementById('buffer-range');
        const themeBoxContent = document.getElementById('theme-box-content');

        // Custom video control elements
        const seekbar = document.getElementById('seekbar');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const jumpStartBtn = document.getElementById('jump-start-btn');
        const jumpEndBtn = document.getElementById('jump-end-btn');
        const timeDisplay = document.getElementById('time-display');
        const volumeSlider = document.getElementById('volume-slider');
        const themeMarker = document.getElementById('theme-marker');
        const themeDurationText = document.getElementById('theme-duration-text');

        // Parse URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const folderNumber = urlParams.get('folder');
        const themeNumber = parseInt(urlParams.get('theme'));

        // Format time
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        // Parse time string to seconds
        function parseTime(timeStr) {
            const parts = timeStr.split(':');
            if (parts.length !== 3) return 0;
            return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseFloat(parts[2]);
        }

        // Auto-save theme adjustment
        let autoSaveTimeout = null;
        let subtitleAutoSaveTimeout = null;
        let currentCueInfo = null; // Track current cue {sequence, timestamp, start, end, text}
        let allThemeCues = []; // Cache all theme cues
        let subtitleFormatting = { bold: false, italic: false, color: null, size: null };
        let allCueFormatting = {}; // Store formatting for all cues: {sequence: {sequence, timestamp, html, _text}}
        let isProgrammaticUpdate = false; // Flag to prevent auto-save during programmatic updates
        let themeStartBeforeDrag = null; // Track theme start before drag to calculate timestamp shift
        let themeEndBeforeDrag = null; // Track theme end before drag

        function autoSaveTheme() {
            // Clear existing timeout
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }

            // Show saving indicator
            const indicator = document.getElementById('autosave-indicator');
            indicator.textContent = '‚è≥ Saving...';
            indicator.classList.add('show', 'saving');

            // Debounce save to avoid too many requests
            autoSaveTimeout = setTimeout(async () => {
                try {
                    const updates = {
                        folder: folderNumber,
                        theme: themeNumber,
                        title: document.getElementById('theme-name').textContent,
                        start: formatTime(startSeconds),
                        end: formatTime(endSeconds)
                    };

                    const response = await fetch('/api/update-theme', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(updates)
                    });

                    if (!response.ok) throw new Error('Failed to auto-save');

                    indicator.textContent = '‚úì Saved';
                    indicator.classList.remove('saving');

                    // Hide after 2 seconds
                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                } catch (error) {
                    indicator.textContent = '‚úó Save failed';
                    indicator.classList.remove('saving');
                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                }
            }, 500); // Wait 500ms after drag ends before saving
        }

        // Helper function to convert seconds to time input format (HH:MM:SS)
        function secondsToTimeInput(totalSeconds) {
            console.log('   secondsToTimeInput called with:', totalSeconds, 'type:', typeof totalSeconds);

            // Handle invalid values
            if (totalSeconds === null || totalSeconds === undefined || isNaN(totalSeconds)) {
                console.warn('   ‚ö†Ô∏è Invalid value, returning 00:00:00');
                return '00:00:00';
            }

            // Ensure we have a number
            totalSeconds = Number(totalSeconds);

            // Round to nearest whole second for time input display
            totalSeconds = Math.round(totalSeconds);

            const h = Math.floor(totalSeconds / 3600);
            const m = Math.floor((totalSeconds % 3600) / 60);
            const s = totalSeconds % 60;

            const result = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            console.log(`   ‚Üí ${result} (h:${h}, m:${m}, s:${s})`);
            return result;
        }

        // Helper function to update time extension inputs
        function updateTimeExtensionInputs() {
            console.log('üïê updateTimeExtensionInputs called');

            const extLeftEnd = document.getElementById('ext-left-end');
            const extRightEnd = document.getElementById('ext-right-end');

            console.log(`   Elements found: extLeftEnd=${!!extLeftEnd}, extRightEnd=${!!extRightEnd}`);
            console.log(`   Values: originalStartSeconds=${originalStartSeconds}, startSeconds=${startSeconds}`);
            console.log(`   Values: originalEndSeconds=${originalEndSeconds}, endSeconds=${endSeconds}`);

            if (extLeftEnd && extRightEnd &&
                originalStartSeconds !== null && originalStartSeconds !== undefined &&
                originalEndSeconds !== null && originalEndSeconds !== undefined &&
                startSeconds !== null && startSeconds !== undefined &&
                endSeconds !== null && endSeconds !== undefined) {

                const leftExtension = Math.max(0, originalStartSeconds - startSeconds);
                const rightExtension = Math.max(0, endSeconds - originalEndSeconds);

                console.log(`   Calculated: leftExtension=${leftExtension}s, rightExtension=${rightExtension}s`);

                extLeftEnd.value = secondsToTimeInput(leftExtension);
                extRightEnd.value = secondsToTimeInput(rightExtension);

                console.log(`   ‚úÖ Updated: extLeftEnd.value=${extLeftEnd.value}, extRightEnd.value=${extRightEnd.value}`);
            } else {
                console.warn('   ‚ö†Ô∏è Cannot update - missing elements or values');
            }
        }

        // Load all theme cues for editing
        async function loadThemeCues() {
            try {
                console.log('üîÑ Loading all theme cues from original SRT...');

                // Load ALL cues from original SRT (not filtered by theme range)
                // This allows styling subtitles in expanded timeline areas
                // Add cache-buster to ensure we get fresh response
                const cacheBuster = Date.now();
                const response = await fetch(`/api/all-subtitles/${folderNumber}?_=${cacheBuster}`);

                console.log(`   Response status: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    console.warn('‚ùå Failed to load all subtitles, falling back to theme-filtered');
                    // Fallback to theme-filtered API
                    const fallbackResponse = await fetch(`/api/theme-subtitles/${folderNumber}/${themeNumber}`);
                    if (!fallbackResponse.ok) return [];
                    const data = await fallbackResponse.json();
                    allThemeCues = data.cues;
                    console.log(`   ‚úì Fallback: loaded ${allThemeCues.length} theme-filtered cues`);
                    return allThemeCues;
                }

                const data = await response.json();
                allThemeCues = data.cues;
                console.log(`‚úì Loaded ${allThemeCues.length} cues from original SRT`);
                return allThemeCues;
            } catch (error) {
                console.error('‚ùå Failed to load theme cues:', error);
                return [];
            }
        }

        // Load subtitle formatting metadata
        async function loadSubtitleFormatting() {
            try {
// console.log('üìÇ Loading subtitle formatting...');
                const response = await fetch(`/api/subtitle-formatting/${folderNumber}/${themeNumber}`);
                if (!response.ok) return;

                const data = await response.json();
                allCueFormatting = data.formatting || {};

                // Helper to parse timestamp to seconds
                const vttToSeconds = (ts) => {
                    const [time, millis] = ts.split('.');
                    const isNeg = time.startsWith('-');
                    const [h, m, s] = time.replace('-', '').split(':').map(Number);
                    const result = h * 3600 + m * 60 + s + (millis || 0) / 1000;
                    return isNeg ? -result : result;
                };

                // Helper to convert seconds to timestamp (supports negative values)
                const secondsToVtt = (totalSeconds) => {
                    const EPSILON = 0.001;
                    if (Math.abs(totalSeconds) < EPSILON) {
                        totalSeconds = 0;
                    }

                    const isNegative = totalSeconds < 0;
                    const absSeconds = Math.abs(totalSeconds);

                    let h = Math.floor(absSeconds / 3600);
                    let m = Math.floor((absSeconds % 3600) / 60);
                    let s = absSeconds % 60;
                    let sInt = Math.floor(s);
                    let msInt = Math.round((s - sInt) * 1000);

                    if (msInt >= 1000) {
                        msInt = 0;
                        sInt += 1;
                        if (sInt >= 60) {
                            sInt = 0;
                            m += 1;
                            if (m >= 60) {
                                m = 0;
                                h += 1;
                            }
                        }
                    }

                    const sign = isNegative ? '-' : '';
                    return `${sign}${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${sInt.toString().padStart(2, '0')}.${msInt.toString().padStart(3, '0')}`;
                };

                // CRITICAL FIX: Convert absolute timestamps to relative timestamps
                // If the JSON has entries with absolute VTT times (e.g., "00:00:10.000")
                // convert them to relative times (e.g., "00:00:00.000") by subtracting themeStart
                if (startSeconds !== null && startSeconds !== undefined && Object.keys(allCueFormatting).length > 0) {
                    const absoluteKeysToRemove = [];
                    const newEntries = {};

                    for (const [timestamp, formatting] of Object.entries(allCueFormatting)) {
                        const timestampSeconds = vttToSeconds(timestamp);

                        // Check if this looks like an absolute timestamp (>= theme start)
                        // Absolute timestamps are typically large (e.g., 10s = theme start, 26s = later in video)
                        // Relative timestamps should be small (e.g., 0s, 0.754s, etc.)
                        if (timestampSeconds >= startSeconds - 0.5) { // Allow 0.5s tolerance
                            // This looks like an absolute timestamp, convert to relative
                            const relativeSeconds = timestampSeconds - startSeconds;
                            const relativeTimestamp = secondsToVtt(relativeSeconds);

                            // Check if a relative version already exists
                            if (allCueFormatting[relativeTimestamp]) {
                                // Relative version exists, keep it and remove absolute
                                absoluteKeysToRemove.push(timestamp);
                            } else {
                                // No relative version exists, move the formatting
                                newEntries[relativeTimestamp] = formatting;
                                absoluteKeysToRemove.push(timestamp);
                            }
                        }
                    }

                    // Remove absolute timestamp entries
                    for (const key of absoluteKeysToRemove) {
                        delete allCueFormatting[key];
                    }

                    // Add converted entries
                    Object.assign(allCueFormatting, newEntries);

                    if (absoluteKeysToRemove.length > 0) {
                        // Save the corrected version
                        fetch('/api/save-subtitle-formatting', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder: folderNumber,
                                theme: themeNumber,
                                formatting: allCueFormatting
                            })
                        }).then(() => {}); // console.log('   ‚úì Saved corrected formatting')
                    }
                }

                // Clean up duplicate entries (caused by Math.max(0, ...) bug fix)
                // Remove entries like "00:00:00.000" if "-00:00:00.001" exists (same subtitle)
                const keysToRemove = [];
                const keys = Object.keys(allCueFormatting);

                // Find duplicates: positive and negative versions of ~same time
                for (const key of keys) {
                    if (key.startsWith('-')) {
                        const absSeconds = Math.abs(vttToSeconds(key));
                        // Check if there's a corresponding positive key
                        for (const otherKey of keys) {
                            if (!otherKey.startsWith('-')) {
                                const otherSeconds = vttToSeconds(otherKey);
                                // If positive key is within 1 second of absolute negative key
                                if (Math.abs(otherSeconds - absSeconds) < 0.01) {
                                    // Mark positive key for removal (keep negative version)
                                    if (!keysToRemove.includes(otherKey)) {
                                        keysToRemove.push(otherKey);
// console.log(`   üßπ Removing duplicate: ${otherKey} (kept: ${key})`);
                                    }
                                }
                            }
                        }
                    }
                }

                // Remove duplicates
                for (const key of keysToRemove) {
                    delete allCueFormatting[key];
                }

                if (keysToRemove.length > 0) {
// console.log(`   üßπ Cleaned up ${keysToRemove.length} duplicate entries`);
                    // Save cleaned up version
                    fetch('/api/save-subtitle-formatting', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            folder: folderNumber,
                            theme: themeNumber,
                            formatting: allCueFormatting
                        })
                    }).then(() => {}); // console.log('   ‚úì Saved cleaned formatting')
                }

                // MIGRATION: Detect old format (timestamp_hash keys) and migrate to sequence keys
                // Old format keys contain ':' or '_' (e.g., "00:00:00.000_364d")
                // New format keys are simple numbers (e.g., "1", "2", "3")
                const formattingKeys = Object.keys(allCueFormatting);
                const hasOldFormatKeys = formattingKeys.some(key => key.includes(':') || key.includes('_'));

                if (hasOldFormatKeys && formattingKeys.length > 0) {
                    console.log('üîÑ Detected old format keys, migrating to sequence numbers...');

                    // Ensure allThemeCues is loaded
                    if (allThemeCues.length === 0) {
                        await loadThemeCues();
                    }

                    // Helper to extract timestamp from old key (handle both "timestamp" and "timestamp_hash")
                    const extractTimestamp = (key) => {
                        if (key.includes('_')) {
                            return key.split('_')[0]; // "00:00:00.000_364d" ‚Üí "00:00:00.000"
                        }
                        return key; // Already just timestamp
                    };

                    // Create new formatting with sequence keys
                    const newFormatting = {};
                    let migratedCount = 0;

                    for (const [oldKey, formatting] of Object.entries(allCueFormatting)) {
                        const timestamp = extractTimestamp(oldKey);

                        // Find matching cue by timestamp and text
                        const matchingCue = allThemeCues.find(cue => {
                            // Match by timestamp and optionally by text if available
                            const timestampMatch = cue.start === timestamp;
                            const textMatch = !formatting._text || cue.text === formatting._text;
                            return timestampMatch && textMatch;
                        });

                        if (matchingCue && matchingCue.sequence) {
                            // Migrate to new format with sequence key
                            newFormatting[matchingCue.sequence] = {
                                sequence: matchingCue.sequence,
                                timestamp: timestamp,
                                html: formatting.html,
                                _text: formatting._text || matchingCue.text
                            };
                            migratedCount++;
                            console.log(`   ‚úì Migrated "${oldKey}" ‚Üí sequence "${matchingCue.sequence}"`);
                        } else {
                            // Couldn't find match, keep old entry (will be cleaned up later)
                            console.log(`   ‚ö†Ô∏è Could not find match for "${oldKey}", keeping as-is`);
                            newFormatting[oldKey] = formatting;
                        }
                    }

                    // Update allCueFormatting with migrated data
                    allCueFormatting = newFormatting;

                    // Save migrated format to server
                    if (migratedCount > 0) {
                        console.log(`   ‚úÖ Migrated ${migratedCount} entries to sequence keys`);
                        fetch('/api/save-subtitle-formatting', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder: folderNumber,
                                theme: themeNumber,
                                formatting: allCueFormatting
                            })
                        }).then(() => {
                            console.log('   üíæ Saved migrated formatting to server');
                        }).catch(err => {
                            console.error('   ‚úó Failed to save migrated formatting:', err);
                        });
                    }
                }

                // Convert <font> tags to <span style="..."> for better CSS compatibility
                const fontSizeMap = { '1': 0.6, '2': 0.8, '3': 1.0, '4': 1.2, '5': 1.4, '6': 1.6, '7': 1.8 };

                const convertFontTags = (html) => {
                    // Pattern: <font color="#..." size="X">text</font>
                    return html.replace(/<font\s+([^>]+)>/gi, (match, attributes) => {
                        let color = '';
                        let size = '';

                        // Extract color attribute
                        const colorMatch = attributes.match(/color="([^"]+)"/);
                        if (colorMatch) {
                            color = `color: ${colorMatch[1]}; `;
                        }

                        // Extract size attribute and convert to em
                        const sizeMatch = attributes.match(/size="([^"]+)"/);
                        if (sizeMatch) {
                            const sizeValue = sizeMatch[1];
                            const emValue = fontSizeMap[sizeValue] || 1.0;
                            size = `font-size: ${emValue}em; `;
                        }

                        return `<span style="${color}${size}">`;
                    }).replace(/<\/font>/gi, '</span>');
                };

                for (const cueStart in allCueFormatting) {
                    const cueData = allCueFormatting[cueStart];
                    if (cueData.html) {
                        const originalHtml = cueData.html;
                        cueData.html = convertFontTags(cueData.html);
                        if (originalHtml !== cueData.html) {
                            // console.log("   Converted:", originalHtml, ‚Üí, cueData.html);', originalHtml, '‚Üí', cueData.html);
                        }
                    }
                }

// console.log('üìù Loaded formatting for', Object.keys(allCueFormatting).length, 'cues:', Object.keys(allCueFormatting));

                // Don't apply formatting here - let the cuechange handler apply it
                // when each cue becomes active (avoids applying wrong cue's formatting)
            } catch (error) {
// console.error('Failed to load subtitle formatting:', error);
            }
        }

        // Auto-save subtitle edit
        function autoSaveSubtitle() {
            if (subtitleAutoSaveTimeout) {
                clearTimeout(subtitleAutoSaveTimeout);
            }

            subtitleAutoSaveTimeout = setTimeout(async () => {
                try {
                    const textarea = document.getElementById('subtitle-text');
                    const newText = textarea.innerText.trim();

                    // Don't save if there's no text or no current cue
                    if (!newText) {
                        return;
                    }

                    // Show saving indicator
                    const indicator = document.getElementById('preview-autosave-indicator');
                    indicator.textContent = '‚è≥ Saving...';
                    indicator.classList.add('show', 'saving');

                    // If we have currentCueInfo, update that specific cue
                    if (currentCueInfo) {
                        // Find and update the current cue
                        const cueIndex = allThemeCues.findIndex(cue =>
                            cue.start === currentCueInfo.start && cue.end === currentCueInfo.end
                        );

                        if (cueIndex !== -1) {
                            allThemeCues[cueIndex].text = newText;
                        }
                    }

                    // Save to server
                    const response = await fetch('/api/save-theme-subtitles', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            folder: folderNumber,
                            theme: themeNumber,
                            cues: allThemeCues
                        })
                    });

                    if (!response.ok) throw new Error('Failed to save subtitle');

                    // Reload the subtitle track to show changes
                    if (previewVideo) {
                        // Remove ALL existing tracks
                        const existingTracks = previewVideo.querySelectorAll('track');
                        existingTracks.forEach(track => track.remove());

                        // Clear the textTracks list
                        while (previewVideo.textTracks.length > 0) {
                            previewVideo.textTracks[0].mode = 'disabled';
                        }

                        // Create new track
                        const newTrack = document.createElement('track');
                        newTrack.id = 'preview-subtitle-track';
                        newTrack.kind = 'subtitles';
                        newTrack.srclang = 'en';
                        newTrack.label = 'English';
                        newTrack.default = false;
                        newTrack.src = `/api/subtitles/${folderNumber}/${themeNumber}.vtt?start=${startSeconds}&end=${endSeconds}&t=${Date.now()}`;

                        // Add to DOM
                        previewVideo.appendChild(newTrack);

                        // Keep mode as 'showing' so cues are loaded and accessible
                        setTimeout(() => {
                            if (previewVideo.textTracks.length > 0) {
                                const textTrack = previewVideo.textTracks[0];
                                if (textTrack) {
                                    textTrack.mode = 'showing';
                                }
                            }
                        }, 100);
                    }

                    indicator.textContent = '‚úì Saved';
                    indicator.classList.remove('saving');

                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                } catch (error) {
                    const indicator = document.getElementById('preview-autosave-indicator');
                    indicator.textContent = '‚úó Save failed';
                    indicator.classList.remove('saving');
                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                }
            }, 800); // Wait 800ms after typing stops
        }

        // Load theme details
        async function loadTheme() {
            try {
                const response = await fetch(`/api/folder/${folderNumber}/themes`);
                if (!response.ok) throw new Error('Failed to load theme');

                const data = await response.json();
                themeData = data.themes.find(t => t.number === themeNumber);

                if (!themeData) throw new Error('Theme not found');

                // Store ORIGINAL values from themes.md (for reset button)
                originalStartSeconds = parseTime(themeData.start);
                originalEndSeconds = parseTime(themeData.end);

                // Use ADJUSTED values for display if they exist, otherwise use original
                if (themeData.adjusted_start && themeData.adjusted_end) {
                    startSeconds = parseTime(themeData.adjusted_start);
                    endSeconds = parseTime(themeData.adjusted_end);
                } else {
                    startSeconds = originalStartSeconds;
                    endSeconds = originalEndSeconds;
                }

                // Use adjusted title if available
                const displayTitle = themeData.adjusted_title || themeData.title || '';

                // Construct video path from folder and actual video filename
                if (data.video_filename) {
                    videoPath = `videos/${data.folder}/${encodeURIComponent(data.video_filename)}`;
                } else {
                    // Fallback: try to construct from title (old behavior)
                    videoPath = `videos/${data.folder}/${encodeURIComponent(data.title)}.mp4`;
                }

                // Update info display
                document.getElementById('theme-number').textContent = `Theme ${themeData.number}`;
                document.getElementById('theme-name').textContent = displayTitle;
                const fullPath = `videos/${data.folder}`;
                const folderLocationEl = document.getElementById('folder-location');
                folderLocationEl.textContent = fullPath;
                folderLocationEl.title = fullPath;

                // Update header with theme info
                document.getElementById('header-title').textContent = `Adjust Theme ${themeData.number}`;
                document.getElementById('header-theme-name').textContent = displayTitle;

                document.getElementById('subtitle-text').innerHTML = themeData.text || '';

                // Load all theme cues for subtitle editing (must be awaited for sequence matching)
                await loadThemeCues();

                // Load subtitle formatting metadata and apply to editor
                await loadSubtitleFormatting();

                // Load VTT subtitles
                const subtitleTrack = document.getElementById('subtitle-track');
                subtitleTrack.src = `/api/subtitles/${folderNumber}.vtt`;
                originalVideo.textTracks.addEventListener('addtrack', (event) => {
                    const track = event.track;
                    track.mode = 'showing';
                });

                // Promise wrapper for video loading
                const loadVideo = (video, src) => {
                    return new Promise((resolve, reject) => {
                        video.addEventListener('loadedmetadata', () => {
                            fullVideoDuration = video.duration;
                            resolve();
                        }, { once: true });

                        video.addEventListener('error', (e) => {
                            reject(new Error('Failed to load video'));
                        }, { once: true });

                        video.src = src;
                    });
                };

                // Load original video first to get full duration
                await loadVideo(originalVideo, videoPath);

                // Calculate buffer range
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);
                bufferedDuration = bufferEnd - bufferStart;

                // Load preview with theme clip range
                previewVideo.src = `${videoPath}#t=${startSeconds},${endSeconds}`;

                // Wait for preview to load
                await loadVideo(previewVideo, previewVideo.src);

                // Load original video with buffered range - this makes seekbar show buffer duration
                originalVideo.src = `${videoPath}#t=${bufferStart},${bufferEnd}`;

                // Wait for original video to reload with range
                await new Promise(resolve => {
                    originalVideo.addEventListener('loadedmetadata', () => {
                        // Update buffer info display
                        document.getElementById('buffer-info').textContent =
                            `Buffer range: ${formatTime(bufferStart)} - ${formatTime(bufferEnd)} (${formatTime(bufferedDuration)})`;

                        // Set video position to theme start time
                        originalVideo.currentTime = startSeconds;

                        resolve();
                    }, { once: true });
                });

                // Show content
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('content').classList.remove('hidden');

                // Initial UI update
                updateUI();
                setupDragHandlers();

                // Setup custom video controls
                setupVideoControls();

                // Initialize time extension inputs with current theme extension values
                updateTimeExtensionInputs();

            } catch (error) {
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('error').textContent = error.message;
                document.getElementById('error').classList.remove('hidden');
            }
        }

        // Update original video playback range (buffered range)
        function updateOriginalVideoRange() {
            if (!videoPath || !fullVideoDuration || startSeconds === null || startSeconds === undefined || endSeconds === null || endSeconds === undefined) return;

            const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
            const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);
            bufferedDuration = bufferEnd - bufferStart;

            // Set video to buffer start position if outside range
            if (originalVideo.currentTime < bufferStart || originalVideo.currentTime > bufferEnd) {
                originalVideo.currentTime = bufferStart;
            }
        }

        // Update preview video with clipped range
        function reloadSubtitleTrack() {
//             console.log('üîÑ reloadSubtitleTrack called');
            // console.log("   startSeconds:", startSeconds);', startSeconds);
            // console.log("   endSeconds:", endSeconds);', endSeconds);

            // Reload VTT subtitle track with current time range
            if (!previewVideo || !folderNumber || !themeNumber) return;

            // console.log("   Before reload - overlay:", document.getElementById(subtitle-preview-text)?.textContent);', document.getElementById('subtitle-preview-text')?.textContent);

            // Clear ALL derived state FIRST to prevent stale subtitle display
            currentCueInfo = null;

            // Clear the subtitle editor
            const subtitleText = document.getElementById('subtitle-text');
            if (subtitleText) {
                subtitleText.innerHTML = '';
            }

            // Clear the preview overlay
            const previewOverlay = document.getElementById('subtitle-preview-text');
            if (previewOverlay) {
                previewOverlay.textContent = '';
            }

            // console.log("   After clear - overlay:", document.getElementById(subtitle-preview-text)?.textContent);', document.getElementById('subtitle-preview-text')?.textContent);

            // Remove ALL existing track elements from the video
            const existingTracks = previewVideo.querySelectorAll('track');
            existingTracks.forEach(track => track.remove());

            // Clear the textTracks list (internal browser cache)
            while (previewVideo.textTracks.length > 0) {
                previewVideo.textTracks[0].mode = 'disabled';
            }

            // Create new track with current time range
            const newSrc = `/api/subtitles/${folderNumber}/${themeNumber}.vtt?start=${startSeconds}&end=${endSeconds}&t=${Date.now()}`;

            const newTrack = document.createElement('track');
            newTrack.id = 'preview-subtitle-track';
            newTrack.kind = 'subtitles';
            newTrack.srclang = 'en';
            newTrack.label = 'English';
            newTrack.default = false;
            newTrack.src = newSrc;

            // Add to DOM
            previewVideo.appendChild(newTrack);

            // Enable track after it loads - do NOT sync immediately
            // Let the natural timeupdate event trigger syncSubtitleToTextarea
            // when cues are actually parsed and ready
            setTimeout(() => {
                if (previewVideo.textTracks.length > 0) {
                    previewVideo.textTracks[0].mode = 'showing';
                }
            }, 50);
        }

        function updatePreviewBoundaries() {
            // Update only the theme boundaries without resetting video
            // This is called during timeline drag to keep preview in sync
            if (!previewVideo || startSeconds === null || startSeconds === undefined || endSeconds === null || endSeconds === undefined) return;

            // Update boundary markers
            previewVideo.dataset.themeStart = startSeconds;
            previewVideo.dataset.themeEnd = endSeconds;
        }

        function updatePreviewVideo() {
            if (!videoPath || startSeconds === null || startSeconds === undefined || endSeconds === null || endSeconds === undefined) return;

            // Load full video and use JavaScript to enforce theme boundaries
            // Add cache-busting parameter to force reload when src doesn't change
            previewVideo.src = videoPath + (videoPath.includes('?') ? '&' : '?') + 't=' + Date.now();
            previewVideo.loop = true;
            previewVideo.muted = false;

            // Store theme boundaries for enforcement
            previewVideo.dataset.themeStart = startSeconds;
            previewVideo.dataset.themeEnd = endSeconds;

            // Remove old listeners
            if (previewVideo.boundariesHandler) {
                previewVideo.removeEventListener('timeupdate', previewVideo.boundariesHandler);
            }
            if (previewVideo.timeUpdateHandler) {
                previewVideo.removeEventListener('timeupdate', previewVideo.timeUpdateHandler);
            }
            if (previewVideo.subtitleSyncHandler) {
                previewVideo.removeEventListener('timeupdate', previewVideo.subtitleSyncHandler);
            }
            if (previewVideo.seekbarHandler) {
                previewSeekbar.removeEventListener('input', previewVideo.seekbarHandler);
            }
            if (previewVideo.playBtnHandler) {
                previewPlayBtn.removeEventListener('click', previewVideo.playBtnHandler);
            }
            if (previewVideo.clickHandler) {
                previewVideo.removeEventListener('click', previewVideo.clickHandler);
            }
            if (previewVideo.playHandler) {
                previewVideo.removeEventListener('play', previewVideo.playHandler);
            }
            if (previewVideo.pauseHandler) {
                previewVideo.removeEventListener('pause', previewVideo.pauseHandler);
            }

            // Enforce theme boundaries and loop
            const enforceThemeBoundaries = () => {
                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd);

                // If video is past theme end and playing, loop back to start
                if (previewVideo.currentTime >= themeEnd && !previewVideo.paused) {
                    previewVideo.currentTime = themeStart;
                }
            };

            // Sync current subtitle from VTT to textarea
            const syncSubtitleToTextarea = () => {
                const textTrack = previewVideo.textTracks[0];
                if (!textTrack || !textTrack.cues || textTrack.cues.length === 0) return;

                const activeCues = textTrack.activeCues;
                if (activeCues.length > 0) {
                    const currentCue = activeCues[0];
                    const subtitleText = document.getElementById('subtitle-text');

//                     console.log('üîÑ syncSubtitleToTextarea called');
                    // console.log("   currentCue.startTime:", currentCue.startTime);', currentCue.startTime);
                    // console.log("   currentCue.text:", currentCue.text);', currentCue.text);
                    // console.log("   previewVideo.currentTime:", previewVideo.currentTime);', previewVideo.currentTime);
                    // console.log("   currentCueInfo:", currentCueInfo);', currentCueInfo);

                    // Convert cue time (seconds) to HH:MM:SS.mmm format for matching with API
                    // Supports negative values for subtitles before theme start
                    const vttToTimestamp = (seconds) => {
                        // Round near-zero values to exactly 0 to avoid floating point precision issues
                        // This prevents -0.000353 from becoming "-00:00:00.000" which won't match "00:00:00.000"
                        const EPSILON = 0.001; // 1ms threshold (increased from 0.0005)
                        if (Math.abs(seconds) < EPSILON) {
                            seconds = 0;
                        }

                        const isNegative = seconds < 0;
                        const absSeconds = Math.abs(seconds);

                        const h = Math.floor(absSeconds / 3600);
                        const m = Math.floor((absSeconds % 3600) / 60);
                        let s = absSeconds % 60;
                        let sInt = Math.floor(s);
                        let msInt = Math.round((s - sInt) * 1000);

                        // Handle millisecond rollover (e.g., 15.999 ‚Üí 16.000)
                        if (msInt >= 1000) {
                            msInt = 0;
                            sInt += 1;
                            if (sInt >= 60) {
                                sInt = 0;
                                m += 1;
                                if (m >= 60) {
                                    m = 0;
                                    h += 1;
                                }
                            }
                        }

                        const sign = isNegative ? '-' : '';
                        return `${sign}${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${sInt.toString().padStart(2, '0')}.${msInt.toString().padStart(3, '0')}`;
                    };

                    // IMPORTANT: Use themeStart from dataset, not closure variable
                    // This ensures correct timing when timeline is expanded/contracted
                    const themeStart = parseFloat(previewVideo.dataset.themeStart);

                    // Track current cue info with matching format
                    // Convert VTT time (original video time) to trimmed time (relative to theme start)
                    // This ensures JSON keys match the trimmed SRT timestamps used for export
                    // Allow negative values to preserve formatting for subtitles before theme start
                    const trimmedStartTime = currentCue.startTime - themeStart;
                    const trimmedEndTime = currentCue.endTime - themeStart;

                    // Match VTT cue to allThemeCues to get the sequence number
                    // The sequence number is the stable SRT sequence (1, 2, 3, ...)
                    let sequence = null;

                    // IMPORTANT: The API returns absolute timestamps from the SRT file
                    // But currentCue.startTime/endTime are also absolute (from original video)
                    // So we should match using absolute timestamps, not relative ones
                    const absoluteTimestampKey = vttToTimestamp(currentCue.startTime);
                    const absoluteEndTimeKey = vttToTimestamp(currentCue.endTime);

                    // timestampKey/endKey are relative (for storage in JSON)
                    const timestampKey = vttToTimestamp(trimmedStartTime);
                    const endTimeKey = vttToTimestamp(trimmedEndTime);

                    // Find matching cue by timestamp and text
                    // Use more lenient text matching (normalize whitespace and newlines)
                    const normalizeText = (text) => text.trim().replace(/[\s\n\r]+/g, ' ');
                    let matchingCue = allThemeCues.find(cue => {
                        const timestampsMatch = cue.start === absoluteTimestampKey && cue.end === absoluteEndTimeKey;
                        if (!timestampsMatch) return false;
                        // Try exact match first, then normalized match
                        return cue.text === currentCue.text || normalizeText(cue.text) === normalizeText(currentCue.text);
                    });

                    // Fallback: match by timestamp only if text matching fails
                    // (handles cases where text has subtle differences)
                    if (!matchingCue) {
                        matchingCue = allThemeCues.find(cue =>
                            cue.start === absoluteTimestampKey && cue.end === absoluteEndTimeKey
                        );
                        if (matchingCue) {
                            console.warn('‚ö†Ô∏è Matched by timestamp only (text differs):');
                            console.warn('   VTT text:', currentCue.text);
                            console.warn('   API text:', matchingCue.text);
                        }
                    }

                    if (matchingCue && matchingCue.sequence) {
                        sequence = matchingCue.sequence;
                    } else {
                        // Debug: log why matching failed
                        console.warn('‚ö†Ô∏è Could not match cue to sequence number');
                        console.warn('   Looking for (ABSOLUTE):', { start: absoluteTimestampKey, end: absoluteEndTimeKey, text: `"${currentCue.text}"` });
                        console.warn('   Looking for (RELATIVE):', { start: timestampKey, end: endTimeKey, text: `"${currentCue.text}"` });
                        console.warn('   allThemeCues.length:', allThemeCues.length);

                        // Find cues with matching timestamp (using absolute)
                        const timestampMatches = allThemeCues.filter(c => c.start === absoluteTimestampKey);
                        console.warn(`   Found ${timestampMatches.length} cues with matching absolute timestamp:`, timestampMatches.map(c => ({
                            sequence: c.sequence,
                            start: c.start,
                            end: c.end,
                            text: `"${c.text}"`
                        })));

                        // Find cues with similar text (substring match)
                        const textMatches = allThemeCues.filter(c => c.text.includes(currentCue.text) || currentCue.text.includes(c.text));
                        if (textMatches.length > 0) {
                            console.warn(`   Found ${textMatches.length} cues with similar text:`, textMatches.map(c => ({
                                sequence: c.sequence,
                                start: c.start,
                                end: c.end,
                                text: `"${c.text}"`
                            })));
                        }
                    }

                    const newCueInfo = {
                        sequence: sequence,
                        timestamp: timestampKey,
                        start: timestampKey,
                        end: endTimeKey,
                        text: currentCue.text
                    };

                    // Only update if we've moved to a different cue (different timestamp OR different text)
                    if (!currentCueInfo || currentCueInfo.start !== newCueInfo.start || currentCueInfo.text !== newCueInfo.text) {
                        currentCueInfo = newCueInfo;

                        // Set flag to prevent auto-save during programmatic update
                        isProgrammaticUpdate = true;

                        console.log('üé¨ Cue changed:', currentCueInfo.sequence, currentCueInfo.timestamp, currentCueInfo.text);
                        console.log('   Looking for formatting in:', Object.keys(allCueFormatting));

                        // Load saved formatting for this cue using sequence as key
                        const key = currentCueInfo.sequence;
                        const formatting = key !== null ? allCueFormatting[key] : null;

                        if (formatting && formatting.html) {
                            // Use the saved HTML which has selective formatting preserved
                            console.log('   ‚úÖ Found saved HTML, applying...');
                            console.log('   HTML to apply:', formatting.html);

                            const html = formatting.html;

                            // Apply HTML directly using insertHTML (bypasses contenteditable sanitization)
                            subtitleText.focus();
                            document.execCommand('selectAll', false, null);
                            document.execCommand('insertHTML', false, html);

// console.log('   HTML after apply:', subtitleText.innerHTML);

                            // Set up observer to detect what's modifying the editor
                            const observer = new MutationObserver((mutations) => {
                                mutations.forEach((mutation) => {
                                    if (mutation.type === 'childList' || mutation.type === 'characterData') {
//                                         console.log('   ‚ö†Ô∏è Editor was modified! New content:', subtitleText.innerHTML);
//                                         console.trace('   Call stack:');
                                    }
                                });
                            });

                            observer.observe(subtitleText, { childList: true, subtree: true, characterData: true });

                            // Stop observing after 2 seconds
                            setTimeout(() => observer.disconnect(), 2000);

                            // Update subtitleFormatting for preview
                            subtitleFormatting = {
                                bold: formatting.bold || false,
                                italic: formatting.italic || false,
                                color: formatting.color || null,
                                size: formatting.size || null
                            };
                        } else {
                            console.log('   ‚ùå No saved formatting for this cue');
                            // No saved formatting, use plain text
                            subtitleText.innerHTML = currentCue.text;
                            subtitleFormatting = { bold: false, italic: false, color: null, size: null };
                        }

                        // Always update preview after programmatic cue change
                        // (Don't check focus here since we just focused the editor to apply HTML)
                        updateSubtitlePreview();

                        // Reset flag after programmatic update is complete
                        isProgrammaticUpdate = false;
                    }
                }
            };

            // Update time display and seekbar
            const updateTimeDisplay = () => {
                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd);
                const currentTime = previewVideo.currentTime;

                // Show time relative to theme start
                const relativeTime = currentTime - themeStart;
                const themeDuration = themeEnd - themeStart;

                // Update seekbar position (0-100% of theme duration)
                const seekbarPercent = (Math.max(0, relativeTime) / themeDuration) * 100;
                previewSeekbar.value = seekbarPercent;

                // Update time display
                document.getElementById('preview-time-display').textContent =
                    `${formatTime(Math.max(0, relativeTime))} / ${formatTime(themeDuration)}`;
            };

            // Handle seekbar input
            const handleSeekbarInput = () => {
                if (videoControlsLocked) return;

                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd);
                const themeDuration = themeEnd - themeStart;

                // Calculate target time based on seekbar percentage
                const relativeTime = (previewSeekbar.value / 100) * themeDuration;
                previewVideo.currentTime = themeStart + relativeTime;
            };

            // Toggle play/pause
            const togglePlayPause = () => {
                if (videoControlsLocked) return;

                if (previewVideo.paused) {
                    previewVideo.play();
                } else {
                    previewVideo.pause();
                }
            };

            // Update play button icon
            const updatePlayButton = () => {
                previewPlayBtn.textContent = previewVideo.paused ? '‚ñ∂' : '‚è∏';
            };

            // Add new listeners
            previewVideo.boundariesHandler = enforceThemeBoundaries;
            previewVideo.addEventListener('timeupdate', enforceThemeBoundaries);

            previewVideo.subtitleSyncHandler = syncSubtitleToTextarea;
            previewVideo.addEventListener('timeupdate', syncSubtitleToTextarea);

            previewVideo.timeUpdateHandler = updateTimeDisplay;
            previewVideo.addEventListener('timeupdate', updateTimeDisplay);

            previewVideo.seekbarHandler = handleSeekbarInput;
            previewSeekbar.addEventListener('input', handleSeekbarInput);

            previewVideo.playBtnHandler = togglePlayPause;
            previewPlayBtn.addEventListener('click', togglePlayPause);

            previewVideo.clickHandler = togglePlayPause;
            previewVideo.addEventListener('click', togglePlayPause);

            previewVideo.playHandler = updatePlayButton;
            previewVideo.addEventListener('play', updatePlayButton);

            previewVideo.pauseHandler = updatePlayButton;
            previewVideo.addEventListener('pause', updatePlayButton);

            // When video loads metadata, seek to theme start
            previewVideo.addEventListener('loadedmetadata', () => {
                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                previewVideo.currentTime = themeStart;
                updateTimeDisplay();
                updatePlayButton();

                // Clear ALL subtitle state to prevent stale display
                // Do NOT enable track here - let reloadSubtitleTrack() handle it
                currentCueInfo = null;

                const subtitleText = document.getElementById('subtitle-text');
                if (subtitleText) {
                    subtitleText.innerHTML = '';
                }

                const previewOverlay = document.getElementById('subtitle-preview-text');
                if (previewOverlay) {
                    previewOverlay.textContent = '';
                }

                // Do NOT enable track here - reloadSubtitleTrack() will handle it
                // Enabling the track here would cause old cues to be displayed before
                // reloadSubtitleTrack() replaces the track with the updated one
            }, { once: true });

            // Fallback: Also seek after a delay in case loadedmetadata doesn't fire
            // This can happen when the browser thinks the video src hasn't changed
            setTimeout(() => {
                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                if (previewVideo.currentTime !== themeStart && previewVideo.readyState >= 2) {
                    previewVideo.currentTime = themeStart;
                    updateTimeDisplay();
                }
            }, 500);

            // Load VTT subtitles for preview - use adjusted subtitles if available
            // Clear current cue info
            currentCueInfo = null;

            // Don't clear allCueFormatting - we want saved styles to persist

            const subtitleTextClear = document.getElementById('subtitle-text');
            if (subtitleTextClear) {
                subtitleTextClear.innerHTML = '';
            }

            // Remove ALL existing tracks first
            const existingTracks = previewVideo.querySelectorAll('track');
            existingTracks.forEach(track => track.remove());

            // Clear the textTracks list
            while (previewVideo.textTracks.length > 0) {
                previewVideo.textTracks[0].mode = 'disabled';
            }

            if (folderNumber && themeNumber) {
                // Create new track
                const newTrack = document.createElement('track');
                newTrack.id = 'preview-subtitle-track';
                newTrack.kind = 'subtitles';
                newTrack.srclang = 'en';
                newTrack.label = 'English';
                newTrack.default = false;
                newTrack.src = `/api/subtitles/${folderNumber}/${themeNumber}.vtt?start=${startSeconds}&end=${endSeconds}`;

                // Add to DOM
                previewVideo.appendChild(newTrack);

                // Keep mode as 'showing' so cues are loaded and accessible
                setTimeout(() => {
                    if (previewVideo.textTracks.length > 0) {
                        const textTrack = previewVideo.textTracks[0];
                        if (textTrack) {
                            textTrack.mode = 'showing';
                        }
                    }
                }, 100);
            }


            // Don't autoplay
            // previewVideo.play().catch(() => {});
        }

        // Update UI
        function updateUI() {
            if (!fullVideoDuration) return;

            const clipDuration = endSeconds - startSeconds;
            const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
            const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);
            bufferedDuration = bufferEnd - bufferStart;

            // Position buffer range on full video timeline
            const bufferLeftPercent = (bufferStart / fullVideoDuration) * 100;
            const bufferWidthPercent = (bufferedDuration / fullVideoDuration) * 100;
            bufferRange.style.left = `${bufferLeftPercent}%`;
            bufferRange.style.width = `${bufferWidthPercent}%`;

            // Position theme box within buffer range
            const themeLeftPercent = ((startSeconds - bufferStart) / bufferedDuration) * 100;
            const themeWidthPercent = (clipDuration / bufferedDuration) * 100;
            themeBox.style.left = `${themeLeftPercent}%`;
            themeBox.style.width = `${themeWidthPercent}%`;
            themeBoxContent.textContent = `${formatTime(startSeconds)} - ${formatTime(endSeconds)}`;

            // Update timeline markers to show full video range
            document.getElementById('time-start-marker').textContent = '00:00:00';
            document.getElementById('time-end-marker').textContent = formatTime(fullVideoDuration);

            // Update info display
            document.getElementById('display-start').textContent = formatTime(startSeconds);
            document.getElementById('display-end').textContent = formatTime(endSeconds);
            document.getElementById('display-duration').textContent = formatTime(clipDuration);

            // Update buffer display with separate left/right values
            const bufferLeftMin = Math.round(bufferLeftSeconds / 60);
            const bufferRightMin = Math.round(bufferRightSeconds / 60);
            document.getElementById('buffer-display').textContent = `L: ¬±${bufferLeftMin}min | R: ¬±${bufferRightMin}min`;

            // Update buffer info on video
            document.getElementById('buffer-info').textContent =
                `Buffer range: ${formatTime(bufferStart)} - ${formatTime(bufferEnd)} (${formatTime(bufferedDuration)})`;

            // Update subtitle preview
            updateSubtitlePreview();

            // Update preview video during drag by updating boundaries
            // Don't reset the video (which causes position 0 issue)
            if (!isDragging) {
                // Not dragging - do full preview video update
                updatePreviewVideo();
            } else {
                // During drag - only update boundaries, don't reset video
                updatePreviewBoundaries();
            }

            // NOTE: Don't reload subtitle track during drag - only after drag completes
            // This prevents continuous reloading which causes performance issues

            // Update original video to show only buffered range (but not during drag)
            if (!isDragging) {
                updateOriginalVideoRange();
            }
        }

        // Setup drag handlers
        function setupDragHandlers() {
            // Left handle - adjust start time
            handleLeft.addEventListener('mousedown', (e) => {
                isDragging = 'left';
                dragStartX = e.clientX;
                dragStartValue = startSeconds;
                themeStartBeforeDrag = startSeconds; // Track theme start before drag
                e.preventDefault();
                e.stopPropagation();
            });

            // Right handle - adjust end time
            handleRight.addEventListener('mousedown', (e) => {
                isDragging = 'right';
                dragStartX = e.clientX;
                dragStartValue = endSeconds;
                themeEndBeforeDrag = endSeconds; // Track theme end before drag
                e.preventDefault();
                e.stopPropagation();
            });

            // Hover effects - highlight theme box edges
            handleLeft.addEventListener('mouseenter', () => {
                themeBox.classList.add('highlight-left');
            });

            handleLeft.addEventListener('mouseleave', () => {
                themeBox.classList.remove('highlight-left');
            });

            handleRight.addEventListener('mouseenter', () => {
                themeBox.classList.add('highlight-right');
            });

            handleRight.addEventListener('mouseleave', () => {
                themeBox.classList.remove('highlight-right');
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - dragStartX;
                // Use full video duration for drag calculations
                const deltaTime = (deltaX / timelineTrack.offsetWidth) * fullVideoDuration;

                if (isDragging === 'left') {
                    let newStart = dragStartValue + deltaTime;
                    newStart = Math.max(0, Math.min(newStart, endSeconds - 20));
                    startSeconds = newStart;
                } else if (isDragging === 'right') {
                    let newEnd = dragStartValue + deltaTime;
                    newEnd = Math.max(startSeconds + 20, Math.min(newEnd, fullVideoDuration));
                    endSeconds = newEnd;
                }

                updateUI();
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                        console.log('üñ±Ô∏è DRAG END - Timeline extended');

                    // Calculate theme start offset when dragging left handle
                    const timeOffset = startSeconds - themeStartBeforeDrag;

                    if (isDragging === 'left' && timeOffset !== 0) {
                        console.log(`   Theme start shifted by ${timeOffset}s`);
                        console.log(`   Old theme start: ${themeStartBeforeDrag}s`);
                        console.log(`   New theme start: ${startSeconds}s`);
                        console.log(`   Keys before:`, Object.keys(allCueFormatting));

                        // CRITICAL: Update timestamps only, don't regenerate keys
                        // Sequence keys are stable and don't change
                        const vttToSeconds = (vttTimestamp) => {
                            const [time, millis] = vttTimestamp.split('.');
                            const isNegative = time.startsWith('-');
                            const [h, m, s] = time.replace('-', '').split(':').map(Number);
                            const result = h * 3600 + m * 60 + s + (millis || 0) / 1000;
                            return isNegative ? -result : result;
                        };

                        const secondsToVtt = (totalSeconds) => {
                            const EPSILON = 0.001;
                            if (Math.abs(totalSeconds) < EPSILON) {
                                totalSeconds = 0;
                            }
                            const isNegative = totalSeconds < 0;
                            const absSeconds = Math.abs(totalSeconds);
                            let h = Math.floor(absSeconds / 3600);
                            let m = Math.floor((absSeconds % 3600) / 60);
                            let s = absSeconds % 60;
                            let sInt = Math.floor(s);
                            let msInt = Math.round((s - sInt) * 1000);
                            if (msInt >= 1000) {
                                msInt = 0;
                                sInt += 1;
                                if (sInt >= 60) {
                                    sInt = 0;
                                    m += 1;
                                    if (m >= 60) {
                                        m = 0;
                                        h += 1;
                                    }
                                }
                            }
                            const sign = isNegative ? '-' : '';
                            return `${sign}${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${sInt.toString().padStart(2, '0')}.${msInt.toString().padStart(3, '0')}`;
                        };

                        // Update timestamp field for each sequence key
                        for (const [seqKey, formatting] of Object.entries(allCueFormatting)) {
                            const oldSeconds = vttToSeconds(formatting.timestamp);
                            const newSeconds = oldSeconds - timeOffset;  // Subtract offset
                            allCueFormatting[seqKey].timestamp = secondsToVtt(newSeconds);
                            console.log(`   Sequence ${seqKey}: ${formatting.timestamp} ‚Üí ${allCueFormatting[seqKey].timestamp}`);
                        }

                        console.log(`   Keys after (unchanged):`, Object.keys(allCueFormatting));

                        // Save formatting to server with updated timestamps
                        console.log('   Saving to server...');
                        fetch('/api/save-subtitle-formatting', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder: folderNumber,
                                theme: themeNumber,
                                formatting: allCueFormatting
                            })
                        }).then(res => res.json())
                          .then(data => console.log('   ‚úì Formatting saved:', data))
                          .catch(err => console.error('   ‚úó Failed to save formatting:', err));
                    }

                    // Handle right-side drag (theme end changes)
                    // Formatting keys are relative to themeStart, so they don't need to shift
                    // But we need to save to ensure styles are preserved
                    if (isDragging === 'right') {
                        const themeEndOffset = endSeconds - themeEndBeforeDrag;

                        if (themeEndOffset !== 0) {
                            console.log(`   Theme end shifted by ${themeEndOffset}s`);
                            console.log(`   Old theme end: ${themeEndBeforeDrag}s`);
                            console.log(`   New theme end: ${endSeconds}s`);
                            console.log(`   Formatting keys (no shift needed, relative to themeStart):`, Object.keys(allCueFormatting));

                            // For right-side drag, we don't shift keys (they're relative to themeStart)
                            // But we save to ensure styles are preserved even if subtitles are now out of bounds
                            console.log('   Saving formatting to preserve styles...');
                            fetch('/api/save-subtitle-formatting', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    folder: folderNumber,
                                    theme: themeNumber,
                                    formatting: allCueFormatting
                                })
                            }).then(res => res.json())
                              .then(data => console.log('   ‚úì Formatting saved:', data))
                              .catch(err => console.error('   ‚úó Failed to save formatting:', err));
                        }
                    }

                    // Drag ended - clear subtitle state FIRST before any video updates
                    // This prevents old cues from being displayed during the update process
                    currentCueInfo = null;

                    const subtitleText = document.getElementById('subtitle-text');
                    if (subtitleText) {
                        subtitleText.innerHTML = '';
                    }

                    const previewOverlay = document.getElementById('subtitle-preview-text');
                    if (previewOverlay) {
                        previewOverlay.textContent = '';
                    }

                    // Seek original video to new theme start position
                    originalVideo.currentTime = startSeconds;

                    // Now that drag is complete, do full preview video update with new time range
                    updatePreviewVideo();

                    // Reload subtitle track with new time range
                    reloadSubtitleTrack();

                    // Regenerate the adjust.srt file with new theme boundaries
                    // This converts absolute timestamps to relative timestamps
// console.log('   Regenerating adjust.srt with new theme boundaries...');

                    // Helper to parse VTT timestamp string to seconds
                    const vttToSeconds = (vttTimestamp) => {
                        const [time, millis] = vttTimestamp.split('.');
                        const [h, m, s] = time.split(':').map(Number);
                        return h * 3600 + m * 60 + s + (millis || 0) / 1000;
                    };

                    // Helper to convert seconds to VTT timestamp string
                    const secondsToVtt = (totalSeconds) => {
                        const h = Math.floor(totalSeconds / 3600);
                        const m = Math.floor((totalSeconds % 3600) / 60);
                        const s = totalSeconds % 60;
                        const sInt = Math.floor(s);
                        const ms = Math.round((s - sInt) * 1000);
                        return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${sInt.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
                    };

                    const adjustedCues = allThemeCues.map((cue, index) => {
                        const cueStartSec = vttToSeconds(cue.start);
                        const cueEndSec = vttToSeconds(cue.end);

                        return {
                            sequence: index + 1,
                            start: secondsToVtt(Math.max(0, cueStartSec - startSeconds)),
                            end: secondsToVtt(Math.max(0, cueEndSec - startSeconds)),
                            text: cue.text
                        };
                    });

                    fetch('/api/save-theme-subtitles', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            folder: folderNumber,
                            theme: themeNumber,
                            cues: adjustedCues
                        })
                    }).catch(err => console.error('Failed to regenerate adjust.srt:', err));

                    // Auto-save theme adjustment
                    autoSaveTheme();

                    // Update time extension inputs to reflect new theme boundaries
                    updateTimeExtensionInputs();
                }
                isDragging = null;
            });

            // Video buffer controls - adjust buffer on each side independently

            // Left side controls - adjust buffer before theme
            const leftDecreaseBtn = document.getElementById('video-buffer-decrease-left');
            const leftIncreaseBtn = document.getElementById('video-buffer-increase-left');
            const rightDecreaseBtn = document.getElementById('video-buffer-decrease-right');
            const rightIncreaseBtn = document.getElementById('video-buffer-increase-right');

            leftDecreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferLeftSeconds = Math.max(0, bufferLeftSeconds - 60);
                updateUI();
            });

            leftIncreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferLeftSeconds += 60;
                updateUI();
            });

            // Right side controls - adjust buffer after theme
            rightDecreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferRightSeconds = Math.max(0, bufferRightSeconds - 60);
                updateUI();
            });

            rightIncreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferRightSeconds += 60;
                updateUI();
            });

            // Helper function to convert time input (HH:MM:SS) to seconds
            const timeInputToSeconds = (timeInput) => {
                const parts = timeInput.split(':');
                if (parts.length === 3) {
                    const [h, m, s] = parts.map(Number);
                    return h * 3600 + m * 60 + s;
                }
                return 0;
            };

            // Apply left extension time from input fields
            const applyExtLeftBtn = document.getElementById('apply-ext-left');
            if (applyExtLeftBtn) {
                applyExtLeftBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();

                    const extLeftEnd = document.getElementById('ext-left-end');

                    if (extLeftEnd) {
                        const extensionSeconds = timeInputToSeconds(extLeftEnd.value);

                        // Move theme start earlier by the extension amount
                        const newStartSeconds = Math.max(0, originalStartSeconds - extensionSeconds);

                        // Handle formatting timestamp shift when theme start changes
                        const timeOffset = newStartSeconds - startSeconds;

                        if (Object.keys(allCueFormatting).length > 0 && timeOffset !== 0) {
                            const vttToSeconds = (vttTimestamp) => {
                                const [time, millis] = vttTimestamp.split('.');
                                const isNegative = time.startsWith('-');
                                const [h, m, s] = time.replace('-', '').split(':').map(Number);
                                const result = h * 3600 + m * 60 + s + (millis || 0) / 1000;
                                return isNegative ? -result : result;
                            };

                            const secondsToVtt = (totalSeconds) => {
                                const EPSILON = 0.001;
                                if (Math.abs(totalSeconds) < EPSILON) {
                                    totalSeconds = 0;
                                }
                                const isNegative = totalSeconds < 0;
                                const absSeconds = Math.abs(totalSeconds);
                                let h = Math.floor(absSeconds / 3600);
                                let m = Math.floor((absSeconds % 3600) / 60);
                                let s = absSeconds % 60;
                                let sInt = Math.floor(s);
                                let msInt = Math.round((s - sInt) * 1000);
                                if (msInt >= 1000) {
                                    msInt = 0;
                                    sInt += 1;
                                    if (sInt >= 60) {
                                        sInt = 0;
                                        m += 1;
                                        if (m >= 60) {
                                            m = 0;
                                            h += 1;
                                        }
                                    }
                                }
                                const sign = isNegative ? '-' : '';
                                return `${sign}${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${sInt.toString().padStart(2, '0')}.${msInt.toString().padStart(3, '0')}`;
                            };

                            // Update timestamps for each sequence key
                            for (const [seqKey, formatting] of Object.entries(allCueFormatting)) {
                                const oldSeconds = vttToSeconds(formatting.timestamp);
                                const newSeconds = oldSeconds - timeOffset;
                                allCueFormatting[seqKey].timestamp = secondsToVtt(newSeconds);
                            }

                            // Save formatting to server
                            fetch('/api/save-subtitle-formatting', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    folder: folderNumber,
                                    theme: themeNumber,
                                    formatting: allCueFormatting
                                })
                            }).then(res => res.json())
                              .then(data => console.log('   ‚úì Formatting saved'))
                              .catch(err => console.error('   ‚úó Failed to save formatting:', err));
                        }

                        startSeconds = newStartSeconds;

                        console.log(`üéØ Applied left extension: ${extLeftEnd.value} (${extensionSeconds}s earlier)`);
                        updateUI();
                        updatePreviewVideo();
                        reloadSubtitleTrack();

                        // Save adjusted theme boundaries to server
                        autoSaveTheme();
                    }
                });
            }

            // Apply right extension time from input fields
            const applyExtRightBtn = document.getElementById('apply-ext-right');
            if (applyExtRightBtn) {
                applyExtRightBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();

                    const extRightEnd = document.getElementById('ext-right-end');

                    if (extRightEnd) {
                        const extensionSeconds = timeInputToSeconds(extRightEnd.value);

                        // Move theme end later by the extension amount
                        const newEndSeconds = Math.min(fullVideoDuration, originalEndSeconds + extensionSeconds);

                        endSeconds = newEndSeconds;

                        console.log(`üéØ Applied right extension: ${extRightEnd.value} (${extensionSeconds}s later)`);
                        updateUI();
                        updatePreviewVideo();
                        reloadSubtitleTrack();

                        // Save adjusted theme boundaries to server
                        autoSaveTheme();
                    }
                });
            }

            // Reset timeline button - reset to original theme time range
            const resetTimelineBtn = document.getElementById('reset-timeline-btn');
            if (resetTimelineBtn) {
                resetTimelineBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    e.preventDefault();

                    const currentStart = startSeconds;
                    const timeOffset = originalStartSeconds - currentStart;

                    console.log('üîÑ Reset to original');
                    console.log(`   Current start: ${currentStart}s ‚Üí Original: ${originalStartSeconds}s`);
                    console.log(`   Time offset: ${timeOffset}s`);
                    console.log(`   Keys before:`, Object.keys(allCueFormatting));

                    // CRITICAL: Update timestamps only, don't regenerate keys
                    // Sequence keys are stable and don't change
                    if (Object.keys(allCueFormatting).length > 0 && timeOffset !== 0) {
                        const vttToSeconds = (vttTimestamp) => {
                            const [time, millis] = vttTimestamp.split('.');
                            const isNegative = time.startsWith('-');
                            const [h, m, s] = time.replace('-', '').split(':').map(Number);
                            const result = h * 3600 + m * 60 + s + (millis || 0) / 1000;
                            return isNegative ? -result : result;
                        };

                        const secondsToVtt = (totalSeconds) => {
                            const EPSILON = 0.001;
                            if (Math.abs(totalSeconds) < EPSILON) {
                                totalSeconds = 0;
                            }
                            const isNegative = totalSeconds < 0;
                            const absSeconds = Math.abs(totalSeconds);
                            let h = Math.floor(absSeconds / 3600);
                            let m = Math.floor((absSeconds % 3600) / 60);
                            let s = absSeconds % 60;
                            let sInt = Math.floor(s);
                            let msInt = Math.round((s - sInt) * 1000);
                            if (msInt >= 1000) {
                                msInt = 0;
                                sInt += 1;
                                if (sInt >= 60) {
                                    sInt = 0;
                                    m += 1;
                                    if (m >= 60) {
                                        m = 0;
                                        h += 1;
                                    }
                                }
                            }
                            const sign = isNegative ? '-' : '';
                            return `${sign}${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${sInt.toString().padStart(2, '0')}.${msInt.toString().padStart(3, '0')}`;
                        };

                        // Update timestamp field for each sequence key
                        for (const [seqKey, formatting] of Object.entries(allCueFormatting)) {
                            const oldSeconds = vttToSeconds(formatting.timestamp);
                            const newSeconds = oldSeconds - timeOffset;  // Subtract offset
                            allCueFormatting[seqKey].timestamp = secondsToVtt(newSeconds);
                            console.log(`   Sequence ${seqKey}: ${formatting.timestamp} ‚Üí ${allCueFormatting[seqKey].timestamp}`);
                        }

                        console.log(`   Keys after (unchanged):`, Object.keys(allCueFormatting));
                    }

                    // Save formatting to server with updated keys
                    console.log('   Saving to server...');
                    const saveResponse = await fetch('/api/save-subtitle-formatting', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            folder: folderNumber,
                            theme: themeNumber,
                            formatting: allCueFormatting
                        })
                    });

                    if (!saveResponse.ok) {
                        console.error('   ‚úó Failed to save formatting:', saveResponse.status);
                    } else {
                        const saveData = await saveResponse.json();
                        console.log('   ‚úì Formatting saved:', saveData);
                    }

                    // Reset to original values
                    startSeconds = originalStartSeconds;
                    endSeconds = originalEndSeconds;

                    // Keep currentCueInfo but don't clear formatting - styles should be preserved
                    currentCueInfo = null;

                    // Update UI (includes original video)
                    updateUI();

                    // IMPORTANT: Explicitly seek original video to the reset position
                    // This ensures the original video updates even if it's already in buffer range
                    originalVideo.currentTime = startSeconds;

                    // Update preview video with new time range
                    updatePreviewVideo();

                    // Reload subtitle track with new time range
                    reloadSubtitleTrack();

                    // Update time extension inputs - after reset they should be 00:00:00
                    updateTimeExtensionInputs();

                    // Delete the adjust file on server
                    try {
                        const response = await fetch('/api/reset-theme', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder: folderNumber,
                                theme: themeNumber
                            })
                        });

                        if (!response.ok) throw new Error('Failed to reset theme');

                        // Visual feedback
                        resetTimelineBtn.textContent = '‚úì Reset Complete';
                        setTimeout(() => {
                            resetTimelineBtn.innerHTML = '‚Ü∫ Reset to Original';
                        }, 1500);
                    } catch (error) {
// console.error('Error resetting theme:', error);
                        resetTimelineBtn.textContent = '‚úó Reset Failed';
                        setTimeout(() => {
                            resetTimelineBtn.innerHTML = '‚Ü∫ Reset to Original';
                        }, 1500);
                    }
                });
            }
        }

        // Setup custom video controls
        function setupVideoControls() {
            // Set initial volume
            originalVideo.volume = volumeSlider.value;

            // Play/Pause button
            playPauseBtn.addEventListener('click', () => {
                if (originalVideo.paused) {
                    originalVideo.play();
                    playPauseBtn.textContent = '‚è∏';
                } else {
                    originalVideo.pause();
                    playPauseBtn.textContent = '‚ñ∂';
                }
            });

            // Update play/pause button when video state changes
            originalVideo.addEventListener('play', () => {
                playPauseBtn.textContent = '‚è∏';
            });

            originalVideo.addEventListener('pause', () => {
                playPauseBtn.textContent = '‚ñ∂';
            });

            // Update seekbar as video plays
            originalVideo.addEventListener('timeupdate', () => {
                // Calculate position within buffer range
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);

                // Keep video within buffer range
                if (originalVideo.currentTime < bufferStart) {
                    originalVideo.currentTime = bufferStart;
                } else if (originalVideo.currentTime > bufferEnd) {
                    originalVideo.currentTime = bufferEnd;
                    originalVideo.pause();
                }

                // Update seekbar (0-100% of buffer)
                const positionInBuffer = originalVideo.currentTime - bufferStart;
                const percent = (positionInBuffer / bufferedDuration) * 100;
                seekbar.value = percent;

                // Update time display (showing time relative to buffer start)
                timeDisplay.textContent = `${formatTime(positionInBuffer)} / ${formatTime(bufferedDuration)}`;
            });

            // Seek when user drags seekbar
            seekbar.addEventListener('input', () => {
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const percent = seekbar.value;
                const positionInBuffer = (percent / 100) * bufferedDuration;
                originalVideo.currentTime = bufferStart + positionInBuffer;
            });

            // Jump to theme start
            jumpStartBtn.addEventListener('click', () => {
                originalVideo.currentTime = startSeconds;
            });

            // Jump to theme end
            jumpEndBtn.addEventListener('click', () => {
                originalVideo.currentTime = endSeconds;
            });

            // Volume control
            volumeSlider.addEventListener('input', () => {
                originalVideo.volume = volumeSlider.value;
            });

            // Click on video to play/pause
            originalVideo.addEventListener('click', () => {
                if (originalVideo.paused) {
                    originalVideo.play();
                } else {
                    originalVideo.pause();
                }
            });

            // Update seekbar theme markers
            const updateSeekbarTheme = () => {
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);

                // Calculate theme position within buffer (as percentage)
                const themeStartPercent = ((startSeconds - bufferStart) / bufferedDuration) * 100;
                const themeEndPercent = ((endSeconds - bufferStart) / bufferedDuration) * 100;

                // Set CSS custom properties for gradient
                seekbar.style.setProperty('--theme-start', `${themeStartPercent}%`);
                seekbar.style.setProperty('--theme-end', `${themeEndPercent}%`);
                seekbar.classList.add('theme-marked');

                // Position marker at center of theme range
                const themeCenterPercent = (themeStartPercent + themeEndPercent) / 2;
                themeMarker.style.left = `${themeCenterPercent}%`;

                // Update theme duration text
                const themeDuration = endSeconds - startSeconds;
                themeDurationText.textContent = formatTime(themeDuration);
            };

            // Set initial seekbar and time display
            seekbar.max = 100;

            // Calculate initial position in buffer (theme start position)
            const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
            const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);
            const positionInBuffer = originalVideo.currentTime - bufferStart;
            const seekbarPercent = (positionInBuffer / bufferedDuration) * 100;

            seekbar.value = seekbarPercent;
            timeDisplay.textContent = `${formatTime(positionInBuffer)} / ${formatTime(bufferedDuration)}`;

            // Apply theme markers to seekbar
            updateSeekbarTheme();

            // Update theme markers when theme range changes
            const originalUpdateUI = updateUI;
            updateUI = function() {
                originalUpdateUI();
                updateSeekbarTheme();
            };
        }

        // Update subtitle preview
        function updateSubtitlePreview() {
            const editor = document.getElementById('subtitle-text');
            let text = editor.innerText; // Get plain text for saving
            const html = editor.innerHTML; // Get HTML for display

//             console.log('üé® updateSubtitlePreview called');
//             console.log('   editor HTML:', html.substring(0, 100));

            const fontSize = document.getElementById('subtitle-size').value;
            const fontFamily = document.getElementById('subtitle-font').value;
            const color = document.getElementById('subtitle-color').value;
            const bgColor = document.getElementById('subtitle-bg').value;
            const bgOpacity = document.getElementById('subtitle-bg-opacity').value / 100;
            const position = document.getElementById('subtitle-position').value;

            const overlay = document.getElementById('subtitle-overlay');
            const textEl = document.getElementById('subtitle-preview-text');

            // For preview, use the innerHTML directly to show formatting
            let displayText = html;

            // Only show overlay if there's text
            if (displayText.trim()) {
                textEl.innerHTML = displayText;
                textEl.style.fontSize = `${fontSize}px`;
                textEl.style.fontFamily = fontFamily;
                // Don't set global color - let HTML inline styles handle individual word/phrase colors
                // Only set background color
                textEl.style.backgroundColor = `rgba(${hexToRgb(bgColor)}, ${bgOpacity})`;
                overlay.style.display = 'block';
                overlay.style.left = '50%';

                // Only update position if NOT manually positioned
                // When user has dragged the subtitle, keep their manual position
                if (!hasManualPosition) {
                    // Position overlay
                    if (position === 'bottom') {
                        overlay.style.bottom = '40px';
                        overlay.style.top = 'auto';
                        overlay.style.transform = 'translateX(-50%)';
                    } else if (position === 'top') {
                        overlay.style.top = '20px';
                        overlay.style.bottom = 'auto';
                        overlay.style.transform = 'translateX(-50%)';
                    } else {
                        overlay.style.top = '50%';
                        overlay.style.bottom = 'auto';
                        overlay.style.transform = 'translate(-50%, -50%)';
                    }
                }
            } else {
                overlay.style.display = 'none';
            }
        }

        // Helper: hex to rgb
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '0, 0, 0';
        }

        // Rich text toolbar functions
        function toggleStyle(style) {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            // Use execCommand which properly handles overlapping selections
            // and preserves existing formatting better than manual DOM manipulation
            document.execCommand(style === 'bold' ? 'bold' : 'italic', false, null);

            // Update the preview video overlay to show the change
            updateSubtitlePreview();

            // Save the formatting for the current cue
            saveCurrentCueFormatting();
        }

        function applyColor(color) {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            // Use execCommand which properly handles overlapping selections
            // styleWithCSS=false gives us <b> tags instead of <span style="font-weight: bold;">
            document.execCommand('styleWithCSS', false, false);
            document.execCommand('foreColor', false, color);

            // Update the preview video overlay to show the change
            updateSubtitlePreview();

            // Save the formatting for the current cue
            saveCurrentCueFormatting();
        }

        function applySize(multiplier) {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;
            if (selection.toString().trim().length === 0) return;

            // Find current font size value (1-7 scale)
            let currentSize = 3; // Default normal size
            let node = selection.anchorNode;
            while (node && node !== editor) {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    // Check for <font size="X"> tags
                    if (node.nodeName === 'FONT' && node.getAttribute('size')) {
                        currentSize = parseInt(node.getAttribute('size'));
                        break;
                    }
                    // Check for span with font-size
                    if (node.nodeName === 'SPAN' && node.style?.fontSize) {
                        // Approximate conversion from em to 1-7 scale
                        const match = node.style.fontSize.match(/([\d.]+)/);
                        if (match) {
                            const em = parseFloat(match[1]);
                            if (em < 0.8) currentSize = 1;
                            else if (em < 1.0) currentSize = 2;
                            else if (em < 1.3) currentSize = 3;
                            else if (em < 1.6) currentSize = 4;
                            else if (em < 1.9) currentSize = 5;
                            else if (em < 2.2) currentSize = 6;
                            else currentSize = 7;
                            break;
                        }
                    }
                }
                node = node.parentNode;
            }

            // Calculate new size (clamp to 1-7 range)
            let newSize = currentSize + (multiplier > 1 ? 1 : -1);
            if (newSize < 1) newSize = 1;
            if (newSize > 7) newSize = 7;

            // Apply the size
            document.execCommand('fontSize', false, newSize.toString());

            editor.focus();
            updateSubtitlePreview();
            saveCurrentCueFormatting();
        }

        function removeFormatting() {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);

                // Only apply if there's actual text selected
                if (range.toString().trim().length > 0) {
                    // Remove all formatting using execCommand
                    document.execCommand('removeFormat', false, null);
                }
            }

            // Update the preview video overlay to show the change
            updateSubtitlePreview();

            // Save the formatting for the current cue
            saveCurrentCueFormatting();
        }

        // Save formatting for the current cue
        async function saveCurrentCueFormatting() {
            if (!currentCueInfo) {
// console.log('‚ùå saveCurrentCueFormatting: No currentCueInfo');
                return;
            }

            const editor = document.getElementById('subtitle-text');

            // Save the actual HTML as the source of truth
            // We'll store the HTML and parse it when needed
            // Use sequence as key (stable SRT sequence number)
            const key = currentCueInfo.sequence;

            // CRITICAL: Cannot save without sequence number (cue matching failed)
            if (key === null) {
                console.error('‚ùå Cannot save formatting: sequence number is null');
                console.error('   allThemeCues.length:', allThemeCues.length);
                console.error('   currentCueInfo:', currentCueInfo);
                // Try to reload cues and retry once
                if (allThemeCues.length === 0) {
                    console.warn('‚ö†Ô∏è allThemeCues is empty, attempting to load...');
                    await loadThemeCues();
                    // Retry after loading
                    const retryCue = allThemeCues.find(cue =>
                        cue.start === currentCueInfo.timestamp &&
                        cue.end === currentCueInfo.end &&
                        cue.text === currentCueInfo.text
                    );
                    if (retryCue && retryCue.sequence) {
                        currentCueInfo.sequence = retryCue.sequence;
                        console.log('‚úÖ Found sequence after reload:', retryCue.sequence);
                        // Recursively call save after updating sequence
                        return await saveCurrentCueFormatting();
                    }
                }
                return; // Cannot save without sequence
            }

            allCueFormatting[key] = {
                sequence: key,
                timestamp: currentCueInfo.timestamp,
                html: editor.innerHTML,
                _text: currentCueInfo.text  // Store text for debugging
            };

            console.log('üíæ Saved formatting for sequence', key, `(${currentCueInfo.timestamp})`);
            console.log('   Text:', currentCueInfo.text.substring(0, 50));
            console.log('   HTML:', editor.innerHTML.substring(0, 100));

            // Also extract simplified formatting info for preview
            const bold = editor.querySelector('strong') !== null;
            const italic = editor.querySelector('em') !== null;

            // Extract color - check both font tags and span styles
            let color = null;
            const colorSpan = editor.querySelector('span[style*="color"]');
            if (colorSpan && colorSpan.style.color) {
                color = colorSpan.style.color;
            } else {
                // Check for font tag with color attribute
                const fontTag = editor.querySelector('font[color]');
                if (fontTag && fontTag.color) {
                    color = fontTag.color;
                }
            }

            // Check for font size in multiple formats
            let size = null;

            // Check span elements with font-size in em
            const sizeSpan = editor.querySelector('span[style*="font-size"]');
            if (sizeSpan && sizeSpan.style.fontSize) {
                // Check for em units first
                const emMatch = sizeSpan.style.fontSize.match(/([\d.]+)em/);
                if (emMatch) {
                    size = parseFloat(emMatch[1]);
                } else {
                    // If not em, it's probably pixels - convert back to em relative to base font size
                    // Base font size is typically 16px in browsers
                    const pxMatch = sizeSpan.style.fontSize.match(/([\d.]+)px/);
                    if (pxMatch) {
                        size = parseFloat(pxMatch[1]) / 16; // Convert to em (relative to 16px base)
                    }
                }
            }

            // Also check for HTML font tags (fallback from execCommand)
            if (!size) {
                const fontTag = editor.querySelector('font[size]');
                if (fontTag && fontTag.size) {
                    // HTML font size is 1-7, map to multipliers: 1=0.5, 2=0.7, 3=0.9, 4=1.0, 5=1.2, 6=1.4, 7=1.6
                    const fontSizeMap = { '1': 0.5, '2': 0.7, '3': 0.9, '4': 1.0, '5': 1.2, '6': 1.4, '7': 1.6 };
                    size = fontSizeMap[fontTag.size];
                }
            }

            allCueFormatting[key].bold = bold;
            allCueFormatting[key].italic = italic;
            allCueFormatting[key].color = color;
            allCueFormatting[key].size = size;

            // Get current position from dropdown
            const positionSelect = document.getElementById('subtitle-position');
            const position = positionSelect ? positionSelect.value : null;
            allCueFormatting[key].position = position;

            subtitleFormatting = { ...allCueFormatting[key] };

            // Debug: log what's being saved
// console.log('üíæ Saving formatting for', currentCueInfo.start);
// console.log('  HTML:', editor.innerHTML.substring(0, 150));
// console.log('  ‚Üí bold:', bold, 'italic:', italic, 'color:', color?.substring(0, 20), 'size:', size, 'position:', position);

            // Show saving indicator
            const indicator = document.getElementById('preview-autosave-indicator');
            indicator.textContent = '‚è≥ Saving...';
            indicator.classList.add('show', 'saving');

            // Save to server
            try {
                const response = await fetch('/api/save-subtitle-formatting', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        formatting: allCueFormatting
                    })
                });

                if (!response.ok) throw new Error('Failed to save formatting');

                indicator.textContent = '‚úì Saved';
                indicator.classList.remove('saving');

                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 2000);
            } catch (error) {
// console.error('Failed to save formatting:', error);
                indicator.textContent = '‚úó Save failed';
                indicator.classList.remove('saving');
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 2000);
            }
        }

        // Event listeners for subtitle settings
        document.getElementById('subtitle-text').addEventListener('input', () => {
            updateSubtitlePreview();
            // Only auto-save if this is a user edit, not a programmatic update
            if (!isProgrammaticUpdate) {
                autoSaveSubtitle(); // Auto-save subtitle edits
            }
        });
        document.getElementById('subtitle-font').addEventListener('change', updateSubtitlePreview);
        document.getElementById('subtitle-size').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-color').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-bg').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-bg-opacity').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-position').addEventListener('change', () => {
            hasManualPosition = false; // Clear manual position when user changes dropdown
            updateSubtitlePreview();
        });

        // Theme name editing
        const themeNameElement = document.getElementById('theme-name');
        let originalThemeName = '';

        themeNameElement.addEventListener('focus', () => {
            originalThemeName = themeNameElement.textContent;
        });

        themeNameElement.addEventListener('blur', () => {
            const newName = themeNameElement.textContent.trim();
            if (newName && newName !== originalThemeName) {
                // Save the new name
                themeData.title = newName;
                autoSaveTheme();
                // Update header too
                document.getElementById('header-theme-name').textContent = newName;
            } else if (!newName) {
                // Revert if empty
                themeNameElement.textContent = originalThemeName;
            }
        });

        themeNameElement.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                themeNameElement.blur();
            } else if (e.key === 'Escape') {
                themeNameElement.textContent = originalThemeName;
                themeNameElement.blur();
            }
        });

        // Preview button
        document.getElementById('preview-btn').addEventListener('click', () => {
            previewVideo.currentTime = startSeconds;
            previewVideo.play();

            const checkEnd = () => {
                if (previewVideo.currentTime >= endSeconds) {
                    previewVideo.pause();
                    previewVideo.removeEventListener('timeupdate', checkEnd);
                }
            };
            previewVideo.addEventListener('timeupdate', checkEnd);
        });

        // Save button
        document.getElementById('save-btn').addEventListener('click', async () => {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = 'Saving...';
            messageDiv.className = '';

            try {
                const duration = endSeconds - startSeconds;
                if (duration < 20) {
                    throw new Error('Duration must be at least 20 seconds for YouTube Shorts');
                }

                const updates = {
                    folder: folderNumber,
                    theme: themeNumber,
                    title: themeData.title,
                    start: formatTime(startSeconds),
                    end: formatTime(endSeconds)
                };

                const response = await fetch('/api/update-theme', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updates)
                });

                if (!response.ok) throw new Error('Failed to save changes');

                messageDiv.textContent = '‚úì Theme updated successfully!';
                messageDiv.className = 'success';

                setTimeout(() => {
                    window.close();
                }, 1500);

            } catch (error) {
                messageDiv.textContent = '‚úó ' + error.message;
                messageDiv.className = 'error';
            }
        });

        // Subtitles toggle
        document.getElementById('subtitles-toggle').addEventListener('change', (e) => {
            const track = originalVideo.textTracks[0];
            if (track) {
                track.mode = e.target.checked ? 'showing' : 'hidden';
            }
        });

        // Overlay toggle
        document.getElementById('overlay-toggle').addEventListener('change', (e) => {
            const overlay = document.getElementById('shorts-overlay');
            if (e.target.checked) {
                overlay.classList.remove('hidden');
            } else {
                overlay.classList.add('hidden');
            }
        });

        // Lock video controls button
        document.getElementById('lock-video-btn').addEventListener('click', () => {
            videoControlsLocked = !videoControlsLocked;
            const lockBtn = document.getElementById('lock-video-btn');
            const lockIcon = document.getElementById('lock-icon');
            const subtitleOverlay = document.getElementById('subtitle-overlay');

            if (videoControlsLocked) {
                lockBtn.classList.add('locked');
                lockIcon.textContent = 'üîí';
                lockBtn.title = 'Unlock video controls';

                // Pause video if playing when locked
                if (!previewVideo.paused) {
                    previewVideo.pause();
                }

                // Enable subtitle dragging when locked
                if (subtitleOverlay) {
                    subtitleOverlay.classList.add('draggable');
                }
            } else {
                lockBtn.classList.remove('locked');
                lockIcon.textContent = 'üîì';
                lockBtn.title = 'Lock video controls';

                // Disable subtitle dragging when unlocked
                if (subtitleOverlay) {
                    subtitleOverlay.classList.remove('draggable');
                }
            }
        });

        // Subtitle dragging functionality
        const subtitleOverlay = document.getElementById('subtitle-overlay');
        let isDraggingSubtitle = false;
        let subtitleDragStart = { x: 0, y: 0 };
        let subtitleStartPos = { left: 0, top: 0 };
        let hasManualPosition = false; // Flag to indicate manual positioning

        subtitleOverlay.addEventListener('mousedown', (e) => {
            if (!videoControlsLocked) return;

            isDraggingSubtitle = true;
            hasManualPosition = true; // Mark as having manual position

            subtitleDragStart = { x: e.clientX, y: e.clientY };

            // Get current position from computed style
            const computedStyle = window.getComputedStyle(subtitleOverlay);
            const rect = subtitleOverlay.getBoundingClientRect();
            const parentRect = subtitleOverlay.parentElement.getBoundingClientRect();

            // Store initial position relative to parent
            subtitleStartPos = {
                left: rect.left - parentRect.left,
                top: rect.top - parentRect.top
            };

            e.preventDefault();
            e.stopPropagation();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingSubtitle || !videoControlsLocked) return;

            const deltaX = e.clientX - subtitleDragStart.x;
            const deltaY = e.clientY - subtitleDragStart.y;

            const parentRect = subtitleOverlay.parentElement.getBoundingClientRect();

            // Calculate new position
            let newX = subtitleStartPos.left + deltaX;
            let newY = subtitleStartPos.top + deltaY;

            // Constrain within parent bounds with some padding
            const padding = 10;
            const maxX = parentRect.width - subtitleOverlay.offsetWidth - padding;
            const maxY = parentRect.height - subtitleOverlay.offsetHeight - padding;

            newX = Math.max(padding, Math.min(newX, maxX));
            newY = Math.max(padding, Math.min(newY, maxY));

            // Update position
            subtitleOverlay.style.left = `${newX + subtitleOverlay.offsetWidth / 2}px`;
            subtitleOverlay.style.top = `${newY}px`;
            subtitleOverlay.style.bottom = 'auto';
            subtitleOverlay.style.transform = 'translateX(-50%)';

            // Add visual border during drag to see position clearly
            subtitleOverlay.style.border = '2px solid yellow';
        });

        document.addEventListener('mouseup', () => {
            if (isDraggingSubtitle) {
                isDraggingSubtitle = false;

                // Remove drag border
                subtitleOverlay.style.border = '';

                // Update subtitle position setting to match new position
                const rect = subtitleOverlay.getBoundingClientRect();
                const parentRect = subtitleOverlay.parentElement.getBoundingClientRect();

                const relativeTop = rect.top - parentRect.top;
                const relativeBottom = parentRect.height - rect.top - rect.height;

                // Determine position (top/middle/bottom) based on current location
                const positionSelect = document.getElementById('subtitle-position');
                const third = parentRect.height / 3;

                if (relativeTop < third) {
                    positionSelect.value = 'top';
                } else if (relativeTop > 2 * third) {
                    positionSelect.value = 'bottom';
                } else {
                    positionSelect.value = 'middle';
                }

                updateSubtitlePreview();

                // IMPORTANT: Save the new position so it persists
                // This ensures the dragged position is saved to the formatting file
                autoSaveSubtitle();
            }
        });

        // Keyboard controls for preview video
        document.addEventListener('keydown', (e) => {
            // Only handle keyboard events when not in textarea/input or editing theme name
            if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT' || e.target.id === 'theme-name') {
                return;
            }

            // Space key for play/pause
            if (e.code === 'Space') {
                e.preventDefault();
                if (!videoControlsLocked) {
                    if (previewVideo.paused) {
                        previewVideo.play();
                    } else {
                        previewVideo.pause();
                    }
                }
                return;
            }

            // Arrow keys for seeking (only when video controls are not locked)
            if (!videoControlsLocked && (e.code === 'ArrowLeft' || e.code === 'ArrowRight')) {
                e.preventDefault();

                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd);
                const seekAmount = 5; // Seek by 5 seconds

                if (e.code === 'ArrowLeft') {
                    // Seek backward
                    previewVideo.currentTime = Math.max(themeStart, previewVideo.currentTime - seekAmount);
                } else {
                    // Seek forward
                    previewVideo.currentTime = Math.min(themeEnd, previewVideo.currentTime + seekAmount);
                }
            }
        });

        // Subtitle Editor Modal
        let themeSubtitles = []; // Store all subtitles for the theme
        const subtitleModal = document.getElementById('subtitle-modal');
        const editAllSubsBtn = document.getElementById('edit-all-subs-btn');
        const closeSubsModal = subtitleModal.querySelector('.close');
        const cancelSubsBtn = document.getElementById('cancel-subs-btn');
        const saveSubsBtn = document.getElementById('save-subs-btn');

        // Open subtitle editor modal
        editAllSubsBtn.addEventListener('click', async () => {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = 'Loading subtitles...';
            messageDiv.className = '';

            try {
                const response = await fetch(`/api/theme-subtitles/${folderNumber}/${themeNumber}`);
                if (!response.ok) throw new Error('Failed to load subtitles');

                const data = await response.json();
                themeSubtitles = data.cues;

                renderSubtitleCues();
                subtitleModal.style.display = 'block';
                messageDiv.textContent = '';
                messageDiv.className = '';
            } catch (error) {
                messageDiv.textContent = `Error: ${error.message}`;
                messageDiv.className = 'error';
            }
        });

        // Close modal handlers
        closeSubsModal.addEventListener('click', () => {
            subtitleModal.style.display = 'none';
        });

        cancelSubsBtn.addEventListener('click', () => {
            subtitleModal.style.display = 'none';
        });

        window.addEventListener('click', (e) => {
            if (e.target === subtitleModal) {
                subtitleModal.style.display = 'none';
            }
        });

        // Render subtitle cues in the modal
        function renderSubtitleCues() {
            const container = document.getElementById('subtitle-cues-container');
            container.innerHTML = '';

            themeSubtitles.forEach((cue, index) => {
                const cueDiv = document.createElement('div');
                cueDiv.className = 'subtitle-cue-item';
                cueDiv.innerHTML = `
                    <div class="cue-header">
                        <strong>#${cue.sequence}</strong>
                        <label>Start:
                            <input type="text" class="cue-time-input" data-index="${index}" data-field="start" value="${cue.start}">
                        </label>
                        <label>End:
                            <input type="text" class="cue-time-input" data-index="${index}" data-field="end" value="${cue.end}">
                        </label>
                    </div>
                    <textarea class="cue-textarea" data-index="${index}" data-field="text">${cue.text}</textarea>
                `;
                container.appendChild(cueDiv);
            });

            // Add event listeners to inputs
            container.querySelectorAll('.cue-time-input, .cue-textarea').forEach(input => {
                input.addEventListener('input', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const field = e.target.dataset.field;
                    themeSubtitles[index][field] = e.target.value;
                });
            });
        }

        // Save subtitles
        saveSubsBtn.addEventListener('click', async () => {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = 'Saving subtitles...';
            messageDiv.className = '';

            try {
                const response = await fetch('/api/save-theme-subtitles', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        cues: themeSubtitles
                    })
                });

                if (!response.ok) throw new Error('Failed to save subtitles');

                const result = await response.json();
                messageDiv.textContent = `‚úì ${result.message}`;
                messageDiv.className = 'success';

                // Reload the video subtitles
                const subtitleTrack = document.getElementById('subtitle-track');
                subtitleTrack.src = `/api/subtitles/${folderNumber}.vtt?t=${Date.now()}`;

                subtitleModal.style.display = 'none';

                setTimeout(() => {
                    messageDiv.textContent = '';
                    messageDiv.className = '';
                }, 3000);
            } catch (error) {
                messageDiv.textContent = `Error: ${error.message}`;
                messageDiv.className = 'error';
            }
        });

        // Initialize
        if (folderNumber && themeNumber) {
            loadTheme();
        } else {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('error').textContent = 'Missing folder or theme number';
            document.getElementById('error').classList.remove('hidden');
        }
    </script>
</body>
</html>
