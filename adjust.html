<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adjust Theme - YouTube Shorts Creator</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a15 0%, #1a1a2e 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .back-link {
            color: #00ff9d;
            text-decoration: none;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .container {
            display: grid;
            grid-template-columns: 7fr 3fr;
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }

        .panel {
            background: rgba(30, 30, 45, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
        }

        .panel h2 {
            color: #00ff9d;
            font-size: 16px;
            margin-bottom: 16px;
        }

        /* Video containers */
        .video-wrapper {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 16/9;
            margin-bottom: 16px;
        }

        .buffer-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            font-family: monospace;
            z-index: 10;
            pointer-events: none;
        }

        .autosave-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 255, 157, 0.9);
            color: #000;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .autosave-indicator.show {
            opacity: 1;
        }

        .autosave-indicator.saving {
            background: rgba(255, 193, 7, 0.9);
        }

        .preview-autosave {
            top: 10px;
            right: 10px;
            left: auto;
        }

        /* Custom Video Controls */
        .video-controls-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
            pointer-events: none;
        }

        .video-wrapper:hover .video-controls-overlay {
            opacity: 1;
            pointer-events: auto;
        }

        .controls-progress {
            width: 100%;
            margin-bottom: 8px;
            position: relative;
        }

        .seekbar {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        /* Seekbar with theme range marked in red */
        .seekbar.theme-marked {
            background: linear-gradient(to right,
                rgba(255, 255, 255, 0.3) var(--theme-start),
                rgba(244, 67, 54, 0.85) var(--theme-start),
                rgba(244, 67, 54, 0.85) var(--theme-end),
                rgba(255, 255, 255, 0.3) var(--theme-end)
            );
        }

        /* Theme marker flag */
        .theme-marker {
            position: absolute;
            top: -30px;
            left: 0;
            transform: translateX(-50%);
            pointer-events: none;
            transition: left 0.2s;
        }

        .theme-marker-flag {
            position: relative;
            background: rgba(244, 67, 54, 0.9);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            font-weight: 500;
        }

        .theme-marker-flag::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid rgba(244, 67, 54, 0.9);
        }

        .seekbar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }

        .seekbar::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .controls-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .control-icon {
            background: none;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            padding: 4px 8px;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .control-icon:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .control-jump {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .control-jump:hover {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
        }

        .time-display {
            color: #fff;
            font-size: 13px;
            font-family: monospace;
            flex-grow: 1;
        }

        .volume-slider {
            width: 80px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        .volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* Theme clip preview - 9:16 aspect ratio for YouTube Shorts */
        .preview-wrapper {
            aspect-ratio: 9/16;
            max-height: 500px;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Preview video should crop to fill the 9:16 frame */
        #preview-video {
            object-fit: cover;
        }

        /* Preview seekbar container */
        .preview-seekbar-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 10px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .preview-wrapper:hover .preview-seekbar-container {
            opacity: 1;
            pointer-events: auto;
        }

        .preview-controls-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .preview-time-row {
            display: flex;
            justify-content: center;
        }

        .preview-control-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #00ff9d;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .preview-control-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        .preview-seekbar {
            flex-grow: 1;
        }

        .preview-time-display {
            font-size: 13px;
            color: #00ff9d;
            font-family: monospace;
        }

        /* Subtitle overlay */
        .subtitle-overlay {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 80%;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        .subtitle-overlay.draggable {
            pointer-events: auto;
            cursor: move;
            z-index: 30; /* Above controls (z-index 20) but not too high */
        }

        .subtitle-text {
            display: inline-block;
            padding: 6px 16px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 6px;
            line-height: 1.4;
        }

        /* Shorts 9:16 crop overlay */
        .shorts-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .shorts-crop-area {
            width: 56.25%;
            height: 100%;
            border: 3px solid rgba(0, 255, 157, 0.8);
            background: rgba(0, 255, 157, 0.1);
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.3);
        }

        .shorts-crop-area::before {
            content: '9:16';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 157, 0.9);
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        /* Timeline */
        .timeline-container {
            margin-top: 16px;
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        /* Video buffer controls (on sides of video) */
        .video-buffer-btn {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #00ff9d;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
            pointer-events: auto;
        }

        .video-buffer-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        /* Buffer button containers */
        .video-buffer-controls-left,
        .video-buffer-controls-right {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 30;
        }

        .video-buffer-controls-left {
            left: 10px;
        }

        .video-buffer-controls-right {
            right: 10px;
        }

        /* Position buffer buttons inside video on edges */
        .video-buffer-btn.video-buffer-left {
            position: static;
            transform: none;
        }

        .video-buffer-btn.video-buffer-right {
            position: static;
            transform: none;
        }

        .buffer-label {
            font-size: 12px;
            color: #aaa;
        }

        .timeline-track {
            position: relative;
            height: 60px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            overflow: hidden;
        }

        /* Buffer range band (shows the buffered portion of the video) */
        .buffer-range {
            position: absolute;
            height: 100%;
            background: rgba(100, 150, 200, 0.2);
            border-radius: 6px;
        }

        .theme-box {
            position: absolute;
            height: 100%;
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.5), rgba(255, 87, 34, 0.5));
            border: 2px solid #f44336;
            border-radius: 6px;
            cursor: default;
            transition: border-color 0.2s;
        }

        .theme-box.highlight-left {
            border-left: 4px solid #ff9800;
        }

        .theme-box.highlight-right {
            border-right: 4px solid #ff9800;
        }

        .theme-box-handle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: #f44336;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: ew-resize;
            z-index: 10;
            transition: background 0.2s, border-color 0.2s;
        }

        .theme-box-handle:hover {
            background: #ff9800 !important;
            border-color: #fff !important;
        }

        .theme-box-handle.left {
            left: -8px; /* Position outside left edge */
        }

        .theme-box-handle.right {
            right: -8px; /* Position outside right edge */
        }

        .theme-box-content {
            position: absolute;
            top: 50%;
            left: 20px;
            right: 20px;
            transform: translateY(-50%);
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .time-markers {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 11px;
            color: #aaa;
        }

        /* Info display */
        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #aaa;
            font-size: 13px;
        }

        .info-value {
            font-weight: 600;
            font-size: 14px;
        }

        .duration-value {
            color: #00ff9d;
            font-size: 18px;
        }

        /* Subtitle editor */
        .subtitle-editor {
            margin-top: 20px;
        }

        .lock-btn {
            background: none;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.2s;
            background: rgba(255, 255, 255, 0.05);
        }

        .lock-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .lock-btn.locked {
            border-color: #ff9800;
            background: rgba(255, 152, 0, 0.1);
        }

        .subtitle-section {
            margin-bottom: 20px;
        }

        .subtitle-section h3 {
            font-size: 14px;
            color: #00ff9d;
            margin-bottom: 12px;
        }

        .form-row {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
        }

        .form-group {
            flex: 1;
        }

        .form-group label {
            display: block;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 6px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #00ff9d;
        }

        .form-group input[type="color"] {
            height: 40px;
            padding: 4px;
        }

        .subtitle-text-area {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
        }

        .subtitle-text-area:focus {
            outline: none;
            border-color: #00ff9d;
        }

        .subtitle-text-area:empty:before {
            content: attr(data-placeholder);
            color: rgba(255, 255, 255, 0.4);
        }

        .subtitle-text-area strong {
            font-weight: bold;
        }

        .subtitle-text-area em {
            font-style: italic;
        }

        .rich-text-toolbar {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .toolbar-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toolbar-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        .toolbar-btn.active {
            background: rgba(0, 255, 157, 0.3);
            border-color: #00ff9d;
        }

        /* Buttons */
        .buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00bfff, #00ff9d);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 255, 157, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Loading and messages */
        .loading {
            text-align: center;
            padding: 60px 20px;
            color: #aaa;
        }

        .error {
            background: rgba(255, 59, 48, 0.2);
            border: 1px solid rgba(255, 59, 48, 0.5);
            border-radius: 8px;
            padding: 16px;
            color: #ff6b6b;
        }

        .success {
            background: rgba(0, 255, 157, 0.2);
            border: 1px solid rgba(0, 255, 157, 0.5);
            border-radius: 8px;
            padding: 16px;
            color: #00ff9d;
        }

        .hidden {
            display: none !important;
        }

        /* Custom tooltip for directory location */
        .custom-tooltip {
            position: relative;
            display: inline-block;
        }

        .custom-tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-5px);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background-color: #1e1e1e;
            margin: 5% auto;
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header h2 {
            margin: 0;
            font-size: 20px;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover,
        .close:focus {
            color: #fff;
        }

        .modal-body {
            padding: 20px;
        }

        .subtitle-cue-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .cue-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 8px;
            font-size: 13px;
            color: #aaa;
        }

        .cue-time-input {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            width: 90px;
        }

        .cue-textarea {
            width: 100%;
            min-height: 60px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
        }

        .cue-textarea:focus {
            outline: none;
            border-color: #00ff9d;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            padding: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="index.html" class="back-link">
            <span>‚Üê</span> Back to Main
        </a>
        <div style="flex-grow: 1; text-align: center;">
            <h1 style="margin: 0; font-size: 18px;" id="header-title">Adjust Theme</h1>
            <p style="margin: 0; font-size: 13px; color: #aaa;" id="header-theme-name"></p>
        </div>
        <div></div>
    </div>

    <div id="loading" class="loading">Loading theme details...</div>
    <div id="error" class="error hidden"></div>

    <div id="content" class="container hidden">
        <!-- Left Panel: Original Video + Timeline -->
        <div class="panel">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                <h2 style="margin: 0;">Original Video</h2>
                <div style="display: flex; gap: 16px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="subtitles-toggle" checked style="width: 18px; height: 18px;">
                        <span style="font-size: 13px; color: #aaa;">Show Subtitles</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="overlay-toggle" style="width: 18px; height: 18px;">
                        <span style="font-size: 13px; color: #aaa;">Show 9:16 Crop Overlay</span>
                    </label>
                </div>
            </div>

            <div class="video-wrapper">
                <video id="original-video">
                    <track id="subtitle-track" kind="subtitles" srclang="en" label="English" default>
                </video>
                <div id="shorts-overlay" class="shorts-overlay hidden">
                    <div class="shorts-crop-area"></div>
                </div>
                <div class="buffer-info" id="buffer-info">Buffer range: 00:00:00 - 00:00:00</div>
                <div class="autosave-indicator" id="autosave-indicator"></div>

                <!-- Custom Video Controls -->
                <div class="video-controls-overlay">
                    <div class="controls-progress">
                        <input type="range" id="seekbar" class="seekbar" min="0" max="100" value="0" step="0.1">
                        <div id="theme-marker" class="theme-marker">
                            <div class="theme-marker-flag">Theme length: <span id="theme-duration-text">00:00</span></div>
                        </div>
                    </div>
                    <div class="controls-row">
                        <button id="play-pause-btn" class="control-icon">‚ñ∂</button>
                        <button id="jump-start-btn" class="control-jump" title="Jump to theme start">‚èÆ Start</button>
                        <button id="jump-end-btn" class="control-jump" title="Jump to theme end">End ‚è≠</button>
                        <span id="time-display" class="time-display">00:00 / 00:00</span>
                        <input type="range" id="volume-slider" class="volume-slider" min="0" max="1" value="1" step="0.1">
                    </div>
                </div>

                <!-- Video buffer controls inside video -->
                <div class="video-buffer-controls-left">
                    <button id="video-buffer-decrease-left" class="video-buffer-btn" title="Reduce buffer by 1 min">‚àí</button>
                    <button id="video-buffer-increase-left" class="video-buffer-btn" title="Increase buffer by 1 min">+</button>
                </div>
                <div class="video-buffer-controls-right">
                    <button id="video-buffer-decrease-right" class="video-buffer-btn" title="Reduce buffer by 1 min">‚àí</button>
                    <button id="video-buffer-increase-right" class="video-buffer-btn" title="Increase buffer by 1 min">+</button>
                </div>
            </div>

            <div class="timeline-container">
                <div class="timeline-header">
                    <span class="buffer-label" id="buffer-display">L: ¬±5min | R: ¬±5min</span>
                </div>
                <div class="timeline-track" id="timeline-track">
                    <div class="buffer-range" id="buffer-range">
                        <div class="theme-box" id="theme-box">
                            <div class="theme-box-handle left" id="handle-left"></div>
                            <div class="theme-box-content" id="theme-box-content">00:30 - 01:30</div>
                            <div class="theme-box-handle right" id="handle-right"></div>
                        </div>
                    </div>
                </div>
                <div class="time-markers">
                    <span id="time-start-marker">00:00</span>
                    <span id="time-end-marker">00:00</span>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <div class="info-row">
                    <span class="info-label">Theme</span>
                    <span class="info-value" id="theme-number">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Theme Name</span>
                    <span class="info-value" id="theme-name" style="color: #00ff9d; cursor: pointer;" contenteditable="true" title="Click to edit">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Start Time</span>
                    <span class="info-value" id="display-start">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">End Time</span>
                    <span class="info-value" id="display-end">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Duration</span>
                    <span class="info-value duration-value" id="display-duration">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Directory location</span>
                    <span class="info-value custom-tooltip" id="folder-location">üìÅ</span>
                </div>
            </div>
        </div>

        <!-- Right Panel: Theme Clip Preview + Subtitle Editor -->
        <div class="panel">
            <h2>Theme Clip Preview (9:16 Shorts)</h2>
            <div class="video-wrapper preview-wrapper">
                <video id="preview-video" loop playsinline>
                    <track id="preview-subtitle-track" kind="subtitles" srclang="en" label="English" default>
                </video>
                <div class="subtitle-overlay" id="subtitle-overlay">
                    <span class="subtitle-text" id="subtitle-preview-text">Preview subtitles</span>
                </div>
                <div class="autosave-indicator preview-autosave" id="preview-autosave-indicator"></div>

                <!-- Custom controls for preview video -->
                <div class="preview-seekbar-container">
                    <div class="preview-controls-row">
                        <button id="preview-play-btn" class="preview-control-btn">‚ñ∂</button>
                        <input type="range" id="preview-seekbar" class="seekbar preview-seekbar" min="0" max="100" value="0" step="0.1">
                    </div>
                    <div class="preview-time-row">
                        <span id="preview-time-display" class="preview-time-display">00:00 / 00:00</span>
                    </div>
                </div>
            </div>

            <div class="subtitle-editor">
                <div class="subtitle-section">
                    <div style="display: flex; align-items: center; justify-content: space-between;">
                        <h3>Subtitle Text</h3>
                        <div style="display: flex; gap: 8px;">
                            <button id="edit-all-subs-btn" class="lock-btn" title="Edit all subtitles for this theme">üìù Edit All</button>
                            <button id="lock-video-btn" class="lock-btn" title="Lock video controls">
                                <span id="lock-icon">üîì</span>
                            </button>
                        </div>
                    </div>
                    <div class="rich-text-toolbar">
                        <button class="toolbar-btn" data-style="bold" onclick="toggleStyle('bold')"><b>Bold</b></button>
                        <button class="toolbar-btn" data-style="italic" onclick="toggleStyle('italic')"><i>Italic</i></button>
                        <button class="toolbar-btn" data-style="color" onclick="applyColor('#ff0000')">üî¥ Red</button>
                        <button class="toolbar-btn" data-style="color" onclick="applyColor('#00ff00')">üü¢ Green</button>
                        <button class="toolbar-btn" data-style="color" onclick="applyColor('#00ffff')">üîµ Cyan</button>
                        <button class="toolbar-btn" data-style="color" onclick="applyColor('#ffff00')">üü° Yellow</button>
                        <button class="toolbar-btn" data-style="size" onclick="applySize(1.2)">A+</button>
                        <button class="toolbar-btn" data-style="size" onclick="applySize(0.8)">a-</button>
                        <button class="toolbar-btn" onclick="removeFormatting()" style="margin-left: auto;">üóë Clear Format</button>
                    </div>
                    <div class="subtitle-text-area" id="subtitle-text" contenteditable="true" data-placeholder="Edit subtitle text here..."></div>
                </div>

                <div class="subtitle-section">
                    <h3>Global Subtitle Settings</h3>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Font Family</label>
                            <select id="subtitle-font">
                                <option value="Arial">Arial</option>
                                <option value="Calibri">Calibri</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Verdana">Verdana</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Font Size (px)</label>
                            <input type="number" id="subtitle-size" value="16" min="12" max="72">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Text Color</label>
                            <input type="color" id="subtitle-color" value="#ffffff">
                        </div>
                        <div class="form-group">
                            <label>Background Color</label>
                            <input type="color" id="subtitle-bg" value="#000000">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Position</label>
                            <select id="subtitle-position">
                                <option value="bottom">Bottom</option>
                                <option value="middle">Middle</option>
                                <option value="top">Top</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Background Opacity</label>
                            <input type="range" id="subtitle-bg-opacity" min="0" max="100" value="70">
                        </div>
                    </div>
                </div>
            </div>

            <div class="buttons">
                <button class="btn btn-secondary" id="preview-btn">‚ñ∂ Preview Theme Clip</button>
                <button class="btn btn-primary" id="save-btn">Save Changes</button>
            </div>

            <div id="message" style="margin-top: 16px;"></div>
        </div>
    </div>

    <!-- Subtitle Editor Modal -->
    <div id="subtitle-modal" class="modal">
        <div class="modal-content" style="max-width: 800px; max-height: 80vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <h2>Edit All Subtitles</h2>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body" style="flex: 1; overflow-y: auto;">
                <div id="subtitle-cues-container"></div>
            </div>
            <div class="modal-footer" style="padding: 16px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: flex-end; gap: 12px;">
                <button id="cancel-subs-btn" class="btn btn-secondary">Cancel</button>
                <button id="save-subs-btn" class="btn btn-primary">Save Subtitles</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let themeData = null;
        let fullVideoDuration = 0;  // Full video duration
        let bufferedDuration = 0;   // Buffered range duration (for timeline)
        let videoPath = '';
        let startSeconds = 0;
        let endSeconds = 0;
        let bufferLeftSeconds = 300; // 5 minutes buffer before theme
        let bufferRightSeconds = 300; // 5 minutes buffer after theme
        let isDragging = null;
        let dragStartX = 0;
        let dragStartValue = 0;
        let dragStartValueEnd = 0;
        let videoControlsLocked = false; // Video controls lock state

        // DOM Elements
        const originalVideo = document.getElementById('original-video');
        const previewVideo = document.getElementById('preview-video');
        const previewSeekbar = document.getElementById('preview-seekbar');
        const previewPlayBtn = document.getElementById('preview-play-btn');
        const themeBox = document.getElementById('theme-box');
        const handleLeft = document.getElementById('handle-left');
        const handleRight = document.getElementById('handle-right');
        const timelineTrack = document.getElementById('timeline-track');
        const bufferRange = document.getElementById('buffer-range');
        const themeBoxContent = document.getElementById('theme-box-content');

        // Custom video control elements
        const seekbar = document.getElementById('seekbar');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const jumpStartBtn = document.getElementById('jump-start-btn');
        const jumpEndBtn = document.getElementById('jump-end-btn');
        const timeDisplay = document.getElementById('time-display');
        const volumeSlider = document.getElementById('volume-slider');
        const themeMarker = document.getElementById('theme-marker');
        const themeDurationText = document.getElementById('theme-duration-text');

        // Parse URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const folderNumber = urlParams.get('folder');
        const themeNumber = parseInt(urlParams.get('theme'));

        // Format time
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        // Parse time string to seconds
        function parseTime(timeStr) {
            const parts = timeStr.split(':');
            if (parts.length !== 3) return 0;
            return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseFloat(parts[2]);
        }

        // Auto-save theme adjustment
        let autoSaveTimeout = null;
        let subtitleAutoSaveTimeout = null;
        let currentCueInfo = null; // Track current cue {start, end, text, sequence}
        let allThemeCues = []; // Cache all theme cues
        let subtitleFormatting = { bold: false, italic: false, color: null, size: null };
        let allCueFormatting = {}; // Store formatting for all cues: {start_time: {bold, italic, color, size}}

        function autoSaveTheme() {
            // Clear existing timeout
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }

            // Show saving indicator
            const indicator = document.getElementById('autosave-indicator');
            indicator.textContent = '‚è≥ Saving...';
            indicator.classList.add('show', 'saving');

            // Debounce save to avoid too many requests
            autoSaveTimeout = setTimeout(async () => {
                try {
                    const updates = {
                        folder: folderNumber,
                        theme: themeNumber,
                        title: themeData.title,
                        start: formatTime(startSeconds),
                        end: formatTime(endSeconds)
                    };

                    const response = await fetch('/api/update-theme', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(updates)
                    });

                    if (!response.ok) throw new Error('Failed to auto-save');

                    indicator.textContent = '‚úì Saved';
                    indicator.classList.remove('saving');

                    // Hide after 2 seconds
                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                } catch (error) {
                    indicator.textContent = '‚úó Save failed';
                    indicator.classList.remove('saving');
                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                }
            }, 500); // Wait 500ms after drag ends before saving
        }

        // Load all theme cues for editing
        async function loadThemeCues() {
            try {
                const response = await fetch(`/api/theme-subtitles/${folderNumber}/${themeNumber}`);
                if (!response.ok) return [];

                const data = await response.json();
                allThemeCues = data.cues;
                return allThemeCues;
            } catch (error) {
                console.error('Failed to load theme cues:', error);
                return [];
            }
        }

        // Load subtitle formatting metadata
        async function loadSubtitleFormatting() {
            try {
                const response = await fetch(`/api/subtitle-formatting/${folderNumber}/${themeNumber}`);
                if (!response.ok) return;

                const data = await response.json();
                allCueFormatting = data.formatting || {};
            } catch (error) {
                console.error('Failed to load subtitle formatting:', error);
            }
        }

        // Auto-save subtitle edit
        function autoSaveSubtitle() {
            if (subtitleAutoSaveTimeout) {
                clearTimeout(subtitleAutoSaveTimeout);
            }

            const indicator = document.getElementById('preview-autosave-indicator');
            indicator.textContent = '‚è≥ Saving...';
            indicator.classList.add('show', 'saving');

            subtitleAutoSaveTimeout = setTimeout(async () => {
                try {
                    const textarea = document.getElementById('subtitle-text');
                    const newText = textarea.innerText.trim();

                    if (!currentCueInfo || !newText) {
                        indicator.classList.remove('show');
                        return;
                    }

                    // Find and update the current cue
                    const cueIndex = allThemeCues.findIndex(cue =>
                        cue.start === currentCueInfo.start && cue.end === currentCueInfo.end
                    );

                    if (cueIndex !== -1) {
                        allThemeCues[cueIndex].text = newText;
                    }

                    // Save to server
                    const response = await fetch('/api/save-theme-subtitles', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            folder: folderNumber,
                            theme: themeNumber,
                            cues: allThemeCues
                        })
                    });

                    if (!response.ok) throw new Error('Failed to save subtitle');

                    // Reload the subtitle track to show changes
                    const previewSubtitleTrack = document.getElementById('preview-subtitle-track');
                    if (previewSubtitleTrack) {
                        previewSubtitleTrack.src = `/api/subtitles/${folderNumber}/${themeNumber}.vtt?t=${Date.now()}`;
                    }

                    indicator.textContent = '‚úì Saved';
                    indicator.classList.remove('saving');

                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                } catch (error) {
                    indicator.textContent = '‚úó Save failed';
                    indicator.classList.remove('saving');
                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                }
            }, 800); // Wait 800ms after typing stops
        }

        // Load theme details
        async function loadTheme() {
            try {
                const response = await fetch(`/api/folder/${folderNumber}/themes`);
                if (!response.ok) throw new Error('Failed to load theme');

                const data = await response.json();
                themeData = data.themes.find(t => t.number === themeNumber);

                if (!themeData) throw new Error('Theme not found');

                // Set initial values
                startSeconds = parseTime(themeData.start);
                endSeconds = parseTime(themeData.end);

                // Construct video path from folder and actual video filename
                if (data.video_filename) {
                    videoPath = `videos/${data.folder}/${encodeURIComponent(data.video_filename)}`;
                } else {
                    // Fallback: try to construct from title (old behavior)
                    videoPath = `videos/${data.folder}/${encodeURIComponent(data.title)}.mp4`;
                }

                // Update info display
                document.getElementById('theme-number').textContent = `Theme ${themeData.number}`;
                document.getElementById('theme-name').textContent = themeData.title || '';
                const fullPath = `videos/${data.folder}`;
                document.getElementById('folder-location').setAttribute('data-tooltip', fullPath);

                // Update header with theme info
                document.getElementById('header-title').textContent = `Adjust Theme ${themeData.number}`;
                document.getElementById('header-theme-name').textContent = themeData.title || '';

                document.getElementById('subtitle-text').innerHTML = themeData.text || '';

                // Load all theme cues for subtitle editing
                loadThemeCues();

                // Load subtitle formatting metadata
                loadSubtitleFormatting();

                // Load VTT subtitles
                const subtitleTrack = document.getElementById('subtitle-track');
                subtitleTrack.src = `/api/subtitles/${folderNumber}.vtt`;
                originalVideo.textTracks.addEventListener('addtrack', (event) => {
                    const track = event.track;
                    track.mode = 'showing';
                });

                // Promise wrapper for video loading
                const loadVideo = (video, src) => {
                    return new Promise((resolve, reject) => {
                        video.addEventListener('loadedmetadata', () => {
                            fullVideoDuration = video.duration;
                            resolve();
                        }, { once: true });

                        video.addEventListener('error', (e) => {
                            reject(new Error('Failed to load video'));
                        }, { once: true });

                        video.src = src;
                    });
                };

                // Load original video first to get full duration
                await loadVideo(originalVideo, videoPath);

                // Calculate buffer range
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);
                bufferedDuration = bufferEnd - bufferStart;

                // Load preview with theme clip range
                previewVideo.src = `${videoPath}#t=${startSeconds},${endSeconds}`;

                // Wait for preview to load
                await loadVideo(previewVideo, previewVideo.src);

                // Load original video with buffered range - this makes seekbar show buffer duration
                originalVideo.src = `${videoPath}#t=${bufferStart},${bufferEnd}`;

                // Wait for original video to reload with range
                await new Promise(resolve => {
                    originalVideo.addEventListener('loadedmetadata', () => {
                        // Update buffer info display
                        document.getElementById('buffer-info').textContent =
                            `Buffer range: ${formatTime(bufferStart)} - ${formatTime(bufferEnd)} (${formatTime(bufferedDuration)})`;

                        // Set video position to theme start time
                        originalVideo.currentTime = startSeconds;

                        resolve();
                    }, { once: true });
                });

                // Show content
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('content').classList.remove('hidden');

                // Initial UI update
                updateUI();
                setupDragHandlers();

                // Setup custom video controls
                setupVideoControls();

            } catch (error) {
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('error').textContent = error.message;
                document.getElementById('error').classList.remove('hidden');
            }
        }

        // Update original video playback range (buffered range)
        function updateOriginalVideoRange() {
            if (!videoPath || !fullVideoDuration || !startSeconds || !endSeconds) return;

            const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
            const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);
            bufferedDuration = bufferEnd - bufferStart;

            // Set video to buffer start position if outside range
            if (originalVideo.currentTime < bufferStart || originalVideo.currentTime > bufferEnd) {
                originalVideo.currentTime = bufferStart;
            }
        }

        // Update preview video with clipped range
        function updatePreviewVideo() {
            if (!videoPath || !startSeconds || !endSeconds) return;

            // Load full video and use JavaScript to enforce theme boundaries
            previewVideo.src = videoPath;
            previewVideo.loop = true;
            previewVideo.muted = false;

            // Store theme boundaries for enforcement
            previewVideo.dataset.themeStart = startSeconds;
            previewVideo.dataset.themeEnd = endSeconds;

            // Remove old listeners
            if (previewVideo.boundariesHandler) {
                previewVideo.removeEventListener('timeupdate', previewVideo.boundariesHandler);
            }
            if (previewVideo.timeUpdateHandler) {
                previewVideo.removeEventListener('timeupdate', previewVideo.timeUpdateHandler);
            }
            if (previewVideo.subtitleSyncHandler) {
                previewVideo.removeEventListener('timeupdate', previewVideo.subtitleSyncHandler);
            }
            if (previewVideo.seekbarHandler) {
                previewSeekbar.removeEventListener('input', previewVideo.seekbarHandler);
            }
            if (previewVideo.playBtnHandler) {
                previewPlayBtn.removeEventListener('click', previewVideo.playBtnHandler);
            }
            if (previewVideo.clickHandler) {
                previewVideo.removeEventListener('click', previewVideo.clickHandler);
            }
            if (previewVideo.playHandler) {
                previewVideo.removeEventListener('play', previewVideo.playHandler);
            }
            if (previewVideo.pauseHandler) {
                previewVideo.removeEventListener('pause', previewVideo.pauseHandler);
            }

            // Enforce theme boundaries and loop
            const enforceThemeBoundaries = () => {
                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd);

                // If video is past theme end and playing, loop back to start
                if (previewVideo.currentTime >= themeEnd && !previewVideo.paused) {
                    previewVideo.currentTime = themeStart;
                }
            };

            // Sync current subtitle from VTT to textarea
            const syncSubtitleToTextarea = () => {
                const textTrack = previewVideo.textTracks[0];
                if (!textTrack || textTrack.cues.length === 0) return;

                const activeCues = textTrack.activeCues;
                if (activeCues.length > 0) {
                    const currentCue = activeCues[0];
                    const subtitleText = document.getElementById('subtitle-text');

                    // Convert cue time (seconds) to HH:MM:SS.mmm format for matching with API
                    const vttToTimestamp = (seconds) => {
                        const h = Math.floor(seconds / 3600);
                        const m = Math.floor((seconds % 3600) / 60);
                        const s = seconds % 60;
                        return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toFixed(3).padStart(6, '0')}`;
                    };

                    // Track current cue info with matching format
                    currentCueInfo = {
                        start: vttToTimestamp(currentCue.startTime),
                        end: vttToTimestamp(currentCue.endTime),
                        text: currentCue.text
                    };

                    // Load saved formatting for this cue
                    if (allCueFormatting[currentCueInfo.start]) {
                        subtitleFormatting = { ...allCueFormatting[currentCueInfo.start] };
                    } else {
                        subtitleFormatting = { bold: false, italic: false, color: null, size: null };
                    }

                    // Only update if user is not currently typing (check focus)
                    if (document.activeElement !== subtitleText) {
                        // Show text with HTML formatting if it exists
                        let displayHTML = currentCue.text;
                        const savedFormat = allCueFormatting[currentCueInfo.start];
                        if (savedFormat && (savedFormat.bold || savedFormat.italic || savedFormat.color || savedFormat.size)) {
                            // Wrap text with HTML tags
                            if (savedFormat.bold) {
                                displayHTML = `<strong>${displayHTML}</strong>`;
                            }
                            if (savedFormat.italic) {
                                displayHTML = `<em>${displayHTML}</em>`;
                            }
                            if (savedFormat.color) {
                                displayHTML = `<span style="color:${savedFormat.color}">${displayHTML}</span>`;
                            }
                            if (savedFormat.size) {
                                displayHTML = `<span style="font-size:${savedFormat.size}em">${displayHTML}</span>`;
                            }
                        }
                        subtitleText.innerHTML = displayHTML;
                        updateSubtitlePreview();
                    }
                }
            };

            // Update time display and seekbar
            const updateTimeDisplay = () => {
                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd);
                const currentTime = previewVideo.currentTime;

                // Show time relative to theme start
                const relativeTime = currentTime - themeStart;
                const themeDuration = themeEnd - themeStart;

                // Update seekbar position (0-100% of theme duration)
                const seekbarPercent = (Math.max(0, relativeTime) / themeDuration) * 100;
                previewSeekbar.value = seekbarPercent;

                // Update time display
                document.getElementById('preview-time-display').textContent =
                    `${formatTime(Math.max(0, relativeTime))} / ${formatTime(themeDuration)}`;
            };

            // Handle seekbar input
            const handleSeekbarInput = () => {
                if (videoControlsLocked) return;

                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd);
                const themeDuration = themeEnd - themeStart;

                // Calculate target time based on seekbar percentage
                const relativeTime = (previewSeekbar.value / 100) * themeDuration;
                previewVideo.currentTime = themeStart + relativeTime;
            };

            // Toggle play/pause
            const togglePlayPause = () => {
                if (videoControlsLocked) return;

                if (previewVideo.paused) {
                    previewVideo.play();
                } else {
                    previewVideo.pause();
                }
            };

            // Update play button icon
            const updatePlayButton = () => {
                previewPlayBtn.textContent = previewVideo.paused ? '‚ñ∂' : '‚è∏';
            };

            // Add new listeners
            previewVideo.boundariesHandler = enforceThemeBoundaries;
            previewVideo.addEventListener('timeupdate', enforceThemeBoundaries);

            previewVideo.subtitleSyncHandler = syncSubtitleToTextarea;
            previewVideo.addEventListener('timeupdate', syncSubtitleToTextarea);

            previewVideo.timeUpdateHandler = updateTimeDisplay;
            previewVideo.addEventListener('timeupdate', updateTimeDisplay);

            previewVideo.seekbarHandler = handleSeekbarInput;
            previewSeekbar.addEventListener('input', handleSeekbarInput);

            previewVideo.playBtnHandler = togglePlayPause;
            previewPlayBtn.addEventListener('click', togglePlayPause);

            previewVideo.clickHandler = togglePlayPause;
            previewVideo.addEventListener('click', togglePlayPause);

            previewVideo.playHandler = updatePlayButton;
            previewVideo.addEventListener('play', updatePlayButton);

            previewVideo.pauseHandler = updatePlayButton;
            previewVideo.addEventListener('pause', updatePlayButton);

            // When video loads, seek to theme start and enable subtitles
            previewVideo.addEventListener('loadedmetadata', () => {
                previewVideo.currentTime = startSeconds;
                updateTimeDisplay();
                updatePlayButton();

                // DISABLE native VTT subtitles - we only show custom overlay
                setTimeout(() => {
                    if (previewVideo.textTracks.length > 0) {
                        previewVideo.textTracks[0].mode = 'hidden';
                    }
                }, 100);
            }, { once: true });

            // Load VTT subtitles for preview - use adjusted subtitles if available
            const previewSubtitleTrack = document.getElementById('preview-subtitle-track');
            if (previewSubtitleTrack) {
                previewSubtitleTrack.src = `/api/subtitles/${folderNumber}/${themeNumber}.vtt`;
            }

            // Don't autoplay
            // previewVideo.play().catch(() => {});
        }

        // Update UI
        function updateUI() {
            if (!fullVideoDuration) return;

            const clipDuration = endSeconds - startSeconds;
            const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
            const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);
            bufferedDuration = bufferEnd - bufferStart;

            // Position buffer range on full video timeline
            const bufferLeftPercent = (bufferStart / fullVideoDuration) * 100;
            const bufferWidthPercent = (bufferedDuration / fullVideoDuration) * 100;
            bufferRange.style.left = `${bufferLeftPercent}%`;
            bufferRange.style.width = `${bufferWidthPercent}%`;

            // Position theme box within buffer range
            const themeLeftPercent = ((startSeconds - bufferStart) / bufferedDuration) * 100;
            const themeWidthPercent = (clipDuration / bufferedDuration) * 100;
            themeBox.style.left = `${themeLeftPercent}%`;
            themeBox.style.width = `${themeWidthPercent}%`;
            themeBoxContent.textContent = `${formatTime(startSeconds)} - ${formatTime(endSeconds)}`;

            // Update timeline markers to show full video range
            document.getElementById('time-start-marker').textContent = '00:00:00';
            document.getElementById('time-end-marker').textContent = formatTime(fullVideoDuration);

            // Update info display
            document.getElementById('display-start').textContent = formatTime(startSeconds);
            document.getElementById('display-end').textContent = formatTime(endSeconds);
            document.getElementById('display-duration').textContent = formatTime(clipDuration);

            // Update buffer display with separate left/right values
            const bufferLeftMin = Math.round(bufferLeftSeconds / 60);
            const bufferRightMin = Math.round(bufferRightSeconds / 60);
            document.getElementById('buffer-display').textContent = `L: ¬±${bufferLeftMin}min | R: ¬±${bufferRightMin}min`;

            // Update buffer info on video
            document.getElementById('buffer-info').textContent =
                `Buffer range: ${formatTime(bufferStart)} - ${formatTime(bufferEnd)} (${formatTime(bufferedDuration)})`;

            // Update subtitle preview
            updateSubtitlePreview();

            // Update preview video when range changes
            updatePreviewVideo();

            // Update original video to show only buffered range (but not during drag)
            if (!isDragging) {
                updateOriginalVideoRange();
            }
        }

        // Setup drag handlers
        function setupDragHandlers() {
            // Left handle - adjust start time
            handleLeft.addEventListener('mousedown', (e) => {
                isDragging = 'left';
                dragStartX = e.clientX;
                dragStartValue = startSeconds;
                e.preventDefault();
                e.stopPropagation();
            });

            // Right handle - adjust end time
            handleRight.addEventListener('mousedown', (e) => {
                isDragging = 'right';
                dragStartX = e.clientX;
                dragStartValue = endSeconds;
                e.preventDefault();
                e.stopPropagation();
            });

            // Hover effects - highlight theme box edges
            handleLeft.addEventListener('mouseenter', () => {
                themeBox.classList.add('highlight-left');
            });

            handleLeft.addEventListener('mouseleave', () => {
                themeBox.classList.remove('highlight-left');
            });

            handleRight.addEventListener('mouseenter', () => {
                themeBox.classList.add('highlight-right');
            });

            handleRight.addEventListener('mouseleave', () => {
                themeBox.classList.remove('highlight-right');
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - dragStartX;
                // Use full video duration for drag calculations
                const deltaTime = (deltaX / timelineTrack.offsetWidth) * fullVideoDuration;

                if (isDragging === 'left') {
                    let newStart = dragStartValue + deltaTime;
                    newStart = Math.max(0, Math.min(newStart, endSeconds - 20));
                    startSeconds = newStart;
                } else if (isDragging === 'right') {
                    let newEnd = dragStartValue + deltaTime;
                    newEnd = Math.max(startSeconds + 20, Math.min(newEnd, fullVideoDuration));
                    endSeconds = newEnd;
                }

                updateUI();
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    // Drag ended - seek original video to new theme start position
                    originalVideo.currentTime = startSeconds;
                    // Auto-save theme adjustment
                    autoSaveTheme();
                }
                isDragging = null;
            });

            // Video buffer controls - adjust buffer on each side independently

            // Left side controls - adjust buffer before theme
            const leftDecreaseBtn = document.getElementById('video-buffer-decrease-left');
            const leftIncreaseBtn = document.getElementById('video-buffer-increase-left');
            const rightDecreaseBtn = document.getElementById('video-buffer-decrease-right');
            const rightIncreaseBtn = document.getElementById('video-buffer-increase-right');

            leftDecreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferLeftSeconds = Math.max(0, bufferLeftSeconds - 60);
                updateUI();
            });

            leftIncreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferLeftSeconds += 60;
                updateUI();
            });

            // Right side controls - adjust buffer after theme
            rightDecreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferRightSeconds = Math.max(0, bufferRightSeconds - 60);
                updateUI();
            });

            rightIncreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferRightSeconds += 60;
                updateUI();
            });
        }

        // Setup custom video controls
        function setupVideoControls() {
            // Set initial volume
            originalVideo.volume = volumeSlider.value;

            // Play/Pause button
            playPauseBtn.addEventListener('click', () => {
                if (originalVideo.paused) {
                    originalVideo.play();
                    playPauseBtn.textContent = '‚è∏';
                } else {
                    originalVideo.pause();
                    playPauseBtn.textContent = '‚ñ∂';
                }
            });

            // Update play/pause button when video state changes
            originalVideo.addEventListener('play', () => {
                playPauseBtn.textContent = '‚è∏';
            });

            originalVideo.addEventListener('pause', () => {
                playPauseBtn.textContent = '‚ñ∂';
            });

            // Update seekbar as video plays
            originalVideo.addEventListener('timeupdate', () => {
                // Calculate position within buffer range
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);

                // Keep video within buffer range
                if (originalVideo.currentTime < bufferStart) {
                    originalVideo.currentTime = bufferStart;
                } else if (originalVideo.currentTime > bufferEnd) {
                    originalVideo.currentTime = bufferEnd;
                    originalVideo.pause();
                }

                // Update seekbar (0-100% of buffer)
                const positionInBuffer = originalVideo.currentTime - bufferStart;
                const percent = (positionInBuffer / bufferedDuration) * 100;
                seekbar.value = percent;

                // Update time display (showing time relative to buffer start)
                timeDisplay.textContent = `${formatTime(positionInBuffer)} / ${formatTime(bufferedDuration)}`;
            });

            // Seek when user drags seekbar
            seekbar.addEventListener('input', () => {
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const percent = seekbar.value;
                const positionInBuffer = (percent / 100) * bufferedDuration;
                originalVideo.currentTime = bufferStart + positionInBuffer;
            });

            // Jump to theme start
            jumpStartBtn.addEventListener('click', () => {
                originalVideo.currentTime = startSeconds;
            });

            // Jump to theme end
            jumpEndBtn.addEventListener('click', () => {
                originalVideo.currentTime = endSeconds;
            });

            // Volume control
            volumeSlider.addEventListener('input', () => {
                originalVideo.volume = volumeSlider.value;
            });

            // Click on video to play/pause
            originalVideo.addEventListener('click', () => {
                if (originalVideo.paused) {
                    originalVideo.play();
                } else {
                    originalVideo.pause();
                }
            });

            // Update seekbar theme markers
            const updateSeekbarTheme = () => {
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);

                // Calculate theme position within buffer (as percentage)
                const themeStartPercent = ((startSeconds - bufferStart) / bufferedDuration) * 100;
                const themeEndPercent = ((endSeconds - bufferStart) / bufferedDuration) * 100;

                // Set CSS custom properties for gradient
                seekbar.style.setProperty('--theme-start', `${themeStartPercent}%`);
                seekbar.style.setProperty('--theme-end', `${themeEndPercent}%`);
                seekbar.classList.add('theme-marked');

                // Position marker at center of theme range
                const themeCenterPercent = (themeStartPercent + themeEndPercent) / 2;
                themeMarker.style.left = `${themeCenterPercent}%`;

                // Update theme duration text
                const themeDuration = endSeconds - startSeconds;
                themeDurationText.textContent = formatTime(themeDuration);
            };

            // Set initial seekbar and time display
            seekbar.max = 100;

            // Calculate initial position in buffer (theme start position)
            const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
            const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);
            const positionInBuffer = originalVideo.currentTime - bufferStart;
            const seekbarPercent = (positionInBuffer / bufferedDuration) * 100;

            seekbar.value = seekbarPercent;
            timeDisplay.textContent = `${formatTime(positionInBuffer)} / ${formatTime(bufferedDuration)}`;

            // Apply theme markers to seekbar
            updateSeekbarTheme();

            // Update theme markers when theme range changes
            const originalUpdateUI = updateUI;
            updateUI = function() {
                originalUpdateUI();
                updateSeekbarTheme();
            };
        }

        // Update subtitle preview
        function updateSubtitlePreview() {
            const editor = document.getElementById('subtitle-text');
            let text = editor.innerText; // Get plain text for saving
            const html = editor.innerHTML; // Get HTML for display
            const fontSize = document.getElementById('subtitle-size').value;
            const fontFamily = document.getElementById('subtitle-font').value;
            const color = document.getElementById('subtitle-color').value;
            const bgColor = document.getElementById('subtitle-bg').value;
            const bgOpacity = document.getElementById('subtitle-bg-opacity').value / 100;
            const position = document.getElementById('subtitle-position').value;

            const overlay = document.getElementById('subtitle-overlay');
            const textEl = document.getElementById('subtitle-preview-text');

            // For preview, use the innerHTML directly to show formatting
            let displayText = html;

            // Only show overlay if there's text
            if (displayText.trim()) {
                textEl.innerHTML = displayText;
                textEl.style.fontSize = `${fontSize}px`;
                textEl.style.fontFamily = fontFamily;
                textEl.style.color = color;
                textEl.style.backgroundColor = `rgba(${hexToRgb(bgColor)}, ${bgOpacity})`;
                overlay.style.display = 'block';
                overlay.style.left = '50%';

                // Only update position if NOT manually positioned
                // When user has dragged the subtitle, keep their manual position
                if (!hasManualPosition) {
                    // Position overlay
                    if (position === 'bottom') {
                        overlay.style.bottom = '40px';
                        overlay.style.top = 'auto';
                        overlay.style.transform = 'translateX(-50%)';
                    } else if (position === 'top') {
                        overlay.style.top = '20px';
                        overlay.style.bottom = 'auto';
                        overlay.style.transform = 'translateX(-50%)';
                    } else {
                        overlay.style.top = '50%';
                        overlay.style.bottom = 'auto';
                        overlay.style.transform = 'translate(-50%, -50%)';
                    }
                }
            } else {
                overlay.style.display = 'none';
            }
        }

        // Helper: hex to rgb
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '0, 0, 0';
        }

        // Rich text toolbar functions
        function toggleStyle(style) {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            // Save current selection
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);

                // Only apply if there's actual text selected
                if (range.toString().trim().length > 0) {
                    const tag = style === 'bold' ? 'strong' : 'em';
                    const element = document.createElement(tag);
                    element.textContent = range.toString();

                    try {
                        // Delete the selected content and insert the formatted element
                        range.deleteContents();
                        range.insertNode(element);

                        // Restore selection to the new element
                        range.selectNodeContents(element);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    } catch (e) {
                        // Fallback to execCommand if surroundContents fails
                        console.error('Error applying style:', e);
                        document.execCommand(style === 'bold' ? 'bold' : 'italic', false, null);
                    }
                }
            }

            // Save the formatting for the current cue
            saveCurrentCueFormatting();
        }

        function applyColor(color) {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            // Save current selection
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);

                // Only apply if there's actual text selected
                if (range.toString().trim().length > 0) {
                    // Create a span with the color
                    const span = document.createElement('span');
                    span.style.color = color;
                    span.textContent = range.toString();

                    try {
                        // Delete the selected content and insert the colored span
                        range.deleteContents();
                        range.insertNode(span);

                        // Restore selection to the new span
                        range.selectNodeContents(span);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    } catch (e) {
                        // Fallback to execCommand if surroundContents fails
                        console.error('Error applying color:', e);
                        document.execCommand('styleWithCSS', false, true);
                        document.execCommand('foreColor', false, color);
                    }
                }
            }

            // Save the formatting for the current cue
            saveCurrentCueFormatting();
        }

        function applySize(multiplier) {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            // Get current selection and wrap with span
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const span = document.createElement('span');
                span.style.fontSize = `${multiplier}em`;
                try {
                    range.surroundContents(span);
                } catch (e) {
                    // If selection is complex, use execCommand
                    document.execCommand('fontSize', false, '7');
                    const fontElements = editor.querySelectorAll('font[size="7"]');
                    fontElements.forEach(el => {
                        el.removeAttribute('size');
                        el.style.fontSize = `${multiplier}em`;
                    });
                }
            }

            // Save the formatting for the current cue
            saveCurrentCueFormatting();
        }

        function removeFormatting() {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);

                // Only apply if there's actual text selected
                if (range.toString().trim().length > 0) {
                    // Remove all formatting using execCommand
                    document.execCommand('removeFormat', false, null);
                }
            }

            // Save the formatting for the current cue
            saveCurrentCueFormatting();
        }

        // Save formatting for the current cue
        async function saveCurrentCueFormatting() {
            if (!currentCueInfo) return;

            const editor = document.getElementById('subtitle-text');

            // Extract formatting from the HTML
            const bold = editor.querySelector('strong') !== null;
            const italic = editor.querySelector('em') !== null;
            const colorSpan = editor.querySelector('span[style*="color"]');
            const color = colorSpan ? colorSpan.style.color : null;
            const sizeSpan = editor.querySelector('span[style*="font-size"]');
            let size = null;
            if (sizeSpan && sizeSpan.style.fontSize) {
                const match = sizeSpan.style.fontSize.match(/([\d.]+)em/);
                if (match) size = parseFloat(match[1]);
            }

            // Store formatting for this cue
            allCueFormatting[currentCueInfo.start] = {
                bold: bold,
                italic: italic,
                color: color,
                size: size
            };
            subtitleFormatting = { ...allCueFormatting[currentCueInfo.start] };

            // Save to server
            try {
                await fetch('/api/save-subtitle-formatting', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        formatting: allCueFormatting
                    })
                });
            } catch (error) {
                console.error('Failed to save formatting:', error);
            }
        }

        // Event listeners for subtitle settings
        document.getElementById('subtitle-text').addEventListener('input', () => {
            updateSubtitlePreview();
            autoSaveSubtitle(); // Auto-save subtitle edits
        });
        document.getElementById('subtitle-font').addEventListener('change', updateSubtitlePreview);
        document.getElementById('subtitle-size').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-color').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-bg').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-bg-opacity').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-position').addEventListener('change', () => {
            hasManualPosition = false; // Clear manual position when user changes dropdown
            updateSubtitlePreview();
        });

        // Theme name editing
        const themeNameElement = document.getElementById('theme-name');
        let originalThemeName = '';

        themeNameElement.addEventListener('focus', () => {
            originalThemeName = themeNameElement.textContent;
        });

        themeNameElement.addEventListener('blur', () => {
            const newName = themeNameElement.textContent.trim();
            if (newName && newName !== originalThemeName) {
                // Save the new name
                themeData.title = newName;
                autoSaveTheme();
                // Update header too
                document.getElementById('header-theme-name').textContent = newName;
            } else if (!newName) {
                // Revert if empty
                themeNameElement.textContent = originalThemeName;
            }
        });

        themeNameElement.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                themeNameElement.blur();
            } else if (e.key === 'Escape') {
                themeNameElement.textContent = originalThemeName;
                themeNameElement.blur();
            }
        });

        // Preview button
        document.getElementById('preview-btn').addEventListener('click', () => {
            previewVideo.currentTime = startSeconds;
            previewVideo.play();

            const checkEnd = () => {
                if (previewVideo.currentTime >= endSeconds) {
                    previewVideo.pause();
                    previewVideo.removeEventListener('timeupdate', checkEnd);
                }
            };
            previewVideo.addEventListener('timeupdate', checkEnd);
        });

        // Save button
        document.getElementById('save-btn').addEventListener('click', async () => {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = 'Saving...';
            messageDiv.className = '';

            try {
                const duration = endSeconds - startSeconds;
                if (duration < 20) {
                    throw new Error('Duration must be at least 20 seconds for YouTube Shorts');
                }

                const updates = {
                    folder: folderNumber,
                    theme: themeNumber,
                    title: themeData.title,
                    start: formatTime(startSeconds),
                    end: formatTime(endSeconds)
                };

                const response = await fetch('/api/update-theme', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updates)
                });

                if (!response.ok) throw new Error('Failed to save changes');

                messageDiv.textContent = '‚úì Theme updated successfully!';
                messageDiv.className = 'success';

                setTimeout(() => {
                    window.close();
                }, 1500);

            } catch (error) {
                messageDiv.textContent = '‚úó ' + error.message;
                messageDiv.className = 'error';
            }
        });

        // Subtitles toggle
        document.getElementById('subtitles-toggle').addEventListener('change', (e) => {
            const track = originalVideo.textTracks[0];
            if (track) {
                track.mode = e.target.checked ? 'showing' : 'hidden';
            }
        });

        // Overlay toggle
        document.getElementById('overlay-toggle').addEventListener('change', (e) => {
            const overlay = document.getElementById('shorts-overlay');
            if (e.target.checked) {
                overlay.classList.remove('hidden');
            } else {
                overlay.classList.add('hidden');
            }
        });

        // Lock video controls button
        document.getElementById('lock-video-btn').addEventListener('click', () => {
            videoControlsLocked = !videoControlsLocked;
            const lockBtn = document.getElementById('lock-video-btn');
            const lockIcon = document.getElementById('lock-icon');
            const subtitleOverlay = document.getElementById('subtitle-overlay');

            if (videoControlsLocked) {
                lockBtn.classList.add('locked');
                lockIcon.textContent = 'üîí';
                lockBtn.title = 'Unlock video controls';

                // Pause video if playing when locked
                if (!previewVideo.paused) {
                    previewVideo.pause();
                }

                // Enable subtitle dragging when locked
                if (subtitleOverlay) {
                    subtitleOverlay.classList.add('draggable');
                }
            } else {
                lockBtn.classList.remove('locked');
                lockIcon.textContent = 'üîì';
                lockBtn.title = 'Lock video controls';

                // Disable subtitle dragging when unlocked
                if (subtitleOverlay) {
                    subtitleOverlay.classList.remove('draggable');
                }
            }
        });

        // Subtitle dragging functionality
        const subtitleOverlay = document.getElementById('subtitle-overlay');
        let isDraggingSubtitle = false;
        let subtitleDragStart = { x: 0, y: 0 };
        let subtitleStartPos = { left: 0, top: 0 };
        let hasManualPosition = false; // Flag to indicate manual positioning

        subtitleOverlay.addEventListener('mousedown', (e) => {
            if (!videoControlsLocked) return;

            isDraggingSubtitle = true;
            hasManualPosition = true; // Mark as having manual position

            subtitleDragStart = { x: e.clientX, y: e.clientY };

            // Get current position from computed style
            const computedStyle = window.getComputedStyle(subtitleOverlay);
            const rect = subtitleOverlay.getBoundingClientRect();
            const parentRect = subtitleOverlay.parentElement.getBoundingClientRect();

            // Store initial position relative to parent
            subtitleStartPos = {
                left: rect.left - parentRect.left,
                top: rect.top - parentRect.top
            };

            e.preventDefault();
            e.stopPropagation();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingSubtitle || !videoControlsLocked) return;

            const deltaX = e.clientX - subtitleDragStart.x;
            const deltaY = e.clientY - subtitleDragStart.y;

            const parentRect = subtitleOverlay.parentElement.getBoundingClientRect();

            // Calculate new position
            let newX = subtitleStartPos.left + deltaX;
            let newY = subtitleStartPos.top + deltaY;

            // Constrain within parent bounds with some padding
            const padding = 10;
            const maxX = parentRect.width - subtitleOverlay.offsetWidth - padding;
            const maxY = parentRect.height - subtitleOverlay.offsetHeight - padding;

            newX = Math.max(padding, Math.min(newX, maxX));
            newY = Math.max(padding, Math.min(newY, maxY));

            // Update position
            subtitleOverlay.style.left = `${newX + subtitleOverlay.offsetWidth / 2}px`;
            subtitleOverlay.style.top = `${newY}px`;
            subtitleOverlay.style.bottom = 'auto';
            subtitleOverlay.style.transform = 'translateX(-50%)';

            // Add visual border during drag to see position clearly
            subtitleOverlay.style.border = '2px solid yellow';
        });

        document.addEventListener('mouseup', () => {
            if (isDraggingSubtitle) {
                isDraggingSubtitle = false;

                // Remove drag border
                subtitleOverlay.style.border = '';

                // Update subtitle position setting to match new position
                const rect = subtitleOverlay.getBoundingClientRect();
                const parentRect = subtitleOverlay.parentElement.getBoundingClientRect();

                const relativeTop = rect.top - parentRect.top;
                const relativeBottom = parentRect.height - rect.top - rect.height;

                // Determine position (top/middle/bottom) based on current location
                const positionSelect = document.getElementById('subtitle-position');
                const third = parentRect.height / 3;

                if (relativeTop < third) {
                    positionSelect.value = 'top';
                } else if (relativeTop > 2 * third) {
                    positionSelect.value = 'bottom';
                } else {
                    positionSelect.value = 'middle';
                }

                updateSubtitlePreview();
            }
        });

        // Keyboard controls for preview video
        document.addEventListener('keydown', (e) => {
            // Only handle keyboard events when not in textarea/input or editing theme name
            if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT' || e.target.id === 'theme-name') {
                return;
            }

            // Space key for play/pause
            if (e.code === 'Space') {
                e.preventDefault();
                if (!videoControlsLocked) {
                    if (previewVideo.paused) {
                        previewVideo.play();
                    } else {
                        previewVideo.pause();
                    }
                }
                return;
            }

            // Arrow keys for seeking (only when video controls are not locked)
            if (!videoControlsLocked && (e.code === 'ArrowLeft' || e.code === 'ArrowRight')) {
                e.preventDefault();

                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd);
                const seekAmount = 5; // Seek by 5 seconds

                if (e.code === 'ArrowLeft') {
                    // Seek backward
                    previewVideo.currentTime = Math.max(themeStart, previewVideo.currentTime - seekAmount);
                } else {
                    // Seek forward
                    previewVideo.currentTime = Math.min(themeEnd, previewVideo.currentTime + seekAmount);
                }
            }
        });

        // Subtitle Editor Modal
        let themeSubtitles = []; // Store all subtitles for the theme
        const subtitleModal = document.getElementById('subtitle-modal');
        const editAllSubsBtn = document.getElementById('edit-all-subs-btn');
        const closeSubsModal = subtitleModal.querySelector('.close');
        const cancelSubsBtn = document.getElementById('cancel-subs-btn');
        const saveSubsBtn = document.getElementById('save-subs-btn');

        // Open subtitle editor modal
        editAllSubsBtn.addEventListener('click', async () => {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = 'Loading subtitles...';
            messageDiv.className = '';

            try {
                const response = await fetch(`/api/theme-subtitles/${folderNumber}/${themeNumber}`);
                if (!response.ok) throw new Error('Failed to load subtitles');

                const data = await response.json();
                themeSubtitles = data.cues;

                renderSubtitleCues();
                subtitleModal.style.display = 'block';
                messageDiv.textContent = '';
                messageDiv.className = '';
            } catch (error) {
                messageDiv.textContent = `Error: ${error.message}`;
                messageDiv.className = 'error';
            }
        });

        // Close modal handlers
        closeSubsModal.addEventListener('click', () => {
            subtitleModal.style.display = 'none';
        });

        cancelSubsBtn.addEventListener('click', () => {
            subtitleModal.style.display = 'none';
        });

        window.addEventListener('click', (e) => {
            if (e.target === subtitleModal) {
                subtitleModal.style.display = 'none';
            }
        });

        // Render subtitle cues in the modal
        function renderSubtitleCues() {
            const container = document.getElementById('subtitle-cues-container');
            container.innerHTML = '';

            themeSubtitles.forEach((cue, index) => {
                const cueDiv = document.createElement('div');
                cueDiv.className = 'subtitle-cue-item';
                cueDiv.innerHTML = `
                    <div class="cue-header">
                        <strong>#${cue.sequence}</strong>
                        <label>Start:
                            <input type="text" class="cue-time-input" data-index="${index}" data-field="start" value="${cue.start}">
                        </label>
                        <label>End:
                            <input type="text" class="cue-time-input" data-index="${index}" data-field="end" value="${cue.end}">
                        </label>
                    </div>
                    <textarea class="cue-textarea" data-index="${index}" data-field="text">${cue.text}</textarea>
                `;
                container.appendChild(cueDiv);
            });

            // Add event listeners to inputs
            container.querySelectorAll('.cue-time-input, .cue-textarea').forEach(input => {
                input.addEventListener('input', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const field = e.target.dataset.field;
                    themeSubtitles[index][field] = e.target.value;
                });
            });
        }

        // Save subtitles
        saveSubsBtn.addEventListener('click', async () => {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = 'Saving subtitles...';
            messageDiv.className = '';

            try {
                const response = await fetch('/api/save-theme-subtitles', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        cues: themeSubtitles
                    })
                });

                if (!response.ok) throw new Error('Failed to save subtitles');

                const result = await response.json();
                messageDiv.textContent = `‚úì ${result.message}`;
                messageDiv.className = 'success';

                // Reload the video subtitles
                const subtitleTrack = document.getElementById('subtitle-track');
                subtitleTrack.src = `/api/subtitles/${folderNumber}.vtt?t=${Date.now()}`;

                subtitleModal.style.display = 'none';

                setTimeout(() => {
                    messageDiv.textContent = '';
                    messageDiv.className = '';
                }, 3000);
            } catch (error) {
                messageDiv.textContent = `Error: ${error.message}`;
                messageDiv.className = 'error';
            }
        });

        // Initialize
        if (folderNumber && themeNumber) {
            loadTheme();
        } else {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('error').textContent = 'Missing folder or theme number';
            document.getElementById('error').classList.remove('hidden');
        }
    </script>
</body>
</html>
