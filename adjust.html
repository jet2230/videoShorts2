<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adjust Theme - YouTube Shorts Creator</title>
    <!-- ffmpeg.wasm for client-side video encoding -->
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.7/dist/umd/ffmpeg.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.1/dist/umd/util.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a15 0%, #1a1a2e 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .back-link {
            color: #00ff9d;
            text-decoration: none;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .container {
            display: grid;
            grid-template-columns: 7fr 3fr;
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }

        .panel {
            background: rgba(30, 30, 45, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
        }

        .panel h2 {
            color: #00ff9d;
            font-size: 16px;
            margin-bottom: 16px;
        }

        /* Video containers */
        .video-wrapper {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 16/9;
            margin-bottom: 16px;
        }

        .buffer-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            font-family: monospace;
            z-index: 10;
            pointer-events: none;
        }

        .autosave-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 255, 157, 0.9);
            color: #000;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .autosave-indicator.show {
            opacity: 1;
        }

        .autosave-indicator.saving {
            background: rgba(255, 193, 7, 0.9);
        }

        .preview-autosave {
            top: 10px;
            right: 10px;
            left: auto;
        }

        /* Custom Video Controls */
        .video-controls-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 20;
            pointer-events: none;
        }

        .video-wrapper:hover .video-controls-overlay {
            opacity: 1;
            pointer-events: auto;
        }

        .controls-progress {
            width: 100%;
            margin-bottom: 8px;
            position: relative;
        }

        .seekbar {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        /* Seekbar with theme range marked in red */
        .seekbar.theme-marked {
            background: linear-gradient(to right,
                rgba(255, 255, 255, 0.3) var(--theme-start),
                rgba(244, 67, 54, 0.85) var(--theme-start),
                rgba(244, 67, 54, 0.85) var(--theme-end),
                rgba(255, 255, 255, 0.3) var(--theme-end)
            );
        }

        /* Theme marker flag */
        .theme-marker {
            position: absolute;
            top: -30px;
            left: 0;
            transform: translateX(-50%);
            pointer-events: none;
            transition: left 0.2s;
        }

        .theme-marker-flag {
            position: relative;
            background: rgba(244, 67, 54, 0.9);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            font-weight: 500;
        }

        .theme-marker-flag::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid rgba(244, 67, 54, 0.9);
        }

        .seekbar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }

        .seekbar::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .controls-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .control-icon {
            background: none;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            padding: 4px 8px;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .control-icon:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .control-jump {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .control-jump:hover {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
        }

        .time-display {
            color: #fff;
            font-size: 13px;
            font-family: monospace;
            flex-grow: 1;
        }

        .volume-slider {
            width: 80px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        .volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* Theme clip preview - 9:16 aspect ratio for YouTube Shorts */
        .preview-wrapper {
            aspect-ratio: 9/16;
            max-height: 500px;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Preview video should crop to fill the 9:16 frame */
        #preview-video {
            object-fit: cover;
        }

        /* Canvas for karaoke rendering */
        #karaoke-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            z-index: 15; /* Above video but below controls (z-index 20) */
        }

        /* Preview seekbar container */
        .preview-seekbar-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 10px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 8px;
            opacity: 1;
            transition: opacity 0.3s;
            pointer-events: auto;
        }
        #preview-video::cue {
            background-color: transparent !important;
            color: transparent !important;
            text-shadow: none !important;
        }
        #preview-video::cue-background {
            background-color: transparent !important;
        }

        /* Extra hiding for canvas mode - ensure VTT is completely invisible */
        #preview-video.canvas-mode-active::cue {
            display: none !important;
            opacity: 0 !important;
            visibility: hidden !important;
        }

        #preview-video.canvas-mode-active::-webkit-media-text-track-display {
            display: none !important;
        }

        #preview-video.canvas-mode-active::-webkit-media-text-track-container {
            display: none !important;
        }

        #preview-video.canvas-mode-active text {
            display: none !important;
        }

        /* Preview seekbar container */
        .preview-seekbar-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 10px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .preview-wrapper:hover .preview-seekbar-container {
            opacity: 1;
            pointer-events: auto;
        }

        .preview-controls-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .preview-time-row {
            display: flex;
            justify-content: center;
        }

        .preview-control-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #00ff9d;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .preview-control-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        .preview-seekbar {
            flex-grow: 1;
        }

        .preview-time-display {
            font-size: 13px;
            color: #00ff9d;
            font-family: monospace;
        }

        /* Subtitle overlay */
        .subtitle-overlay {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 80%;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        .subtitle-overlay.draggable {
            pointer-events: auto;
            cursor: move;
            z-index: 30; /* Above controls (z-index 20) but not too high */
        }

        .subtitle-text {
            display: inline-block;
            padding: 6px 16px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 6px;
            line-height: 1.4;
        }

        /* Shorts 9:16 crop overlay */
        .shorts-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .shorts-crop-area {
            width: 56.25%;
            height: 100%;
            border: 3px solid rgba(0, 255, 157, 0.8);
            background: rgba(0, 255, 157, 0.1);
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.3);
        }

        .shorts-crop-area::before {
            content: '9:16';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 157, 0.9);
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        /* Timeline */
        .timeline-container {
            margin-top: 16px;
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        /* Video buffer controls (on sides of video) */
        .video-buffer-btn {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #00ff9d;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
            pointer-events: auto;
        }

        .video-buffer-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        /* Buffer button containers */
        .video-buffer-controls-left,
        .video-buffer-controls-right {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 30;
        }

        .video-buffer-controls-left {
            left: 10px;
        }

        .video-buffer-controls-right {
            right: 10px;
        }

        /* Position buffer buttons inside video on edges */
        .video-buffer-btn.video-buffer-left {
            position: static;
            transform: none;
        }

        .video-buffer-btn.video-buffer-right {
            position: static;
            transform: none;
        }

        .buffer-label {
            font-size: 12px;
            color: #aaa;
        }

        .reset-timeline-btn {
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255, 87, 34, 0.5);
            background: rgba(255, 87, 34, 0.1);
            color: #ff5722;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .reset-timeline-btn:hover {
            background: rgba(255, 87, 34, 0.2);
            border-color: rgba(255, 87, 34, 0.8);
            transform: translateY(-1px);
        }

        .reset-timeline-btn:active {
            transform: translateY(0);
            background: rgba(255, 87, 34, 0.3);
        }

        .timeline-track {
            position: relative;
            height: 60px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            overflow: hidden;
        }

        /* Buffer range band (shows the buffered portion of the video) */
        .buffer-range {
            position: absolute;
            height: 100%;
            background: rgba(100, 150, 200, 0.2);
            border-radius: 6px;
        }

        .theme-box {
            position: absolute;
            height: 100%;
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.5), rgba(255, 87, 34, 0.5));
            border: 2px solid #f44336;
            border-radius: 6px;
            cursor: default;
            transition: border-color 0.2s;
        }

        .theme-box.highlight-left {
            border-left: 4px solid #ff9800;
        }

        .theme-box.highlight-right {
            border-right: 4px solid #ff9800;
        }

        .theme-box-handle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: #f44336;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: ew-resize;
            z-index: 10;
            transition: background 0.2s, border-color 0.2s;
        }

        .theme-box-handle:hover {
            background: #ff9800 !important;
            border-color: #fff !important;
        }

        .theme-box-handle.left {
            left: -8px; /* Position outside left edge */
        }

        .theme-box-handle.right {
            right: -8px; /* Position outside right edge */
        }

        .theme-box-content {
            position: absolute;
            top: 50%;
            left: 20px;
            right: 20px;
            transform: translateY(-50%);
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .time-markers {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 11px;
            color: #aaa;
        }

        /* Time start marker inside timeline */
        .time-start-marker-inside {
            position: absolute;
            bottom: 4px;
            left: 8px;
            font-size: 11px;
            color: #00ff9d;
            font-weight: 500;
            pointer-events: none;
            z-index: 5;
        }

        /* Time end marker inside timeline */
        .time-end-marker-inside {
            position: absolute;
            bottom: 4px;
            right: 8px;
            font-size: 11px;
            color: #00ff9d;
            font-weight: 500;
            pointer-events: none;
            z-index: 5;
        }

        /* Info display */
        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #aaa;
            font-size: 13px;
        }

        .info-value {
            font-weight: 600;
            font-size: 14px;
        }

        #folder-location {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: inline-block;
            vertical-align: bottom;
            cursor: help;
        }

        #folder-location:hover {
            overflow: visible;
            white-space: normal;
            word-wrap: break-word;
        }

        .duration-value {
            color: #00ff9d;
            font-size: 18px;
        }

        /* Subtitle editor */
        .subtitle-editor {
            margin-top: 20px;
        }

        .lock-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .lock-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        .lock-btn.locked {
            background: rgba(255, 152, 0, 0.2);
            border-color: #ff9800;
        }

        .subtitle-section {
            margin-bottom: 20px;
        }

        .subtitle-section h3 {
            font-size: 14px;
            color: #00ff9d;
            margin-bottom: 12px;
        }

        .form-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .form-group {
            flex: 1;
        }

        .form-group label {
            display: block;
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #00ff9d;
        }

        .form-group input[type="color"] {
            height: 40px;
            padding: 4px;
        }

        .position-mode-group {
            display: flex;
            gap: 2px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 2px;
        }

        .position-mode-btn {
            flex: 1;
            padding: 6px 8px;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .position-mode-btn:hover {
            color: rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.05);
        }

        .position-mode-btn.active {
            background: #00ff9d;
            color: #000;
            font-weight: 600;
        }

        .position-mode-btn.active:hover {
            background: #00cc7d;
        }

        .align-group {
            display: flex;
            gap: 2px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 2px;
        }

        .align-btn {
            flex: 1;
            padding: 6px 2px;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            line-height: 1;
        }

        .align-btn:hover {
            color: rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.05);
        }

        .align-btn.active {
            background: #00ff9d;
            color: #000;
        }

        .subtitle-text-area {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            /* Don't set color here - let inline styles work */
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
        }

        .subtitle-text-area:focus {
            outline: none;
            border-color: #00ff9d;
        }

        .subtitle-text-area:empty:before {
            content: attr(data-placeholder);
            color: rgba(255, 255, 255, 0.4);
        }

        .subtitle-text-area strong {
            font-weight: bold;
        }

        .subtitle-text-area em {
            font-style: italic;
        }

        .rich-text-toolbar {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .toolbar-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toolbar-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        .toolbar-btn.active {
            background: rgba(0, 255, 157, 0.3);
            border-color: #00ff9d;
        }

        .toolbar-divider {
            width: 1px;
            background: rgba(255, 255, 255, 0.2);
            margin: 0 4px;
        }

        /* Custom color picker */
        .color-picker-wrapper {
            position: relative;
            width: 36px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-picker-wrapper:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        .color-picker-wrapper::before {
            content: 'üé®';
            font-size: 14px;
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        /* Color preview dot (shows current/last selected color) */
        .color-picker-wrapper::after {
            content: '';
            position: absolute;
            bottom: 3px;
            right: 3px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.5);
            background: var(--current-color, #ff00ff);
            pointer-events: none;
            z-index: 2;
        }

        #custom-color-picker {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        #custom-color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        #custom-color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 4px;
        }

        /* Actions toolbar (for Edit All, Lock, Clear buttons) */
        .actions-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .actions-group {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .action-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        #lock-video-btn.locked {
            background: rgba(255, 152, 0, 0.2);
            border-color: #ff9800;
            color: #ff9800;
        }

        #lock-video-btn.locked:hover {
            background: rgba(255, 152, 0, 0.3);
        }

        /* Buttons */
        .buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00bfff, #00ff9d);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 255, 157, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Loading and messages */
        .loading {
            text-align: center;
            padding: 60px 20px;
            color: #aaa;
        }

        .error {
            background: rgba(255, 59, 48, 0.2);
            border: 1px solid rgba(255, 59, 48, 0.5);
            border-radius: 8px;
            padding: 16px;
            color: #ff6b6b;
        }

        .success {
            background: rgba(0, 255, 157, 0.2);
            border: 1px solid rgba(0, 255, 157, 0.5);
            border-radius: 8px;
            padding: 16px;
            color: #00ff9d;
        }

        .hidden {
            display: none !important;
        }

        /* Custom tooltip for directory location */
        .custom-tooltip {
            position: relative;
            display: inline-block;
        }

        .custom-tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-5px);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background-color: #1e1e1e;
            margin: 5% auto;
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header h2 {
            margin: 0;
            font-size: 20px;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover,
        .close:focus {
            color: #fff;
        }

        .modal-body {
            padding: 20px;
        }

        .subtitle-cue-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .cue-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 8px;
            font-size: 13px;
            color: #aaa;
        }

        .cue-time-input {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            width: 90px;
        }

        .cue-textarea {
            width: 100%;
            min-height: 60px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
        }

        .cue-textarea:focus {
            outline: none;
            border-color: #00ff9d;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            padding: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Time extension controls */
        .time-extension-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            margin: 16px 0;
            padding: 12px 16px;
            background: rgba(0, 255, 157, 0.08);
            border: 1px solid rgba(0, 255, 157, 0.2);
            border-radius: 8px;
        }

        .extension-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .extension-divider {
            color: #aaa;
            font-size: 14px;
            margin: 0 4px;
        }

        .extension-label {
            color: #00ff9d;
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
        }

        .extension-time-input {
            background: rgba(30, 30, 45, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 13px;
            padding: 6px 8px;
            font-family: monospace;
            width: 115px;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s;
        }

        /* Make the time input spinner icon white */
        .extension-time-input::-webkit-calendar-picker-indicator {
            filter: invert(1);
            cursor: pointer;
        }

        .extension-time-input::-webkit-calendar-picker-indicator:hover {
            filter: invert(1) brightness(1.2);
        }

        .extension-time-input:hover {
            border-color: rgba(0, 255, 157, 0.4);
        }

        .extension-time-input:focus {
            outline: none;
            border-color: #00ff9d;
            background: rgba(30, 30, 45, 1);
        }

        .time-separator {
            color: #aaa;
            font-size: 12px;
        }

        .extension-apply-btn {
            background: rgba(0, 255, 157, 0.15);
            border: 1px solid rgba(0, 255, 157, 0.4);
            border-radius: 4px;
            color: #00ff9d;
            font-size: 12px;
            font-weight: 500;
            padding: 6px 14px;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s, transform 0.1s;
        }

        .extension-apply-btn:hover {
            background: rgba(0, 255, 157, 0.25);
            border-color: #00ff9d;
        }

        .extension-apply-btn:active {
            transform: scale(0.96);
        }
    </style>
</head>
<body>
    <div class="header">
        <a href="index.html" class="back-link">
            <span>‚Üê</span> Back to Main
        </a>
        <div style="flex-grow: 1; text-align: center;">
            <h1 style="margin: 0; font-size: 18px;" id="header-title">Adjust Theme</h1>
            <p style="margin: 0; font-size: 13px; color: #aaa;" id="header-theme-name"></p>
        </div>
        <div></div>
    </div>

    <div id="loading" class="loading">Loading theme details...</div>
    <div id="error" class="error hidden"></div>

    <div id="content" class="container hidden">
        <!-- Left Panel: Original Video + Timeline -->
        <div class="panel">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                <h2 style="margin: 0;">Original Video</h2>
                <div style="display: flex; gap: 16px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="subtitles-toggle" checked style="width: 18px; height: 18px;">
                        <span style="font-size: 13px; color: #aaa;">Show Subtitles</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="overlay-toggle" style="width: 18px; height: 18px;">
                        <span style="font-size: 13px; color: #aaa;">Show 9:16 Crop Overlay</span>
                    </label>
                </div>
            </div>

            <div class="video-wrapper">
                <video id="original-video">
                    <track id="subtitle-track" kind="subtitles" srclang="en" label="English" default>
                </video>
                <div id="shorts-overlay" class="shorts-overlay hidden">
                    <div class="shorts-crop-area"></div>
                </div>
                <div class="buffer-info" id="buffer-info">Buffer range: 00:00:00 - 00:00:00</div>
                <div class="autosave-indicator" id="autosave-indicator"></div>

                <!-- Custom Video Controls -->
                <div class="video-controls-overlay">
                    <div class="controls-progress">
                        <input type="range" id="seekbar" class="seekbar" min="0" max="100" value="0" step="0.1">
                        <div id="theme-marker" class="theme-marker">
                            <div class="theme-marker-flag">Theme length: <span id="theme-duration-text">00:00</span></div>
                        </div>
                    </div>
                    <div class="controls-row">
                        <button id="play-pause-btn" class="control-icon">‚ñ∂</button>
                        <button id="jump-start-btn" class="control-jump" title="Jump to theme start">‚èÆ Start</button>
                        <button id="jump-end-btn" class="control-jump" title="Jump to theme end">End ‚è≠</button>
                        <span id="time-display" class="time-display">00:00 / 00:00</span>
                        <input type="range" id="volume-slider" class="volume-slider" min="0" max="1" value="1" step="0.1">
                    </div>
                </div>

                <!-- Video buffer controls inside video -->
                <div class="video-buffer-controls-left">
                    <button id="video-buffer-decrease-left" class="video-buffer-btn" title="Reduce buffer by 1 min">‚àí</button>
                    <button id="video-buffer-increase-left" class="video-buffer-btn" title="Increase buffer by 1 min">+</button>
                </div>
                <div class="video-buffer-controls-right">
                    <button id="video-buffer-decrease-right" class="video-buffer-btn" title="Reduce buffer by 1 min">‚àí</button>
                    <button id="video-buffer-increase-right" class="video-buffer-btn" title="Increase buffer by 1 min">+</button>
                </div>
            </div>

            <div class="timeline-container">
                <div class="timeline-header">
                    <span class="buffer-label" id="buffer-display">L: ¬±5min | R: ¬±5min</span>
                    <button id="reset-timeline-btn" class="reset-timeline-btn" title="Reset to original theme time range">‚Ü∫ Reset to Original</button>
                </div>
                <div class="timeline-track" id="timeline-track">
                    <div class="buffer-range" id="buffer-range">
                        <div class="theme-box" id="theme-box">
                            <div class="theme-box-handle left" id="handle-left"></div>
                            <div class="theme-box-content" id="theme-box-content">00:30 - 01:30</div>
                            <div class="theme-box-handle right" id="handle-right"></div>
                        </div>
                    </div>
                    <span class="time-start-marker-inside" id="time-start-marker">00:00</span>
                    <span class="time-end-marker-inside" id="time-end-marker">00:00</span>
                </div>
                <div class="time-markers">
                </div>
            </div>

            <!-- Manual time extension inputs -->
            <div class="time-extension-controls">
                <div class="extension-input-group">
                    <label class="extension-label">Ext Left</label>
                    <button id="apply-ext-left" class="extension-apply-btn">Apply</button>
                </div>
                <input type="time" id="ext-left-end" class="extension-time-input" step="1" min="00:00:00" max="01:00:00">
                <div class="extension-divider">|</div>
                <input type="time" id="ext-right-end" class="extension-time-input" step="1" min="00:00:00" max="01:00:00">
                <div class="extension-input-group">
                    <button id="apply-ext-right" class="extension-apply-btn">Apply</button>
                    <label class="extension-label">Ext Right</label>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <div class="info-row">
                    <span class="info-label">Theme</span>
                    <span class="info-value" id="theme-number">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Theme Name</span>
                    <span class="info-value" id="theme-name" style="color: #00ff9d; cursor: pointer;" contenteditable="true" title="Click to edit">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Start Time</span>
                    <span class="info-value" id="display-start">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">End Time</span>
                    <span class="info-value" id="display-end">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Duration</span>
                    <span class="info-value duration-value" id="display-duration">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Directory location</span>
                    <span class="info-value" id="folder-location" title="">-</span>
                </div>
            </div>
        </div>

        <!-- Right Panel: Theme Clip Preview + Subtitle Editor -->
        <div class="panel" style="position: relative;">
            <h2>Theme Clip Preview (9:16 Shorts)</h2>
            <div class="video-wrapper preview-wrapper">
                <video id="preview-video" loop playsinline>
                    <track id="preview-subtitle-track" kind="subtitles" srclang="en" label="English" default>
                </video>
                <div class="subtitle-overlay" id="subtitle-overlay">
                    <span class="subtitle-text" id="subtitle-preview-text">Preview subtitles</span>
                </div>
                <div class="autosave-indicator preview-autosave" id="preview-autosave-indicator"></div>

                <!-- Canvas for karaoke rendering (hidden by default) -->
                <canvas id="karaoke-canvas" style="display:none;"></canvas>
                <div class="buffer-info" id="canvas-mode-indicator" style="display:none;">Canvas Preview Mode</div>

                <!-- Custom controls for preview video -->
                <div class="preview-seekbar-container">
                    <div class="preview-controls-row">
                        <button id="preview-play-btn" class="preview-control-btn">‚ñ∂</button>
                        <input type="range" id="preview-seekbar" class="seekbar preview-seekbar" min="0" max="100" value="0" step="0.1">
                    </div>
                    <div class="preview-time-row">
                        <span id="preview-time-display" class="preview-time-display">00:00 / 00:00</span>
                    </div>
                </div>
            </div>

            <!-- Canvas Mode Toggle LED - positioned at top center of preview video -->
            <div id="canvas-mode-led" style="position: absolute; top: 48px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 6px 12px; border-radius: 6px; background: rgba(255,255,255,0.05); transition: all 0.2s ease; user-select: none; z-index: 10;" title="Toggle Canvas Mode">
                <div id="led-indicator" style="width: 12px; height: 12px; border-radius: 50%; background: #333; box-shadow: inset 0 1px 3px rgba(0,0,0,0.5); transition: all 0.3s ease;"></div>
                <span style="font-size: 12px; color: #aaa;">Canvas</span>
            </div>

            <div class="subtitle-editor">
                <div class="subtitle-section">
                    <h3>Subtitle Text</h3>

                    <!-- Action buttons toolbar -->
                    <div class="actions-toolbar">
                        <div class="actions-group">
                            <button id="edit-all-subs-btn" class="action-btn" title="Edit all subtitles for this theme">üìù Edit All</button>
                            <button id="lock-video-btn" class="action-btn" title="Lock video controls to enable dragging">
                                <span id="lock-icon">üîì</span> Lock
                            </button>
                        </div>
                        <div class="actions-group">
                            <button class="toolbar-btn" onclick="removeFormatting()" title="Clear all formatting">üóë Clear</button>
                        </div>
                    </div>

                    <!-- Rich text formatting toolbar -->
                    <div class="rich-text-toolbar">
                        <button class="toolbar-btn" data-style="bold" onclick="toggleStyle('bold')"><b>Bold</b></button>
                        <button class="toolbar-btn" data-style="italic" onclick="toggleStyle('italic')"><i>Italic</i></button>
                        <button class="toolbar-btn" data-style="color" onclick="applyColor('#ff0000')">üî¥</button>
                        <button class="toolbar-btn" data-style="color" onclick="applyColor('#00ff00')">üü¢</button>
                        <button class="toolbar-btn" data-style="color" onclick="applyColor('#00ffff')">üîµ</button>
                        <button class="toolbar-btn" data-style="color" onclick="applyColor('#ffff00')">üü°</button>
                        <button class="toolbar-btn" data-style="color" onclick="applyColor('#ffffff')">‚ö™</button>
                        <div class="color-picker-wrapper">
                            <input type="color" id="custom-color-picker" value="#ff00ff" title="Custom color">
                        </div>
                        <div class="toolbar-divider"></div>
                        <button class="toolbar-btn" data-style="size" onclick="applySize(1.2)">A+</button>
                        <button class="toolbar-btn" data-style="size" onclick="applySize(0.8)">a-</button>
                    </div>
                    <div class="subtitle-text-area" id="subtitle-text" contenteditable="true" data-placeholder="Edit subtitle text here..."></div>
                </div>

                <div class="subtitle-section">
                    <h3>Global Subtitle Settings</h3>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Font Family</label>
                            <select id="subtitle-font">
                                <option value="Arial">Arial</option>
                                <option value="Calibri">Calibri</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Verdana">Verdana</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Font Size (px)</label>
                            <input type="number" id="subtitle-size" value="16" min="12" max="72">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Text Color</label>
                            <input type="color" id="subtitle-color" value="#ffffff">
                        </div>
                        <div class="form-group">
                            <label>Background Color</label>
                            <input type="color" id="subtitle-bg" value="#000000">
                        </div>
                        <div class="form-group">
                            <label>Background Opacity</label>
                            <input type="range" id="subtitle-bg-opacity" min="0" max="100" value="70">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Position Mode</label>
                            <div class="position-mode-group">
                                <button class="position-mode-btn active" data-mode="global">Global</button>
                                <button class="position-mode-btn" data-mode="current">Current</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Position</label>
                            <select id="subtitle-position">
                                <option value="bottom">Bottom</option>
                                <option value="middle">Middle</option>
                                <option value="top">Top</option>
                            </select>
                        </div>
                    </div>

                    <div class="form-row" style="justify-content: center;">
                        <div class="form-group" style="flex: 0; min-width: 140px;">
                            <label style="text-align: center;">H: ‚¨Ö ‚¨å ‚û°</label>
                            <div class="align-group">
                                <button class="align-btn" data-align="left" title="Align Left">‚¨Ö</button>
                                <button class="align-btn active" data-align="center" title="Align Center">‚¨å</button>
                                <button class="align-btn" data-align="right" title="Align Right">‚û°</button>
                            </div>
                        </div>
                        <div class="form-group" style="flex: 0; min-width: 140px;">
                            <label style="text-align: center;">V: ‚¨Ü ‚¨ç ‚¨á</label>
                            <div class="align-group">
                                <button class="align-btn" data-valign="top" title="Align Top">‚¨Ü</button>
                                <button class="align-btn active" data-valign="middle" title="Align Middle">‚¨ç</button>
                                <button class="align-btn" data-valign="bottom" title="Align Bottom">‚¨á</button>
                            </div>
                        </div>
                    </div>

                    <!-- Karaoke Highlighting Section -->
                    <div class="form-row">
                        <div class="form-group" style="width: 100%;">
                            <label style="display: flex; align-items: center; gap: 12px; cursor: pointer;">
                                <input type="checkbox" id="karaoke-toggle" style="width: 18px; height: 18px;">
                                <span style="font-size: 14px; color: #fff;">üé§ Karaoke Word Highlighting</span>
                            </label>

                            <!-- Karaoke Style Controls -->
                            <div id="karaoke-style-controls" style="display: none; margin-top: 15px; padding: 15px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333;">
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">

                                    <!-- Karaoke Mode -->
                                    <div style="display: flex; flex-direction: column; gap: 5px;">
                                        <label style="font-size: 12px; color: #aaa; font-weight: 500;">Karaoke Mode</label>
                                        <select id="karaoke-mode" style="padding: 6px 8px; background: #2a2a2a; color: #fff; border: 1px solid #444; border-radius: 4px; font-size: 12px;">
                                            <option value="normal" selected>Normal (word highlights, then fades)</option>
                                            <option value="cumulative">Cumulative (words stay highlighted)</option>
                                            <option value="fill">Fill Effect (bottom to top)</option>
                                            <option value="outline">Outline Effect</option>
                                        </select>
                                    </div>

                                    <!-- Font Size Scale -->
                                    <div style="display: flex; flex-direction: column; gap: 5px;">
                                        <label style="font-size: 12px; color: #aaa; font-weight: 500;">Font Size: <span id="font-scale-value">100%</span></label>
                                        <input type="range" id="font-size-scale" min="50" max="200" value="100" style="width: 100%; height: 6px;">
                                    </div>

                                    <!-- Past Words Color (for cumulative mode) -->
                                    <div style="display: flex; align-items: center; gap: 10px; grid-column: 1 / -1;">
                                        <label style="font-size: 12px; color: #aaa; font-weight: 500; min-width: 120px;">Past Words Color:</label>
                                        <input type="color" id="past-color" value="#808080" style="width: 50px; height: 28px; cursor: pointer; border: none; border-radius: 4px;">
                                        <span style="font-size: 11px; color: #666;">(for cumulative mode)</span>
                                    </div>

                                    <!-- Divider -->
                                    <div style="grid-column: 1 / -1; height: 1px; background: #333; margin: 10px 0;"></div>

                                    <!-- Color Preset -->
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <label style="font-size: 12px; color: #aaa; font-weight: 500; min-width: 70px;">Preset:</label>
                                        <select id="highlight-preset" style="flex: 1; padding: 6px 8px; background: #2a2a2a; color: #fff; border: 1px solid #444; border-radius: 4px; font-size: 12px;">
                                            <option value="custom">Custom</option>
                                            <option value="yellow-glow" selected>Yellow Glow</option>
                                            <option value="red-bold">Red Bold</option>
                                            <option value="cyan-neon">Cyan Neon</option>
                                            <option value="green-glow">Green Glow</option>
                                            <option value="pink-soft">Pink Soft</option>
                                            <option value="orange-fire">Orange Fire</option>
                                            <option value="white-clean">White Clean</option>
                                            <option value="purple-vibe">Purple Vibe</option>
                                        </select>
                                    </div>

                                    <!-- Text Color -->
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <label style="font-size: 12px; color: #aaa; font-weight: 500; min-width: 70px;">Text Color:</label>
                                        <input type="color" id="highlight-text-color" value="#ffff00" style="width: 50px; height: 28px; cursor: pointer; border: none; border-radius: 4px;">
                                    </div>

                                    <!-- Glow Color -->
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <label style="font-size: 12px; color: #aaa; font-weight: 500; min-width: 70px;">Glow Color:</label>
                                        <input type="color" id="highlight-glow-color" value="#ffff00" style="width: 50px; height: 28px; cursor: pointer; border: none; border-radius: 4px;">
                                    </div>

                                    <!-- Glow Blur -->
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <label style="font-size: 12px; color: #aaa; font-weight: 500; min-width: 70px;">Glow Blur:</label>
                                        <input type="range" id="highlight-glow-blur" min="0" max="30" value="10" style="flex: 1; height: 6px;">
                                        <span id="highlight-glow-blur-value" style="font-size: 11px; color: #aaa; min-width: 30px;">10px</span>
                                    </div>

                                    <!-- Font Weight -->
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <label style="font-size: 12px; color: #aaa; font-weight: 500; min-width: 70px;">Font Weight:</label>
                                        <select id="highlight-font-weight" style="flex: 1; padding: 6px 8px; background: #2a2a2a; color: #fff; border: 1px solid #444; border-radius: 4px; font-size: 12px;">
                                            <option value="normal">Normal</option>
                                            <option value="bold" selected>Bold</option>
                                            <option value="100">Thin (100)</option>
                                            <option value="300">Light (300)</option>
                                            <option value="500">Medium (500)</option>
                                            <option value="700">Extra Bold (700)</option>
                                            <option value="900">Black (900)</option>
                                        </select>
                                    </div>

                                    <!-- Reset Button -->
                                    <div style="grid-column: 1 / -1; display: flex; justify-content: center; margin-top: 10px;">
                                        <button id="reset-highlight-style" style="padding: 8px 20px; background: #444; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Reset to Default</button>
                                    </div>

                                    <!-- Canvas Mode Toggle -->
                                    <div style="grid-column: 1 / -1; display: flex; justify-content: center; margin-top: 10px;">
                                        <button id="toggle-canvas-mode" style="padding: 8px 20px; background: #2196F3; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Canvas Preview: OFF</button>
                                    </div>

                                    <!-- Export Canvas Video Button -->
                                    <div style="grid-column: 1 / -1; display: flex; justify-content: center; margin-top: 10px;">
                                        <button id="export-canvas-video" style="padding: 10px 24px; background: linear-gradient(135deg, #4CAF50, #45a049); color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600;">Export Canvas Karaoke Video (ffmpeg.wasm)</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="message" style="margin-top: 16px;"></div>
        </div>
    </div>

    <!-- Subtitle Editor Modal -->
    <div id="subtitle-modal" class="modal">
        <div class="modal-content" style="max-width: 800px; max-height: 80vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <h2>Edit All Subtitles</h2>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body" style="flex: 1; overflow-y: auto;">
                <div id="subtitle-cues-container"></div>
            </div>
            <div class="modal-footer" style="padding: 16px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: flex-end; gap: 12px;">
                <button id="cancel-subs-btn" class="btn btn-secondary">Cancel</button>
                <button id="save-subs-btn" class="btn btn-primary">Save Subtitles</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let themeData = null;
        let fullVideoDuration = 0;  // Full video duration
        let bufferedDuration = 0;   // Buffered range duration (for timeline)
        let videoPath = '';
        let startSeconds = 0;
        let endSeconds = 0;
        let originalStartSeconds = 0;  // Original theme time from themes.md (for reset)
        let originalEndSeconds = 0;    // Original theme time from themes.md (for reset)
        let bufferLeftSeconds = 300; // 5 minutes buffer before theme
        let bufferRightSeconds = 300; // 5 minutes buffer after theme
        let isDragging = null;
        let dragStartX = 0;
        let dragStartValue = 0;
        let dragStartValueEnd = 0;
        let videoControlsLocked = false; // Video controls lock state

        // DOM Elements
        const originalVideo = document.getElementById('original-video');
        const previewVideo = document.getElementById('preview-video');
        const previewSeekbar = document.getElementById('preview-seekbar');
        const previewPlayBtn = document.getElementById('preview-play-btn');
        const themeBox = document.getElementById('theme-box');
        const handleLeft = document.getElementById('handle-left');
        const handleRight = document.getElementById('handle-right');
        const timelineTrack = document.getElementById('timeline-track');
        const bufferRange = document.getElementById('buffer-range');
        const themeBoxContent = document.getElementById('theme-box-content');

        // Custom video control elements
        const seekbar = document.getElementById('seekbar');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const jumpStartBtn = document.getElementById('jump-start-btn');
        const jumpEndBtn = document.getElementById('jump-end-btn');
        const timeDisplay = document.getElementById('time-display');
        const volumeSlider = document.getElementById('volume-slider');
        const themeMarker = document.getElementById('theme-marker');
        const themeDurationText = document.getElementById('theme-duration-text');

        // Parse URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const folderNumber = urlParams.get('folder');
        const themeNumber = parseInt(urlParams.get('theme'));

        // Format time
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        // Parse time string to seconds
        function parseTime(timeStr) {
            const parts = timeStr.split(':');
            if (parts.length !== 3) return 0;
            return parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseFloat(parts[2]);
        }

        // Auto-save theme adjustment
        let autoSaveTimeout = null;
        let subtitleAutoSaveTimeout = null;
        let currentCueInfo = null; // Track current cue {sequence, timestamp, start, end, text}
        let allThemeCues = []; // Cache all theme cues
        let subtitleFormatting = { bold: false, italic: false, color: null, size: null };
        let allCueFormatting = {}; // Store formatting for all cues: {sequence: {sequence, timestamp, html, _text}}
        let isProgrammaticUpdate = false; // Flag to prevent auto-save during programmatic updates
        let themeStartBeforeDrag = null; // Track theme start before drag to calculate timestamp shift
        let themeEndBeforeDrag = null; // Track theme end before drag

        // Position mode: 'global' (all subtitles) or 'current' (individual subtitle)
        let positionMode = 'global';
        let globalPosition = 'bottom'; // Default global position for all subtitles
        let karaokeEnabled = true; // Karaoke word highlighting (default: enabled)
        let wordTimestamps = null; // Word timestamps for preview karaoke effect

        // Canvas mode state
        let canvasMode = false;
        let canvasRenderer = null;

        // Update LED indicator state
        function updateCanvasLED() {
            const led = document.getElementById('led-indicator');
            const ledContainer = document.getElementById('canvas-mode-led');
            if (canvasMode) {
                // LED ON - bright green with glow
                led.style.background = '#00ff00';
                led.style.boxShadow = '0 0 10px #00ff00, 0 0 20px #00ff00, inset 0 1px 3px rgba(255,255,255,0.3)';
                ledContainer.style.background = 'rgba(0, 255, 0, 0.15)';
            } else {
                // LED OFF - dark grey
                led.style.background = '#333';
                led.style.boxShadow = 'inset 0 1px 3px rgba(0,0,0,0.5)';
                ledContainer.style.background = 'rgba(255,255,255,0.05)';
            }
        }

        // KaraokeCanvasRenderer class for canvas-based karaoke with fade-back effects
        class KaraokeCanvasRenderer {
            constructor(canvas, videoElement, wordTimestamps, settings) {
                this.canvas = canvas;
                this.video = videoElement;
                this.ctx = canvas.getContext('2d');
                this.wordTimestamps = wordTimestamps || [];
                this.settings = settings || {};
                this.fadeDuration = 0.5; // seconds to fade from highlight to original color
            }

            // Linear interpolation between two hex colors
            lerpColor(color1, color2, factor) {
                const c1 = this.hexToRgb(color1);
                const c2 = this.hexToRgb(color2);
                const r = Math.round(c1.r + (c2.r - c1.r) * factor);
                const g = Math.round(c1.g + (c2.g - c1.g) * factor);
                const b = Math.round(c1.b + (c2.b - c1.b) * factor);
                return `rgb(${r},${g},${b})`;
            }

            hexToRgb(hex) {
                // Handle #RGB and #RRGGBB formats
                if (hex.startsWith('#')) {
                    hex = hex.slice(1);
                }
                if (hex.length === 3) {
                    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                }
                const result = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : {r: 255, g: 255, b: 255};
            }

            // Get current subtitle text for given time
            getCurrentSubtitleText(currentTime) {
                const textEl = document.getElementById('subtitle-preview-text');
                return textEl?.textContent?.trim() || '';
            }

            // Find word timestamp by word text and index
            findWordTimestamp(word, wordIndex) {
                if (!this.wordTimestamps || this.wordTimestamps.length === 0) {
                    return null;
                }

                // Clean the word for comparison
                const cleanWord = word.toLowerCase().replace(/[.,!?;:"'\s]/g, '');

                // Try exact match first
                for (const wt of this.wordTimestamps) {
                    const cleanWt = (wt.word || '').toLowerCase().replace(/[.,!?;:"'\s]/g, '');
                    if (cleanWt === cleanWord) {
                        return wt;
                    }
                }

                // Try index-based match as fallback
                if (wordIndex < this.wordTimestamps.length) {
                    return this.wordTimestamps[wordIndex];
                }

                return null;
            }

            // Render a single frame at the given time
            renderFrame(currentTime, subtitleText) {
                const ctx = this.ctx;
                const canvas = this.canvas;

                // Debug: log what we're rendering
                if (Math.random() < 0.05) { // Only log occasionally to avoid spam
                    console.log('[Canvas renderFrame]', { currentTime, subtitleText, canvasSize: `${canvas.width}x${canvas.height}` });
                }

                // Draw video frame first (if video element is available and ready)
                if (this.video && this.video.readyState >= 2) {
                    // Calculate scaling to maintain aspect ratio and cover the canvas
                    const videoRatio = this.video.videoWidth / this.video.videoHeight;
                    const canvasRatio = canvas.width / canvas.height;

                    let drawWidth, drawHeight, startX, startY;

                    if (videoRatio > canvasRatio) {
                        // Video is wider - use height as reference
                        drawHeight = canvas.height;
                        drawWidth = drawHeight * videoRatio;
                        startX = (canvas.width - drawWidth) / 2;
                        startY = 0;
                    } else {
                        // Video is taller - use width as reference
                        drawWidth = canvas.width;
                        drawHeight = drawWidth / videoRatio;
                        startX = 0;
                        startY = (canvas.height - drawHeight) / 2;
                    }

                    ctx.drawImage(this.video, startX, startY, drawWidth, drawHeight);
                } else {
                    // Fallback to black background if video not available
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                if (!subtitleText) {
                    return;
                }

                // Get settings
                const fontSize = this.settings.fontSize || 48;
                const fontFamily = this.settings.font_name || 'Arial';
                const highlightColor = this.settings.textColor || '#ffff00';
                const pastColor = this.settings.past_color || '#808080';
                const mode = this.settings.mode || 'normal';
                const fontWeight = this.settings.font_weight || 'bold';

                // Set font
                ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';

                // Calculate position (bottom center with margin)
                const margin = 100;
                const maxWidth = canvas.width - 80; // 40px padding on each side

                // Get words from subtitle text
                const words = subtitleText.split(/\s+/).filter(w => w.length > 0);

                if (words.length === 0) {
                    return;
                }

                // Word wrapping - break into lines
                const lines = [];
                let currentLine = [];
                let lineWidth = 0;
                const spaceWidth = ctx.measureText(' ').width;

                for (const word of words) {
                    const wordWidth = ctx.measureText(word).width;
                    const testWidth = currentLine.length > 0 ? lineWidth + spaceWidth + wordWidth : wordWidth;

                    if (testWidth <= maxWidth) {
                        // Word fits on current line
                        currentLine.push(word);
                        lineWidth = testWidth;
                    } else {
                        // Word doesn't fit - start new line
                        if (currentLine.length > 0) {
                            lines.push(currentLine);
                        }
                        currentLine = [word];
                        lineWidth = wordWidth;
                    }
                }

                // Add last line
                if (currentLine.length > 0) {
                    lines.push(currentLine);
                }

                // Calculate total height for all lines
                const lineHeight = fontSize * 1.2; // 20% line spacing
                const totalHeight = lines.length * lineHeight;
                const startY = canvas.height - margin - (lines.length - 1) * lineHeight;

                // Render each line
                for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                    const line = lines[lineIndex];
                    const lineY = startY + lineIndex * lineHeight;
                    const lineX = canvas.width / 2;

                    // Calculate word positions for this line
                    let lineTextWidth = 0;
                    const wordWidths = [];
                    for (const word of line) {
                        const width = ctx.measureText(word).width;
                        wordWidths.push(width);
                        lineTextWidth += width;
                    }
                    lineTextWidth += spaceWidth * (line.length - 1);

                    let xPos = lineX - lineTextWidth / 2;

                    // Render each word in this line
                    for (let wordIndex = 0; wordIndex < line.length; wordIndex++) {
                        const word = line[wordIndex];
                        const wordWidth = wordWidths[wordIndex];
                        let color = '#ffffff'; // Default white

                        // Find timestamp for this word (using global word index)
                        const globalWordIndex = words.indexOf(word);
                        const wordTimestamp = this.findWordTimestamp(word, globalWordIndex);

                        if (wordTimestamp) {
                            const wordStart = wordTimestamp.start || 0;
                            const wordEnd = wordTimestamp.end || 0;

                            if (currentTime >= wordStart && currentTime <= wordEnd) {
                                // Currently being spoken - highlight
                                color = highlightColor;
                            } else if (currentTime > wordEnd) {
                                // Word was spoken
                                if (mode === 'normal') {
                                    // Fade back to white
                                    const timeSinceEnd = currentTime - wordEnd;
                                    const fadeProgress = Math.min(timeSinceEnd / this.fadeDuration, 1);
                                    color = this.lerpColor(highlightColor, '#ffffff', fadeProgress);
                                } else if (mode === 'cumulative') {
                                    // Stay gray/past color
                                    color = pastColor;
                                }
                            }
                        }

                        // Draw the word
                        ctx.fillStyle = color;
                        ctx.fillText(word, xPos + wordWidth / 2, lineY);
                        xPos += wordWidth + spaceWidth;
                    }
                }
            }

            // Render a frame using the highlighted word index from the DOM (matches original system exactly)
            renderFrameWithHighlight(currentTime, subtitleText, highlightedWordIndex) {
                const ctx = this.ctx;
                const canvas = this.canvas;

                // Debug: log what we're rendering EVERY TIME to track changes
                console.log('[Canvas Render] highlightedWordIndex:', highlightedWordIndex, 'subtitleText:', subtitleText?.substring(0, 30));

                // Clear canvas to transparent first
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (!subtitleText) {
                    return;
                }

                // Get settings
                const fontSize = this.settings.fontSize || 48;
                const fontFamily = this.settings.font_name || 'Arial';
                const highlightColor = this.settings.textColor || '#ffff00';
                const pastColor = this.settings.past_color || '#808080';
                const mode = this.settings.mode || 'normal';
                const fontWeight = this.settings.font_weight || 'bold';

                // Set font
                ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';

                // Calculate position (bottom center with margin)
                const margin = 100;
                const maxWidth = canvas.width - 80; // 40px padding on each side

                // Get words from subtitle text
                const words = subtitleText.split(/\s+/).filter(w => w.length > 0);

                if (words.length === 0) {
                    return;
                }

                // Word wrapping - break into lines
                const lines = [];
                let currentLine = [];
                let lineWidth = 0;
                const spaceWidth = ctx.measureText(' ').width;

                for (const word of words) {
                    const wordWidth = ctx.measureText(word).width;
                    const testWidth = currentLine.length > 0 ? lineWidth + spaceWidth + wordWidth : wordWidth;

                    if (testWidth <= maxWidth) {
                        // Word fits on current line
                        currentLine.push(word);
                        lineWidth = testWidth;
                    } else {
                        // Word doesn't fit - start new line
                        if (currentLine.length > 0) {
                            lines.push(currentLine);
                        }
                        currentLine = [word];
                        lineWidth = wordWidth;
                    }
                }

                // Add last line
                if (currentLine.length > 0) {
                    lines.push(currentLine);
                }

                // Calculate total height for all lines
                const lineHeight = fontSize * 1.2; // 20% line spacing
                const totalHeight = lines.length * lineHeight;
                const startY = canvas.height - margin - (lines.length - 1) * lineHeight;

                // Render each line
                let globalWordIndex = 0; // Track word index across all lines
                for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                    const line = lines[lineIndex];
                    const lineY = startY + lineIndex * lineHeight;
                    const lineX = canvas.width / 2;

                    // Calculate word positions for this line
                    let lineTextWidth = 0;
                    const wordWidths = [];
                    for (const word of line) {
                        const width = ctx.measureText(word).width;
                        wordWidths.push(width);
                        lineTextWidth += width;
                    }
                    lineTextWidth += spaceWidth * (line.length - 1);

                    let xPos = lineX - lineTextWidth / 2;

                    // Render each word in this line
                    for (let wordIndex = 0; wordIndex < line.length; wordIndex++) {
                        const word = line[wordIndex];
                        const wordWidth = wordWidths[wordIndex];
                        let color = '#ffffff'; // Default white

                        // Use the highlighted word index from DOM to determine color
                        if (globalWordIndex < highlightedWordIndex) {
                            // Word was already spoken
                            if (mode === 'cumulative') {
                                color = pastColor;
                            } else {
                                // Normal mode - white
                                color = '#ffffff';
                            }
                        } else if (globalWordIndex === highlightedWordIndex) {
                            // Currently being spoken - highlight
                            color = highlightColor;
                        }

                        // Draw the word
                        ctx.fillStyle = color;
                        ctx.fillText(word, xPos + wordWidth / 2, lineY);
                        xPos += wordWidth + spaceWidth;
                        globalWordIndex++;
                    }
                }
            }
        }

        // Custom position and alignment
        let customPosition = null; // {left: number, top: number, width: number}
        let horizontalAlign = 'center'; // 'left', 'center', 'right'
        let verticalAlign = 'middle'; // 'top', 'middle', 'bottom'

        function autoSaveTheme() {
            // Clear existing timeout
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }

            // Show saving indicator
            const indicator = document.getElementById('autosave-indicator');
            indicator.textContent = '‚è≥ Saving...';
            indicator.classList.add('show', 'saving');

            // Debounce save to avoid too many requests
            autoSaveTimeout = setTimeout(async () => {
                try {
                    const updates = {
                        folder: folderNumber,
                        theme: themeNumber,
                        title: document.getElementById('theme-name').textContent,
                        start: formatTime(startSeconds),
                        end: formatTime(endSeconds)
                    };

                    const response = await fetch('/api/update-theme', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(updates)
                    });

                    if (!response.ok) throw new Error('Failed to auto-save');

                    indicator.textContent = '‚úì Saved';
                    indicator.classList.remove('saving');

                    // Hide after 2 seconds
                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                } catch (error) {
                    indicator.textContent = '‚úó Save failed';
                    indicator.classList.remove('saving');
                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                }
            }, 500); // Wait 500ms after drag ends before saving
        }

        // Helper function to convert seconds to time input format (HH:MM:SS)
        function secondsToTimeInput(totalSeconds) {
            console.log('   secondsToTimeInput called with:', totalSeconds, 'type:', typeof totalSeconds);

            // Handle invalid values
            if (totalSeconds === null || totalSeconds === undefined || isNaN(totalSeconds)) {
                console.warn('   ‚ö†Ô∏è Invalid value, returning 00:00:00');
                return '00:00:00';
            }

            // Ensure we have a number
            totalSeconds = Number(totalSeconds);

            // Round to nearest whole second for time input display
            totalSeconds = Math.round(totalSeconds);

            const h = Math.floor(totalSeconds / 3600);
            const m = Math.floor((totalSeconds % 3600) / 60);
            const s = totalSeconds % 60;

            const result = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            console.log(`   ‚Üí ${result} (h:${h}, m:${m}, s:${s})`);
            return result;
        }

        // Helper function to update time extension inputs
        function updateTimeExtensionInputs() {
            console.log('üïê updateTimeExtensionInputs called');

            const extLeftEnd = document.getElementById('ext-left-end');
            const extRightEnd = document.getElementById('ext-right-end');

            console.log(`   Elements found: extLeftEnd=${!!extLeftEnd}, extRightEnd=${!!extRightEnd}`);
            console.log(`   Values: originalStartSeconds=${originalStartSeconds}, startSeconds=${startSeconds}`);
            console.log(`   Values: originalEndSeconds=${originalEndSeconds}, endSeconds=${endSeconds}`);

            if (extLeftEnd && extRightEnd &&
                originalStartSeconds !== null && originalStartSeconds !== undefined &&
                originalEndSeconds !== null && originalEndSeconds !== undefined &&
                startSeconds !== null && startSeconds !== undefined &&
                endSeconds !== null && endSeconds !== undefined) {

                const leftExtension = Math.max(0, originalStartSeconds - startSeconds);
                const rightExtension = Math.max(0, endSeconds - originalEndSeconds);

                console.log(`   Calculated: leftExtension=${leftExtension}s, rightExtension=${rightExtension}s`);

                extLeftEnd.value = secondsToTimeInput(leftExtension);
                extRightEnd.value = secondsToTimeInput(rightExtension);

                console.log(`   ‚úÖ Updated: extLeftEnd.value=${extLeftEnd.value}, extRightEnd.value=${extRightEnd.value}`);
            } else {
                console.warn('   ‚ö†Ô∏è Cannot update - missing elements or values');
            }
        }

        // ============================================
        // Position Mode Functions (Global vs Current)
        // ============================================

        // Switch position mode (global or current)
        function setPositionMode(mode) {
            console.log('üìç Setting position mode:', mode);
            positionMode = mode;

            // Update button UI
            const buttons = document.querySelectorAll('.position-mode-btn');
            buttons.forEach(btn => {
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Update position dropdown to match current value for the mode
            const positionSelect = document.getElementById('subtitle-position');
            if (mode === 'global') {
                // Show global position
                positionSelect.value = globalPosition;
                console.log('   ‚Üí Switched to global mode, position =', globalPosition);
            } else {
                // Show current cue's individual position (if exists)
                if (currentCueInfo && currentCueInfo.sequence) {
                    const formatting = allCueFormatting[currentCueInfo.sequence];
                    if (formatting && formatting.position) {
                        positionSelect.value = formatting.position;
                        console.log('   ‚Üí Switched to current mode, position =', formatting.position);
                    } else {
                        // No individual position set, use global
                        positionSelect.value = globalPosition;
                        console.log('   ‚Üí Switched to current mode, using global =', globalPosition);
                    }
                } else {
                    positionSelect.value = globalPosition;
                    console.log('   ‚Üí Switched to current mode, no cue, using global =', globalPosition);
                }
            }

            updateSubtitlePreview();
        }

        // Save global position to server
        async function saveGlobalPosition(position) {
            console.log('üíæ Saving global position:', position);
            console.log('   folder:', folderNumber, 'theme:', themeNumber);

            // Get preview video element to calculate scale factor
            const previewVideo = document.getElementById('preview-video');
            const previewHeight = previewVideo.offsetHeight || 500;  // Default to 500px if not available
            const previewWidth = previewVideo.offsetWidth || 281;   // Default ~281px for 9:16

            // Target output resolution
            const targetWidth = 1080;
            const targetHeight = 1920;

            // Calculate scale factors
            const scaleX = targetWidth / previewWidth;
            const scaleY = targetHeight / previewHeight;

            console.log('   Scale factors:', { scaleX: scaleX.toFixed(3), scaleY: scaleY.toFixed(3) });
            console.log('   Preview size:', { width: previewWidth, height: previewHeight });

            // Calculate correct X position based on alignment
            // ASS with center alignment uses center point, not left edge
            let leftToSave = null;
            let topToSave = null;
            if (customPosition) {
                // Scale coordinates from preview to output resolution
                if (horizontalAlign === 'center') {
                    // For center alignment, save the center point (scaled)
                    leftToSave = Math.round(customPosition.centerX * scaleX);
                } else if (horizontalAlign === 'right') {
                    // For right alignment, save the right edge (scaled)
                    leftToSave = Math.round((customPosition.left + customPosition.width) * scaleX);
                } else {
                    // For left alignment, save the left edge (scaled)
                    leftToSave = Math.round(customPosition.left * scaleX);
                }
                // Scale Y coordinate
                topToSave = Math.round(customPosition.top * scaleY);

                console.log('   Position calculation:', {
                    previewLeft: customPosition.left,
                    previewTop: customPosition.top,
                    previewCenter: customPosition.centerX,
                    scaledLeft: leftToSave,
                    scaledTop: topToSave,
                    align: horizontalAlign
                });
            }

            try {
                const response = await fetch('/api/save-global-position', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        position: position,
                        // Include scaled custom coordinates
                        left: leftToSave,
                        top: topToSave,
                        h_align: horizontalAlign,
                        v_align: verticalAlign
                    })
                });

                console.log('   Response status:', response.status);

                if (!response.ok) {
                    console.error('‚ùå Failed to save global position, status:', response.status);
                    const errorText = await response.text();
                    console.error('   Error:', errorText);
                    return false;
                }

                const result = await response.json();
                console.log('   Server response:', result);

                globalPosition = position;
                console.log('   ‚úÖ Global position saved:', globalPosition);
                return true;
            } catch (error) {
                console.error('‚ùå Error saving global position:', error);
                return false;
            }
        }

        // Load global position from server
        async function loadGlobalPosition() {
            console.log('üîÑ Loading global position...');

            try {
                const response = await fetch(`/api/get-global-position?folder=${folderNumber}&theme=${themeNumber}`);

                if (!response.ok) {
                    console.warn('   ‚ö†Ô∏è No global position found, using default');
                    globalPosition = 'bottom';
                    customPosition = null;
                    return 'bottom';
                }

                const data = await response.json();
                globalPosition = data.position || 'bottom';
                console.log('   ‚úÖ Global position loaded:', globalPosition, data);

                // Check if it's a custom position with coordinates
                if (data.position === 'custom' && data.left !== null && data.top !== null) {
                    const hAlign = data.h_align || 'center';

                    // Get preview video element to calculate scale factor
                    const previewVideo = document.getElementById('preview-video');
                    const previewHeight = previewVideo?.offsetHeight || 500;
                    const previewWidth = previewVideo?.offsetWidth || 281;

                    // Target output resolution
                    const targetWidth = 1080;
                    const targetHeight = 1920;

                    // Calculate scale factors (output -> preview)
                    const scaleX = previewWidth / targetWidth;
                    const scaleY = previewHeight / targetHeight;

                    console.log('   Loading with scale factors:', { scaleX: scaleX.toFixed(3), scaleY: scaleY.toFixed(3) });

                    // Scale coordinates from output resolution to preview resolution
                    const scaledLeft = data.left * scaleX;
                    const scaledTop = data.top * scaleY;

                    // Convert saved position back to preview coordinates
                    let leftEdge;
                    if (hAlign === 'center') {
                        // Saved value is center point - use directly with transform
                        leftEdge = scaledLeft;
                    } else if (hAlign === 'right') {
                        // Saved value is right edge - estimate left edge
                        leftEdge = scaledLeft - 200; // Will be adjusted by preview positioning
                    } else {
                        // Saved value is left edge - use directly
                        leftEdge = scaledLeft;
                    }

                    customPosition = {
                        left: leftEdge,
                        top: scaledTop,
                        centerX: hAlign === 'center' ? scaledLeft : null,
                        width: null
                    };
                    horizontalAlign = hAlign;
                    verticalAlign = data.v_align || 'middle';
                    hasManualPosition = true;  // Mark as having manual position since we loaded custom coordinates

                    // Update align buttons to match loaded values
                    updateAlignButtons(horizontalAlign, verticalAlign);

                    console.log('   ‚úÖ Custom coordinates loaded (scaled for preview):', customPosition, 'align:', hAlign);
                    console.log('      Original from server:', { left: data.left, top: data.top });
                } else {
                    customPosition = null;
                }

                // Update dropdown to match global position
                const positionSelect = document.getElementById('subtitle-position');
                if (positionSelect && positionMode === 'global') {
                    positionSelect.value = globalPosition === 'custom' ? 'bottom' : globalPosition;
                }

                return globalPosition;
            } catch (error) {
                console.warn('   ‚ö†Ô∏è Error loading global position:', error);
                globalPosition = 'bottom';
                customPosition = null;
                return 'bottom';
            }
        }

        // Handle position dropdown change based on current mode
        async function handlePositionChange(newPosition) {
            console.log('üìç Position changed to:', newPosition, 'mode:', positionMode);

            // Clear custom position when preset is selected
            customPosition = null;
            hasManualPosition = false;

            if (positionMode === 'global') {
                // Save to global (adjust.md)
                await saveGlobalPosition(newPosition);
            } else {
                // Save to current cue (JSON)
                updateSubtitlePreview();
                await saveCurrentCueFormatting();
            }
        }

        // Load all theme cues for editing
        async function loadThemeCues() {
            try {
                console.log('üîÑ Loading all theme cues from original SRT...');

                // Load ALL cues from original SRT (not filtered by theme range)
                // This allows styling subtitles in expanded timeline areas
                // Add cache-buster to ensure we get fresh response
                const cacheBuster = Date.now();
                const response = await fetch(`/api/all-subtitles/${folderNumber}?_=${cacheBuster}`);

                console.log(`   Response status: ${response.status} ${response.statusText}`);

                if (!response.ok) {
                    console.warn('‚ùå Failed to load all subtitles, falling back to theme-filtered');
                    // Fallback to theme-filtered API
                    const fallbackResponse = await fetch(`/api/theme-subtitles/${folderNumber}/${themeNumber}`);
                    if (!fallbackResponse.ok) return [];
                    const data = await fallbackResponse.json();
                    allThemeCues = data.cues;
                    console.log(`   ‚úì Fallback: loaded ${allThemeCues.length} theme-filtered cues`);
                    return allThemeCues;
                }

                const data = await response.json();
                allThemeCues = data.cues;
                console.log(`‚úì Loaded ${allThemeCues.length} cues from original SRT`);
                return allThemeCues;
            } catch (error) {
                console.error('‚ùå Failed to load theme cues:', error);
                return [];
            }
        }

        // Load subtitle formatting metadata
        async function loadSubtitleFormatting() {
            try {
// console.log('üìÇ Loading subtitle formatting...');
                const response = await fetch(`/api/subtitle-formatting/${folderNumber}/${themeNumber}`);
                if (!response.ok) return;

                const data = await response.json();
                allCueFormatting = data.formatting || {};

                // Helper to parse timestamp to seconds
                const vttToSeconds = (ts) => {
                    const [time, millis] = ts.split('.');
                    const isNeg = time.startsWith('-');
                    const [h, m, s] = time.replace('-', '').split(':').map(Number);
                    const result = h * 3600 + m * 60 + s + (millis || 0) / 1000;
                    return isNeg ? -result : result;
                };

                // Helper to convert seconds to timestamp (supports negative values)
                const secondsToVtt = (totalSeconds) => {
                    const EPSILON = 0.001;
                    if (Math.abs(totalSeconds) < EPSILON) {
                        totalSeconds = 0;
                    }

                    const isNegative = totalSeconds < 0;
                    const absSeconds = Math.abs(totalSeconds);

                    let h = Math.floor(absSeconds / 3600);
                    let m = Math.floor((absSeconds % 3600) / 60);
                    let s = absSeconds % 60;
                    let sInt = Math.floor(s);
                    let msInt = Math.round((s - sInt) * 1000);

                    if (msInt >= 1000) {
                        msInt = 0;
                        sInt += 1;
                        if (sInt >= 60) {
                            sInt = 0;
                            m += 1;
                            if (m >= 60) {
                                m = 0;
                                h += 1;
                            }
                        }
                    }

                    const sign = isNegative ? '-' : '';
                    return `${sign}${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${sInt.toString().padStart(2, '0')}.${msInt.toString().padStart(3, '0')}`;
                };

                // CRITICAL FIX: Convert absolute timestamps to relative timestamps
                // If the JSON has entries with absolute VTT times (e.g., "00:00:10.000")
                // convert them to relative times (e.g., "00:00:00.000") by subtracting themeStart
                if (startSeconds !== null && startSeconds !== undefined && Object.keys(allCueFormatting).length > 0) {
                    const absoluteKeysToRemove = [];
                    const newEntries = {};

                    for (const [timestamp, formatting] of Object.entries(allCueFormatting)) {
                        const timestampSeconds = vttToSeconds(timestamp);

                        // Check if this looks like an absolute timestamp (>= theme start)
                        // Absolute timestamps are typically large (e.g., 10s = theme start, 26s = later in video)
                        // Relative timestamps should be small (e.g., 0s, 0.754s, etc.)
                        if (timestampSeconds >= startSeconds - 0.5) { // Allow 0.5s tolerance
                            // This looks like an absolute timestamp, convert to relative
                            const relativeSeconds = timestampSeconds - startSeconds;
                            const relativeTimestamp = secondsToVtt(relativeSeconds);

                            // Check if a relative version already exists
                            if (allCueFormatting[relativeTimestamp]) {
                                // Relative version exists, keep it and remove absolute
                                absoluteKeysToRemove.push(timestamp);
                            } else {
                                // No relative version exists, move the formatting
                                newEntries[relativeTimestamp] = formatting;
                                absoluteKeysToRemove.push(timestamp);
                            }
                        }
                    }

                    // Remove absolute timestamp entries
                    for (const key of absoluteKeysToRemove) {
                        delete allCueFormatting[key];
                    }

                    // Add converted entries
                    Object.assign(allCueFormatting, newEntries);

                    if (absoluteKeysToRemove.length > 0) {
                        // Save the corrected version
                        fetch('/api/save-subtitle-formatting', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder: folderNumber,
                                theme: themeNumber,
                                formatting: allCueFormatting
                            })
                        }).then(() => {}); // console.log('   ‚úì Saved corrected formatting')
                    }
                }

                // Clean up duplicate entries (caused by Math.max(0, ...) bug fix)
                // Remove entries like "00:00:00.000" if "-00:00:00.001" exists (same subtitle)
                const keysToRemove = [];
                const keys = Object.keys(allCueFormatting);

                // Find duplicates: positive and negative versions of ~same time
                for (const key of keys) {
                    if (key.startsWith('-')) {
                        const absSeconds = Math.abs(vttToSeconds(key));
                        // Check if there's a corresponding positive key
                        for (const otherKey of keys) {
                            if (!otherKey.startsWith('-')) {
                                const otherSeconds = vttToSeconds(otherKey);
                                // If positive key is within 1 second of absolute negative key
                                if (Math.abs(otherSeconds - absSeconds) < 0.01) {
                                    // Mark positive key for removal (keep negative version)
                                    if (!keysToRemove.includes(otherKey)) {
                                        keysToRemove.push(otherKey);
// console.log(`   üßπ Removing duplicate: ${otherKey} (kept: ${key})`);
                                    }
                                }
                            }
                        }
                    }
                }

                // Remove duplicates
                for (const key of keysToRemove) {
                    delete allCueFormatting[key];
                }

                if (keysToRemove.length > 0) {
// console.log(`   üßπ Cleaned up ${keysToRemove.length} duplicate entries`);
                    // Save cleaned up version
                    fetch('/api/save-subtitle-formatting', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            folder: folderNumber,
                            theme: themeNumber,
                            formatting: allCueFormatting
                        })
                    }).then(() => {}); // console.log('   ‚úì Saved cleaned formatting')
                }

                // MIGRATION: Detect old format (timestamp_hash keys) and migrate to sequence keys
                // Old format keys contain ':' or '_' (e.g., "00:00:00.000_364d")
                // New format keys are simple numbers (e.g., "1", "2", "3")
                const formattingKeys = Object.keys(allCueFormatting);
                const hasOldFormatKeys = formattingKeys.some(key => key.includes(':') || key.includes('_'));

                if (hasOldFormatKeys && formattingKeys.length > 0) {
                    console.log('üîÑ Detected old format keys, migrating to sequence numbers...');

                    // Ensure allThemeCues is loaded
                    if (allThemeCues.length === 0) {
                        await loadThemeCues();
                    }

                    // Helper to extract timestamp from old key (handle both "timestamp" and "timestamp_hash")
                    const extractTimestamp = (key) => {
                        if (key.includes('_')) {
                            return key.split('_')[0]; // "00:00:00.000_364d" ‚Üí "00:00:00.000"
                        }
                        return key; // Already just timestamp
                    };

                    // Create new formatting with sequence keys
                    const newFormatting = {};
                    let migratedCount = 0;

                    for (const [oldKey, formatting] of Object.entries(allCueFormatting)) {
                        const timestamp = extractTimestamp(oldKey);

                        // Find matching cue by timestamp and text
                        const matchingCue = allThemeCues.find(cue => {
                            // Match by timestamp and optionally by text if available
                            const timestampMatch = cue.start === timestamp;
                            const textMatch = !formatting._text || cue.text === formatting._text;
                            return timestampMatch && textMatch;
                        });

                        if (matchingCue && matchingCue.sequence) {
                            // Migrate to new format with sequence key
                            newFormatting[matchingCue.sequence] = {
                                sequence: matchingCue.sequence,
                                timestamp: timestamp,
                                html: formatting.html,
                                _text: formatting._text || matchingCue.text
                            };
                            migratedCount++;
                            console.log(`   ‚úì Migrated "${oldKey}" ‚Üí sequence "${matchingCue.sequence}"`);
                        } else {
                            // Couldn't find match, keep old entry (will be cleaned up later)
                            console.log(`   ‚ö†Ô∏è Could not find match for "${oldKey}", keeping as-is`);
                            newFormatting[oldKey] = formatting;
                        }
                    }

                    // Update allCueFormatting with migrated data
                    allCueFormatting = newFormatting;

                    // Save migrated format to server
                    if (migratedCount > 0) {
                        console.log(`   ‚úÖ Migrated ${migratedCount} entries to sequence keys`);
                        fetch('/api/save-subtitle-formatting', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder: folderNumber,
                                theme: themeNumber,
                                formatting: allCueFormatting
                            })
                        }).then(() => {
                            console.log('   üíæ Saved migrated formatting to server');
                        }).catch(err => {
                            console.error('   ‚úó Failed to save migrated formatting:', err);
                        });
                    }
                }

                // Convert <font> tags to <span style="..."> for better CSS compatibility
                const fontSizeMap = { '1': 0.6, '2': 0.8, '3': 1.0, '4': 1.2, '5': 1.4, '6': 1.6, '7': 1.8 };

                const convertFontTags = (html) => {
                    // Pattern: <font color="#..." size="X">text</font>
                    return html.replace(/<font\s+([^>]+)>/gi, (match, attributes) => {
                        let color = '';
                        let size = '';

                        // Extract color attribute
                        const colorMatch = attributes.match(/color="([^"]+)"/);
                        if (colorMatch) {
                            color = `color: ${colorMatch[1]}; `;
                        }

                        // Extract size attribute and convert to em
                        const sizeMatch = attributes.match(/size="([^"]+)"/);
                        if (sizeMatch) {
                            const sizeValue = sizeMatch[1];
                            const emValue = fontSizeMap[sizeValue] || 1.0;
                            size = `font-size: ${emValue}em; `;
                        }

                        return `<span style="${color}${size}">`;
                    }).replace(/<\/font>/gi, '</span>');
                };

                for (const cueStart in allCueFormatting) {
                    const cueData = allCueFormatting[cueStart];
                    if (cueData.html) {
                        const originalHtml = cueData.html;
                        cueData.html = convertFontTags(cueData.html);
                        if (originalHtml !== cueData.html) {
                            // console.log("   Converted:", originalHtml, ‚Üí, cueData.html);', originalHtml, '‚Üí', cueData.html);
                        }
                    }
                }

// console.log('üìù Loaded formatting for', Object.keys(allCueFormatting).length, 'cues:', Object.keys(allCueFormatting));

                // Don't apply formatting here - let the cuechange handler apply it
                // when each cue becomes active (avoids applying wrong cue's formatting)
            } catch (error) {
// console.error('Failed to load subtitle formatting:', error);
            }
        }

        // Auto-save subtitle edit
        function autoSaveSubtitle() {
            if (subtitleAutoSaveTimeout) {
                clearTimeout(subtitleAutoSaveTimeout);
            }

            subtitleAutoSaveTimeout = setTimeout(async () => {
                try {
                    const textarea = document.getElementById('subtitle-text');
                    const newText = textarea.innerText.trim();

                    // Don't save if there's no text or no current cue
                    if (!newText) {
                        return;
                    }

                    // Show saving indicator
                    const indicator = document.getElementById('preview-autosave-indicator');
                    indicator.textContent = '‚è≥ Saving...';
                    indicator.classList.add('show', 'saving');

                    // If we have currentCueInfo, update that specific cue
                    if (currentCueInfo) {
                        // Find and update the current cue
                        const cueIndex = allThemeCues.findIndex(cue =>
                            cue.start === currentCueInfo.start && cue.end === currentCueInfo.end
                        );

                        if (cueIndex !== -1) {
                            allThemeCues[cueIndex].text = newText;
                        }
                    }

                    // Note: Cue text edits are kept in memory only (allThemeCues)
                    // The shorts_creator will create its own trimmed SRT from original source

                    // Reload the subtitle track to show changes
                    if (previewVideo) {
                        // Remove ALL existing tracks
                        const existingTracks = previewVideo.querySelectorAll('track');
                        existingTracks.forEach(track => track.remove());

                        // Clear the textTracks list
                        while (previewVideo.textTracks.length > 0) {
                            previewVideo.textTracks[0].mode = 'disabled';
                        }

                        // Create new track
                        const newTrack = document.createElement('track');
                        newTrack.id = 'preview-subtitle-track';
                        newTrack.kind = 'subtitles';
                        newTrack.srclang = 'en';
                        newTrack.label = 'English';
                        newTrack.default = false;
                        newTrack.src = `/api/subtitles/${folderNumber}/${themeNumber}.vtt?start=${startSeconds}&end=${endSeconds}&t=${Date.now()}`;

                        // Add to DOM
                        previewVideo.appendChild(newTrack);

                        // Keep mode as 'showing' so cues are loaded and accessible
                        setTimeout(() => {
                            if (previewVideo.textTracks.length > 0) {
                                const textTrack = previewVideo.textTracks[0];
                                if (textTrack) {
                                    textTrack.mode = 'showing';
                                }
                            }
                        }, 100);
                    }

                    indicator.textContent = '‚úì Saved';
                    indicator.classList.remove('saving');

                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                } catch (error) {
                    const indicator = document.getElementById('preview-autosave-indicator');
                    indicator.textContent = '‚úó Save failed';
                    indicator.classList.remove('saving');
                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                }
            }, 800); // Wait 800ms after typing stops
        }

        // Load theme details
        async function loadTheme() {
            try {
                const response = await fetch(`/api/folder/${folderNumber}/themes`);
                if (!response.ok) throw new Error('Failed to load theme');

                const data = await response.json();
                themeData = data.themes.find(t => t.number === themeNumber);

                if (!themeData) throw new Error('Theme not found');

                // Store ORIGINAL values from themes.md (for reset button)
                originalStartSeconds = parseTime(themeData.start);
                originalEndSeconds = parseTime(themeData.end);

                // Use ADJUSTED values for display if they exist, otherwise use original
                if (themeData.adjusted_start && themeData.adjusted_end) {
                    startSeconds = parseTime(themeData.adjusted_start);
                    endSeconds = parseTime(themeData.adjusted_end);
                } else {
                    startSeconds = originalStartSeconds;
                    endSeconds = originalEndSeconds;
                }

                // Use adjusted title if available
                const displayTitle = themeData.adjusted_title || themeData.title || '';

                // Construct video path from folder and actual video filename
                if (data.video_filename) {
                    videoPath = `videos/${data.folder}/${encodeURIComponent(data.video_filename)}`;
                } else {
                    // Fallback: try to construct from title (old behavior)
                    videoPath = `videos/${data.folder}/${encodeURIComponent(data.title)}.mp4`;
                }

                // Update info display
                document.getElementById('theme-number').textContent = `Theme ${themeData.number}`;
                document.getElementById('theme-name').textContent = displayTitle;
                const fullPath = `videos/${data.folder}`;
                const folderLocationEl = document.getElementById('folder-location');
                folderLocationEl.textContent = fullPath;
                folderLocationEl.title = fullPath;

                // Update header with theme info
                document.getElementById('header-title').textContent = `Adjust Theme ${themeData.number}`;
                document.getElementById('header-theme-name').textContent = displayTitle;

                document.getElementById('subtitle-text').innerHTML = themeData.text || '';

                // Load all theme cues for subtitle editing (must be awaited for sequence matching)
                await loadThemeCues();

                // Load subtitle formatting metadata and apply to editor
                await loadSubtitleFormatting();

                // Load global position from adjust.md
                await loadGlobalPosition();

                // Load VTT subtitles
                const subtitleTrack = document.getElementById('subtitle-track');
                subtitleTrack.src = `/api/subtitles/${folderNumber}.vtt`;
                originalVideo.textTracks.addEventListener('addtrack', (event) => {
                    const track = event.track;
                    track.mode = 'showing';
                });

                // Promise wrapper for video loading
                const loadVideo = (video, src) => {
                    return new Promise((resolve, reject) => {
                        video.addEventListener('loadedmetadata', () => {
                            fullVideoDuration = video.duration;
                            resolve();
                        }, { once: true });

                        video.addEventListener('error', (e) => {
                            reject(new Error('Failed to load video'));
                        }, { once: true });

                        video.src = src;
                    });
                };

                // Load original video first to get full duration
                await loadVideo(originalVideo, videoPath);

                // Calculate buffer range
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);
                bufferedDuration = bufferEnd - bufferStart;

                // Load preview with theme clip range
                previewVideo.src = `${videoPath}#t=${startSeconds},${endSeconds}`;

                // Wait for preview to load
                await loadVideo(previewVideo, previewVideo.src);

                // Load original video with buffered range - this makes seekbar show buffer duration
                originalVideo.src = `${videoPath}#t=${bufferStart},${bufferEnd}`;

                // Wait for original video to reload with range
                await new Promise(resolve => {
                    originalVideo.addEventListener('loadedmetadata', () => {
                        // Update buffer info display
                        document.getElementById('buffer-info').textContent =
                            `Buffer range: ${formatTime(bufferStart)} - ${formatTime(bufferEnd)} (${formatTime(bufferedDuration)})`;

                        // Set video position to theme start time
                        originalVideo.currentTime = startSeconds;

                        resolve();
                    }, { once: true });
                });

                // Show content
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('content').classList.remove('hidden');

                // Initial UI update
                updateUI();
                setupDragHandlers();

                // Setup custom video controls
                setupVideoControls();

                // Initialize time extension inputs with current theme extension values
                updateTimeExtensionInputs();

            } catch (error) {
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('error').textContent = error.message;
                document.getElementById('error').classList.remove('hidden');
            }
        }

        // Update original video playback range (buffered range)
        function updateOriginalVideoRange() {
            if (!videoPath || !fullVideoDuration || startSeconds === null || startSeconds === undefined || endSeconds === null || endSeconds === undefined) return;

            const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
            const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);
            bufferedDuration = bufferEnd - bufferStart;

            // Set video to buffer start position if outside range
            if (originalVideo.currentTime < bufferStart || originalVideo.currentTime > bufferEnd) {
                originalVideo.currentTime = bufferStart;
            }
        }

        // Update preview video with clipped range
        function reloadSubtitleTrack() {
//             console.log('üîÑ reloadSubtitleTrack called');
            // console.log("   startSeconds:", startSeconds);', startSeconds);
            // console.log("   endSeconds:", endSeconds);', endSeconds);

            // Reload VTT subtitle track with current time range
            if (!previewVideo || !folderNumber || !themeNumber) return;

            // console.log("   Before reload - overlay:", document.getElementById(subtitle-preview-text)?.textContent);', document.getElementById('subtitle-preview-text')?.textContent);

            // Clear ALL derived state FIRST to prevent stale subtitle display
            currentCueInfo = null;

            // Clear the subtitle editor
            const subtitleText = document.getElementById('subtitle-text');
            if (subtitleText) {
                subtitleText.innerHTML = '';
            }

            // Clear the preview overlay
            const previewOverlay = document.getElementById('subtitle-preview-text');
            if (previewOverlay) {
                previewOverlay.textContent = '';
            }

            // console.log("   After clear - overlay:", document.getElementById(subtitle-preview-text)?.textContent);', document.getElementById('subtitle-preview-text')?.textContent);

            // Remove ALL existing track elements from the video
            const existingTracks = previewVideo.querySelectorAll('track');
            existingTracks.forEach(track => track.remove());

            // Clear the textTracks list (internal browser cache)
            while (previewVideo.textTracks.length > 0) {
                previewVideo.textTracks[0].mode = 'disabled';
            }

            // Create new track with current time range
            const newSrc = `/api/subtitles/${folderNumber}/${themeNumber}.vtt?start=${startSeconds}&end=${endSeconds}&t=${Date.now()}`;

            const newTrack = document.createElement('track');
            newTrack.id = 'preview-subtitle-track';
            newTrack.kind = 'subtitles';
            newTrack.srclang = 'en';
            newTrack.label = 'English';
            newTrack.default = false;
            newTrack.src = newSrc;

            // Add to DOM
            previewVideo.appendChild(newTrack);

            // Enable track after it loads - do NOT sync immediately
            // Let the natural timeupdate event trigger syncSubtitleToTextarea
            // when cues are actually parsed and ready
            setTimeout(() => {
                if (previewVideo.textTracks.length > 0) {
                    previewVideo.textTracks[0].mode = 'showing';
                }
            }, 50);
        }

        function updatePreviewBoundaries() {
            // Update only the theme boundaries without resetting video
            // This is called during timeline drag to keep preview in sync
            if (!previewVideo || startSeconds === null || startSeconds === undefined || endSeconds === null || endSeconds === undefined) return;

            // Update boundary markers
            previewVideo.dataset.themeStart = startSeconds;
            previewVideo.dataset.themeEnd = endSeconds;
        }

        function updatePreviewVideo() {
            if (!videoPath || startSeconds === null || startSeconds === undefined || endSeconds === null || endSeconds === undefined) return;

            // Load full video and use JavaScript to enforce theme boundaries
            // Add cache-busting parameter to force reload when src doesn't change
            previewVideo.src = videoPath + (videoPath.includes('?') ? '&' : '?') + 't=' + Date.now();
            previewVideo.loop = true;
            previewVideo.muted = false;

            // Store theme boundaries for enforcement
            previewVideo.dataset.themeStart = startSeconds;
            previewVideo.dataset.themeEnd = endSeconds;

            // Remove old listeners
            if (previewVideo.boundariesHandler) {
                previewVideo.removeEventListener('timeupdate', previewVideo.boundariesHandler);
            }
            if (previewVideo.timeUpdateHandler) {
                previewVideo.removeEventListener('timeupdate', previewVideo.timeUpdateHandler);
            }
            if (previewVideo.subtitleSyncHandler) {
                previewVideo.removeEventListener('timeupdate', previewVideo.subtitleSyncHandler);
            }
            if (previewVideo.seekbarHandler) {
                previewSeekbar.removeEventListener('input', previewVideo.seekbarHandler);
            }
            if (previewVideo.playBtnHandler) {
                previewPlayBtn.removeEventListener('click', previewVideo.playBtnHandler);
            }
            if (previewVideo.clickHandler) {
                previewVideo.removeEventListener('click', previewVideo.clickHandler);
            }
            if (previewVideo.playHandler) {
                previewVideo.removeEventListener('play', previewVideo.playHandler);
            }
            if (previewVideo.pauseHandler) {
                previewVideo.removeEventListener('pause', previewVideo.pauseHandler);
            }

            // Enforce theme boundaries and loop
            const enforceThemeBoundaries = () => {
                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd);

                // If video is past theme end and playing, loop back to start
                if (previewVideo.currentTime >= themeEnd && !previewVideo.paused) {
                    previewVideo.currentTime = themeStart;
                }
            };

            // Sync current subtitle from VTT to textarea
            const syncSubtitleToTextarea = () => {
                const textTrack = previewVideo.textTracks[0];
                if (!textTrack || !textTrack.cues || textTrack.cues.length === 0) return;

                const activeCues = textTrack.activeCues;
                if (activeCues.length > 0) {
                    const currentCue = activeCues[0];
                    const subtitleText = document.getElementById('subtitle-text');

//                     console.log('üîÑ syncSubtitleToTextarea called');
                    // console.log("   currentCue.startTime:", currentCue.startTime);', currentCue.startTime);
                    // console.log("   currentCue.text:", currentCue.text);', currentCue.text);
                    // console.log("   previewVideo.currentTime:", previewVideo.currentTime);', previewVideo.currentTime);
                    // console.log("   currentCueInfo:", currentCueInfo);', currentCueInfo);

                    // Convert cue time (seconds) to HH:MM:SS.mmm format for matching with API
                    // Supports negative values for subtitles before theme start
                    const vttToTimestamp = (seconds) => {
                        // Round near-zero values to exactly 0 to avoid floating point precision issues
                        // This prevents -0.000353 from becoming "-00:00:00.000" which won't match "00:00:00.000"
                        const EPSILON = 0.001; // 1ms threshold (increased from 0.0005)
                        if (Math.abs(seconds) < EPSILON) {
                            seconds = 0;
                        }

                        const isNegative = seconds < 0;
                        const absSeconds = Math.abs(seconds);

                        const h = Math.floor(absSeconds / 3600);
                        const m = Math.floor((absSeconds % 3600) / 60);
                        let s = absSeconds % 60;
                        let sInt = Math.floor(s);
                        let msInt = Math.round((s - sInt) * 1000);

                        // Handle millisecond rollover (e.g., 15.999 ‚Üí 16.000)
                        if (msInt >= 1000) {
                            msInt = 0;
                            sInt += 1;
                            if (sInt >= 60) {
                                sInt = 0;
                                m += 1;
                                if (m >= 60) {
                                    m = 0;
                                    h += 1;
                                }
                            }
                        }

                        const sign = isNegative ? '-' : '';
                        return `${sign}${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${sInt.toString().padStart(2, '0')}.${msInt.toString().padStart(3, '0')}`;
                    };

                    // IMPORTANT: Use themeStart from dataset, not closure variable
                    // This ensures correct timing when timeline is expanded/contracted
                    const themeStart = parseFloat(previewVideo.dataset.themeStart);

                    // Track current cue info with matching format
                    // Convert VTT time (original video time) to trimmed time (relative to theme start)
                    // This ensures JSON keys match the trimmed SRT timestamps used for export
                    // Allow negative values to preserve formatting for subtitles before theme start
                    const trimmedStartTime = currentCue.startTime - themeStart;
                    const trimmedEndTime = currentCue.endTime - themeStart;

                    // Match VTT cue to allThemeCues to get the sequence number
                    // The sequence number is the stable SRT sequence (1, 2, 3, ...)
                    let sequence = null;

                    // IMPORTANT: The API returns absolute timestamps from the SRT file
                    // But currentCue.startTime/endTime are also absolute (from original video)
                    // So we should match using absolute timestamps, not relative ones
                    const absoluteTimestampKey = vttToTimestamp(currentCue.startTime);
                    const absoluteEndTimeKey = vttToTimestamp(currentCue.endTime);

                    // timestampKey/endKey are relative (for storage in JSON)
                    const timestampKey = vttToTimestamp(trimmedStartTime);
                    const endTimeKey = vttToTimestamp(trimmedEndTime);

                    // Find matching cue by timestamp and text
                    // Use more lenient text matching (normalize whitespace and newlines)
                    const normalizeText = (text) => text.trim().replace(/[\s\n\r]+/g, ' ');
                    let matchingCue = allThemeCues.find(cue => {
                        const timestampsMatch = cue.start === absoluteTimestampKey && cue.end === absoluteEndTimeKey;
                        if (!timestampsMatch) return false;
                        // Try exact match first, then normalized match
                        return cue.text === currentCue.text || normalizeText(cue.text) === normalizeText(currentCue.text);
                    });

                    // Fallback: match by timestamp only if text matching fails
                    // (handles cases where text has subtle differences)
                    if (!matchingCue) {
                        matchingCue = allThemeCues.find(cue =>
                            cue.start === absoluteTimestampKey && cue.end === absoluteEndTimeKey
                        );
                        if (matchingCue) {
                            console.warn('‚ö†Ô∏è Matched by timestamp only (text differs):');
                            console.warn('   VTT text:', currentCue.text);
                            console.warn('   API text:', matchingCue.text);
                        }
                    }

                    if (matchingCue && matchingCue.sequence) {
                        sequence = matchingCue.sequence;
                    } else {
                        // Debug: log why matching failed
                        console.warn('‚ö†Ô∏è Could not match cue to sequence number');
                        console.warn('   Looking for (ABSOLUTE):', { start: absoluteTimestampKey, end: absoluteEndTimeKey, text: `"${currentCue.text}"` });
                        console.warn('   Looking for (RELATIVE):', { start: timestampKey, end: endTimeKey, text: `"${currentCue.text}"` });
                        console.warn('   allThemeCues.length:', allThemeCues.length);

                        // Find cues with matching timestamp (using absolute)
                        const timestampMatches = allThemeCues.filter(c => c.start === absoluteTimestampKey);
                        console.warn(`   Found ${timestampMatches.length} cues with matching absolute timestamp:`, timestampMatches.map(c => ({
                            sequence: c.sequence,
                            start: c.start,
                            end: c.end,
                            text: `"${c.text}"`
                        })));

                        // Find cues with similar text (substring match)
                        const textMatches = allThemeCues.filter(c => c.text.includes(currentCue.text) || currentCue.text.includes(c.text));
                        if (textMatches.length > 0) {
                            console.warn(`   Found ${textMatches.length} cues with similar text:`, textMatches.map(c => ({
                                sequence: c.sequence,
                                start: c.start,
                                end: c.end,
                                text: `"${c.text}"`
                            })));
                        }
                    }

                    const newCueInfo = {
                        sequence: sequence,
                        timestamp: timestampKey,
                        start: timestampKey,
                        end: endTimeKey,
                        text: currentCue.text
                    };

                    // Only update if we've moved to a different cue (different timestamp OR different text)
                    if (!currentCueInfo || currentCueInfo.start !== newCueInfo.start || currentCueInfo.text !== newCueInfo.text) {
                        currentCueInfo = newCueInfo;

                        // Set flag to prevent auto-save during programmatic update
                        isProgrammaticUpdate = true;

                        console.log('üé¨ Cue changed:', currentCueInfo.sequence, currentCueInfo.timestamp, currentCueInfo.text);
                        console.log('   Looking for formatting in:', Object.keys(allCueFormatting));

                        // Load saved formatting for this cue using sequence as key
                        const key = currentCueInfo.sequence;
                        const formatting = key !== null ? allCueFormatting[key] : null;

                        if (formatting && formatting.html) {
                            // Use the saved HTML which has selective formatting preserved
                            console.log('   ‚úÖ Found saved HTML, applying...');
                            console.log('   HTML to apply:', formatting.html);

                            const html = formatting.html;

                            // Apply HTML directly using insertHTML (bypasses contenteditable sanitization)
                            subtitleText.focus();
                            document.execCommand('selectAll', false, null);
                            document.execCommand('insertHTML', false, html);

// console.log('   HTML after apply:', subtitleText.innerHTML);

                            // Set up observer to detect what's modifying the editor
                            const observer = new MutationObserver((mutations) => {
                                mutations.forEach((mutation) => {
                                    if (mutation.type === 'childList' || mutation.type === 'characterData') {
//                                         console.log('   ‚ö†Ô∏è Editor was modified! New content:', subtitleText.innerHTML);
//                                         console.trace('   Call stack:');
                                    }
                                });
                            });

                            observer.observe(subtitleText, { childList: true, subtree: true, characterData: true });

                            // Stop observing after 2 seconds
                            setTimeout(() => observer.disconnect(), 2000);

                            // Update subtitleFormatting for preview
                            subtitleFormatting = {
                                bold: formatting.bold || false,
                                italic: formatting.italic || false,
                                color: formatting.color || null,
                                size: formatting.size || null,
                                position: formatting.position || null,  // Load individual position
                                customPosition: formatting.customPosition || null,
                                horizontalAlign: formatting.horizontalAlign || 'center',
                                verticalAlign: formatting.verticalAlign || 'middle'
                            };

                            // Restore custom position if exists
                            if (formatting.customPosition) {
                                // Scale coordinates from output resolution back to preview resolution
                                const previewVideo = document.getElementById('preview-video');
                                const scaleX = (previewVideo?.offsetWidth || 281) / 1080;
                                const scaleY = (previewVideo?.offsetHeight || 500) / 1920;

                                customPosition = {
                                    left: formatting.customPosition.left * scaleX,
                                    top: formatting.customPosition.top * scaleY,
                                    centerX: formatting.customPosition.centerX ? formatting.customPosition.centerX * scaleX : null,
                                    width: formatting.customPosition.width ? formatting.customPosition.width * scaleX : null
                                };
                                console.log('   üîÑ Scaled individual position from JSON:', customPosition);
                            } else {
                                customPosition = null;
                            }

                            // Restore alignment
                            horizontalAlign = formatting.horizontalAlign || 'center';
                            verticalAlign = formatting.verticalAlign || 'middle';

                            // Update align button states
                            updateAlignButtons(horizontalAlign, verticalAlign);
                        } else {
                            console.log('   ‚ùå No saved formatting for this cue');
                            // No saved formatting, use plain text
                            subtitleText.innerHTML = currentCue.text;
                            subtitleFormatting = { bold: false, italic: false, color: null, size: null, position: null };

                            // Don't reset customPosition if global mode has custom position
                            // Keep the global custom position for all cues
                            if (globalPosition !== 'custom') {
                                customPosition = null;
                                hasManualPosition = false;
                            } else {
                                // Global mode has custom position - keep it and mark as manual
                                hasManualPosition = true;
                                console.log('   ‚úÖ Keeping global custom position:', customPosition);
                            }

                            horizontalAlign = 'center';
                            verticalAlign = 'middle';
                            updateAlignButtons(horizontalAlign, verticalAlign);
                        }

                        // Always update preview after programmatic cue change
                        // (Don't check focus here since we just focused the editor to apply HTML)
                        updateSubtitlePreview();

                        // Reset flag after programmatic update is complete
                        isProgrammaticUpdate = false;
                    }
                }
            };

            // Update time display and seekbar
            const updateTimeDisplay = () => {
                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd);
                const currentTime = previewVideo.currentTime;

                // Show time relative to theme start
                const relativeTime = currentTime - themeStart;
                const themeDuration = themeEnd - themeStart;

                // Update seekbar position (0-100% of theme duration)
                const seekbarPercent = (Math.max(0, relativeTime) / themeDuration) * 100;
                previewSeekbar.value = seekbarPercent;

                // Update time display
                document.getElementById('preview-time-display').textContent =
                    `${formatTime(Math.max(0, relativeTime))} / ${formatTime(themeDuration)}`;
            };

            // Handle seekbar input
            const handleSeekbarInput = () => {
                if (videoControlsLocked) return;

                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd);
                const themeDuration = themeEnd - themeStart;

                // Calculate target time based on seekbar percentage
                const relativeTime = (previewSeekbar.value / 100) * themeDuration;
                previewVideo.currentTime = themeStart + relativeTime;
            };

            // Toggle play/pause
            const togglePlayPause = () => {
                if (videoControlsLocked) return;

                if (previewVideo.paused) {
                    previewVideo.play();
                } else {
                    previewVideo.pause();
                }
            };

            // Update play button icon
            const updatePlayButton = () => {
                previewPlayBtn.textContent = previewVideo.paused ? '‚ñ∂' : '‚è∏';
            };

            // Add new listeners
            previewVideo.boundariesHandler = enforceThemeBoundaries;
            previewVideo.addEventListener('timeupdate', enforceThemeBoundaries);

            previewVideo.subtitleSyncHandler = syncSubtitleToTextarea;
            previewVideo.addEventListener('timeupdate', syncSubtitleToTextarea);

            previewVideo.timeUpdateHandler = updateTimeDisplay;
            previewVideo.addEventListener('timeupdate', updateTimeDisplay);

            // Add word highlighting handler for karaoke preview
            previewVideo.wordHighlightHandler = () => {
                if (karaokeEnabled) {
                    updatePreviewWordHighlighting(previewVideo.currentTime);
                }

                // Canvas rendering handler for canvas mode
                if (canvasMode && canvasRenderer) {
                    try {
                        // IMPORTANT: Always find current subtitle from allThemeCues based on video time
                        // Don't rely on editor element which may be stale
                        let subtitleText = '';
                        let currentCue = null;

                        if (allThemeCues && allThemeCues.length > 0) {
                            const currentTime = previewVideo.currentTime;
                            currentCue = allThemeCues.find(cue => {
                                const cueStart = parseTime(cue.start);
                                const cueEnd = parseTime(cue.end);
                                return currentTime >= cueStart && currentTime <= cueEnd;
                            });

                            if (currentCue) {
                                subtitleText = currentCue.text;
                            }
                        }

                        // Debug log when we have subtitles
                        if (subtitleText && !window.canvasTextLogged) {
                            console.log('[Canvas] ‚úì Found subtitle text:', subtitleText.substring(0, 60));
                            window.canvasTextLogged = true;
                        }

                        // Only render if there's actually text to show
                        if (!subtitleText) {
                            // No subtitle active - render transparent frame
                            const canvas = document.getElementById('karaoke-canvas');
                            const ctx = canvas?.getContext('2d');
                            if (ctx && canvas) {
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                            }
                            return;
                        }

                        // Get the currently highlighted word index from word timestamps (not DOM)
                        let highlightedWordIndex = -1;
                        if (wordTimestamps && wordTimestamps.length > 0 && subtitleText) {
                            const currentTime = previewVideo.currentTime;

                            // Find the global index of the word being spoken
                            const globalWordIndex = wordTimestamps.findIndex(w =>
                                currentTime >= w.start && currentTime < w.end
                            );

                            if (globalWordIndex >= 0 && currentCue) {
                                // We have a cue from allThemeCues - calculate local word index
                                const currentCueStart = parseTime(currentCue.start);
                                const currentCueEnd = parseTime(currentCue.end);
                                const wordsInCurrentCue = subtitleText.split(/\s+/).filter(w => w.length > 0);

                                // Collect all word timestamps that fall within this cue's time range
                                // Use epsilon for floating point comparison, and exclude words at exact boundaries
                                const EPSILON = 0.05; // 50ms tolerance
                                const wordsInCueRange = [];
                                for (let i = 0; i < wordTimestamps.length; i++) {
                                    const wt = wordTimestamps[i];
                                    // Include words that start within the cue (with small buffer at start, strict at end)
                                    if (wt.start >= currentCueStart - EPSILON && wt.start < currentCueEnd - EPSILON) {
                                        wordsInCueRange.push({ index: i, word: wt.word, start: wt.start, end: wt.end });
                                    }
                                }

                                // Now we need to match wordsInCueRange to wordsInCurrentCue by text
                                // Note: highlightedWordIndex is declared above, don't redeclare with 'let'

                                if (wordsInCueRange.length > 0) {
                                    // Find which word is currently being spoken
                                    const currentlySpoken = wordsInCueRange.find(w =>
                                        previewVideo.currentTime >= w.start && previewVideo.currentTime < w.end
                                    );

                                    if (currentlySpoken) {
                                        // Try to find this word in the subtitle text
                                        // IMPORTANT: Trim whitespace and normalize
                                        const spokenWordLower = currentlySpoken.word.trim().toLowerCase().replace(/[.,!?;:"']/g, '');

                                        for (let i = 0; i < wordsInCurrentCue.length; i++) {
                                            const cueWordLower = wordsInCurrentCue[i].trim().toLowerCase().replace(/[.,!?;:"']/g, '');
                                            if (cueWordLower === spokenWordLower) {
                                                highlightedWordIndex = i;
                                                break;
                                            }
                                        }
                                    }
                                }
                            } else if (globalWordIndex >= 0 && !currentCue) {
                                // Text came from editor, try to match by word text
                                const wordsInText = subtitleText.split(/\s+/).filter(w => w.length > 0);
                                const spokenWord = wordTimestamps[globalWordIndex];

                                // Try to find matching word in subtitle text
                                for (let i = 0; i < wordsInText.length; i++) {
                                    const cleanWord = wordsInText[i].toLowerCase().replace(/[.,!?;:"']/g, '');
                                    const cleanSpoken = (spokenWord.word || '').toLowerCase().replace(/[.,!?;:"']/g, '');
                                    if (cleanWord === cleanSpoken || cleanWord.includes(cleanSpoken) || cleanSpoken.includes(cleanWord)) {
                                        highlightedWordIndex = i;
                                        break;
                                    }
                                }
                            }
                        }

                        // Check if the method exists
                        if (typeof canvasRenderer.renderFrameWithHighlight === 'function') {
                            canvasRenderer.renderFrameWithHighlight(previewVideo.currentTime, subtitleText, highlightedWordIndex);

                            // Debug: confirm render was called
                            if (!window.canvasRenderCallLogged) {
                                console.log('[Canvas] ‚úì renderFrameWithHighlight called successfully!');
                                const canvas = document.getElementById('karaoke-canvas');
                                console.log('[Canvas] canvas visibility:', canvas.style.display);
                                console.log('[Canvas] canvas z-index:', window.getComputedStyle(canvas).zIndex);
                                console.log('[Canvas] video opacity:', previewVideo.style.opacity);
                                window.canvasRenderCallLogged = true;
                            }
                        } else {
                            console.error('[Canvas] renderFrameWithHighlight method not found, falling back to renderFrame');
                            canvasRenderer.renderFrame(previewVideo.currentTime, subtitleText);
                        }
                    } catch (error) {
                        console.error('[Canvas] Render error:', error);
                    }
                }
            };
            previewVideo.addEventListener('timeupdate', previewVideo.wordHighlightHandler);

            previewVideo.seekbarHandler = handleSeekbarInput;
            previewSeekbar.addEventListener('input', handleSeekbarInput);

            previewVideo.playBtnHandler = togglePlayPause;
            previewPlayBtn.addEventListener('click', togglePlayPause);

            previewVideo.clickHandler = togglePlayPause;
            previewVideo.addEventListener('click', togglePlayPause);

            previewVideo.playHandler = updatePlayButton;
            previewVideo.addEventListener('play', updatePlayButton);

            previewVideo.pauseHandler = updatePlayButton;
            previewVideo.addEventListener('pause', updatePlayButton);

            // When video loads metadata, seek to theme start
            previewVideo.addEventListener('loadedmetadata', () => {
                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                previewVideo.currentTime = themeStart;
                updateTimeDisplay();
                updatePlayButton();

                // Clear ALL subtitle state to prevent stale display
                // Do NOT enable track here - let reloadSubtitleTrack() handle it
                currentCueInfo = null;

                const subtitleText = document.getElementById('subtitle-text');
                if (subtitleText) {
                    subtitleText.innerHTML = '';
                }

                const previewOverlay = document.getElementById('subtitle-preview-text');
                if (previewOverlay) {
                    previewOverlay.textContent = '';
                }

                // Do NOT enable track here - reloadSubtitleTrack() will handle it
                // Enabling the track here would cause old cues to be displayed before
                // reloadSubtitleTrack() replaces the track with the updated one
            }, { once: true });

            // Fallback: Also seek after a delay in case loadedmetadata doesn't fire
            // This can happen when the browser thinks the video src hasn't changed
            setTimeout(() => {
                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                if (previewVideo.currentTime !== themeStart && previewVideo.readyState >= 2) {
                    previewVideo.currentTime = themeStart;
                    updateTimeDisplay();
                }
            }, 500);

            // Load VTT subtitles for preview - use adjusted subtitles if available
            // Clear current cue info
            currentCueInfo = null;

            // Don't clear allCueFormatting - we want saved styles to persist

            const subtitleTextClear = document.getElementById('subtitle-text');
            if (subtitleTextClear) {
                subtitleTextClear.innerHTML = '';
            }

            // Remove ALL existing tracks first
            const existingTracks = previewVideo.querySelectorAll('track');
            existingTracks.forEach(track => track.remove());

            // Clear the textTracks list
            while (previewVideo.textTracks.length > 0) {
                previewVideo.textTracks[0].mode = 'disabled';
            }

            if (folderNumber && themeNumber) {
                // Create new track
                const newTrack = document.createElement('track');
                newTrack.id = 'preview-subtitle-track';
                newTrack.kind = 'subtitles';
                newTrack.srclang = 'en';
                newTrack.label = 'English';
                newTrack.default = false;
                newTrack.src = `/api/subtitles/${folderNumber}/${themeNumber}.vtt?start=${startSeconds}&end=${endSeconds}`;

                // Add to DOM
                previewVideo.appendChild(newTrack);

                // Keep mode as 'showing' so cues are loaded and accessible
                setTimeout(() => {
                    if (previewVideo.textTracks.length > 0) {
                        const textTrack = previewVideo.textTracks[0];
                        if (textTrack) {
                            textTrack.mode = 'showing';
                        }
                    }
                }, 100);
            }


            // Don't autoplay
            // previewVideo.play().catch(() => {});
        }

        // Update UI
        function updateUI() {
            if (!fullVideoDuration) return;

            const clipDuration = endSeconds - startSeconds;
            const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
            const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);
            bufferedDuration = bufferEnd - bufferStart;

            // Position buffer range on full video timeline
            const bufferLeftPercent = (bufferStart / fullVideoDuration) * 100;
            const bufferWidthPercent = (bufferedDuration / fullVideoDuration) * 100;
            bufferRange.style.left = `${bufferLeftPercent}%`;
            bufferRange.style.width = `${bufferWidthPercent}%`;

            // Position theme box within buffer range
            const themeLeftPercent = ((startSeconds - bufferStart) / bufferedDuration) * 100;
            const themeWidthPercent = (clipDuration / bufferedDuration) * 100;
            themeBox.style.left = `${themeLeftPercent}%`;
            themeBox.style.width = `${themeWidthPercent}%`;
            themeBoxContent.textContent = `${formatTime(startSeconds)} - ${formatTime(endSeconds)}`;

            // Update timeline markers to show full video range
            document.getElementById('time-start-marker').textContent = '00:00:00';
            document.getElementById('time-end-marker').textContent = formatTime(fullVideoDuration);

            // Update info display
            document.getElementById('display-start').textContent = formatTime(startSeconds);
            document.getElementById('display-end').textContent = formatTime(endSeconds);
            document.getElementById('display-duration').textContent = formatTime(clipDuration);

            // Update buffer display with separate left/right values
            const bufferLeftMin = Math.round(bufferLeftSeconds / 60);
            const bufferRightMin = Math.round(bufferRightSeconds / 60);
            document.getElementById('buffer-display').textContent = `L: ¬±${bufferLeftMin}min | R: ¬±${bufferRightMin}min`;

            // Update buffer info on video
            document.getElementById('buffer-info').textContent =
                `Buffer range: ${formatTime(bufferStart)} - ${formatTime(bufferEnd)} (${formatTime(bufferedDuration)})`;

            // Update subtitle preview
            updateSubtitlePreview();

            // Update preview video during drag by updating boundaries
            // Don't reset the video (which causes position 0 issue)
            if (!isDragging) {
                // Not dragging - do full preview video update
                updatePreviewVideo();
            } else {
                // During drag - only update boundaries, don't reset video
                updatePreviewBoundaries();
            }

            // NOTE: Don't reload subtitle track during drag - only after drag completes
            // This prevents continuous reloading which causes performance issues

            // Update original video to show only buffered range (but not during drag)
            if (!isDragging) {
                updateOriginalVideoRange();
            }
        }

        // Setup drag handlers
        function setupDragHandlers() {
            // Left handle - adjust start time
            handleLeft.addEventListener('mousedown', (e) => {
                isDragging = 'left';
                dragStartX = e.clientX;
                dragStartValue = startSeconds;
                themeStartBeforeDrag = startSeconds; // Track theme start before drag
                e.preventDefault();
                e.stopPropagation();
            });

            // Right handle - adjust end time
            handleRight.addEventListener('mousedown', (e) => {
                isDragging = 'right';
                dragStartX = e.clientX;
                dragStartValue = endSeconds;
                themeEndBeforeDrag = endSeconds; // Track theme end before drag
                e.preventDefault();
                e.stopPropagation();
            });

            // Hover effects - highlight theme box edges
            handleLeft.addEventListener('mouseenter', () => {
                themeBox.classList.add('highlight-left');
            });

            handleLeft.addEventListener('mouseleave', () => {
                themeBox.classList.remove('highlight-left');
            });

            handleRight.addEventListener('mouseenter', () => {
                themeBox.classList.add('highlight-right');
            });

            handleRight.addEventListener('mouseleave', () => {
                themeBox.classList.remove('highlight-right');
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - dragStartX;
                // Use full video duration for drag calculations
                const deltaTime = (deltaX / timelineTrack.offsetWidth) * fullVideoDuration;

                if (isDragging === 'left') {
                    let newStart = dragStartValue + deltaTime;
                    newStart = Math.max(0, Math.min(newStart, endSeconds - 20));
                    startSeconds = newStart;
                } else if (isDragging === 'right') {
                    let newEnd = dragStartValue + deltaTime;
                    newEnd = Math.max(startSeconds + 20, Math.min(newEnd, fullVideoDuration));
                    endSeconds = newEnd;
                }

                updateUI();
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                        console.log('üñ±Ô∏è DRAG END - Timeline extended');

                    // Calculate theme start offset when dragging left handle
                    const timeOffset = startSeconds - themeStartBeforeDrag;

                    if (isDragging === 'left' && timeOffset !== 0) {
                        console.log(`   Theme start shifted by ${timeOffset}s`);
                        console.log(`   Old theme start: ${themeStartBeforeDrag}s`);
                        console.log(`   New theme start: ${startSeconds}s`);
                        console.log(`   Keys before:`, Object.keys(allCueFormatting));

                        // CRITICAL: Update timestamps only, don't regenerate keys
                        // Sequence keys are stable and don't change
                        const vttToSeconds = (vttTimestamp) => {
                            const [time, millis] = vttTimestamp.split('.');
                            const isNegative = time.startsWith('-');
                            const [h, m, s] = time.replace('-', '').split(':').map(Number);
                            const result = h * 3600 + m * 60 + s + (millis || 0) / 1000;
                            return isNegative ? -result : result;
                        };

                        const secondsToVtt = (totalSeconds) => {
                            const EPSILON = 0.001;
                            if (Math.abs(totalSeconds) < EPSILON) {
                                totalSeconds = 0;
                            }
                            const isNegative = totalSeconds < 0;
                            const absSeconds = Math.abs(totalSeconds);
                            let h = Math.floor(absSeconds / 3600);
                            let m = Math.floor((absSeconds % 3600) / 60);
                            let s = absSeconds % 60;
                            let sInt = Math.floor(s);
                            let msInt = Math.round((s - sInt) * 1000);
                            if (msInt >= 1000) {
                                msInt = 0;
                                sInt += 1;
                                if (sInt >= 60) {
                                    sInt = 0;
                                    m += 1;
                                    if (m >= 60) {
                                        m = 0;
                                        h += 1;
                                    }
                                }
                            }
                            const sign = isNegative ? '-' : '';
                            return `${sign}${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${sInt.toString().padStart(2, '0')}.${msInt.toString().padStart(3, '0')}`;
                        };

                        // Update timestamp field for each sequence key
                        for (const [seqKey, formatting] of Object.entries(allCueFormatting)) {
                            const oldSeconds = vttToSeconds(formatting.timestamp);
                            const newSeconds = oldSeconds - timeOffset;  // Subtract offset
                            allCueFormatting[seqKey].timestamp = secondsToVtt(newSeconds);
                            console.log(`   Sequence ${seqKey}: ${formatting.timestamp} ‚Üí ${allCueFormatting[seqKey].timestamp}`);
                        }

                        console.log(`   Keys after (unchanged):`, Object.keys(allCueFormatting));

                        // Save formatting to server with updated timestamps
                        console.log('   Saving to server...');
                        fetch('/api/save-subtitle-formatting', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder: folderNumber,
                                theme: themeNumber,
                                formatting: allCueFormatting
                            })
                        }).then(res => res.json())
                          .then(data => console.log('   ‚úì Formatting saved:', data))
                          .catch(err => console.error('   ‚úó Failed to save formatting:', err));
                    }

                    // Handle right-side drag (theme end changes)
                    // Formatting keys are relative to themeStart, so they don't need to shift
                    // But we need to save to ensure styles are preserved
                    if (isDragging === 'right') {
                        const themeEndOffset = endSeconds - themeEndBeforeDrag;

                        if (themeEndOffset !== 0) {
                            console.log(`   Theme end shifted by ${themeEndOffset}s`);
                            console.log(`   Old theme end: ${themeEndBeforeDrag}s`);
                            console.log(`   New theme end: ${endSeconds}s`);
                            console.log(`   Formatting keys (no shift needed, relative to themeStart):`, Object.keys(allCueFormatting));

                            // For right-side drag, we don't shift keys (they're relative to themeStart)
                            // But we save to ensure styles are preserved even if subtitles are now out of bounds
                            console.log('   Saving formatting to preserve styles...');
                            fetch('/api/save-subtitle-formatting', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    folder: folderNumber,
                                    theme: themeNumber,
                                    formatting: allCueFormatting
                                })
                            }).then(res => res.json())
                              .then(data => console.log('   ‚úì Formatting saved:', data))
                              .catch(err => console.error('   ‚úó Failed to save formatting:', err));
                        }
                    }

                    // Drag ended - clear subtitle state FIRST before any video updates
                    // This prevents old cues from being displayed during the update process
                    currentCueInfo = null;

                    const subtitleText = document.getElementById('subtitle-text');
                    if (subtitleText) {
                        subtitleText.innerHTML = '';
                    }

                    const previewOverlay = document.getElementById('subtitle-preview-text');
                    if (previewOverlay) {
                        previewOverlay.textContent = '';
                    }

                    // Seek original video to new theme start position
                    originalVideo.currentTime = startSeconds;

                    // Now that drag is complete, do full preview video update with new time range
                    updatePreviewVideo();

                    // Reload subtitle track with new time range
                    reloadSubtitleTrack();

                    // Regenerate the adjust.srt file with new theme boundaries
                    // This converts absolute timestamps to relative timestamps
// console.log('   Regenerating adjust.srt with new theme boundaries...');

                    // Helper to parse VTT timestamp string to seconds
                    const vttToSeconds = (vttTimestamp) => {
                        const [time, millis] = vttTimestamp.split('.');
                        const [h, m, s] = time.split(':').map(Number);
                        return h * 3600 + m * 60 + s + (millis || 0) / 1000;
                    };

                    // Helper to convert seconds to VTT timestamp string
                    const secondsToVtt = (totalSeconds) => {
                        const h = Math.floor(totalSeconds / 3600);
                        const m = Math.floor((totalSeconds % 3600) / 60);
                        const s = totalSeconds % 60;
                        const sInt = Math.floor(s);
                        const ms = Math.round((s - sInt) * 1000);
                        return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${sInt.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
                    };

                    const adjustedCues = allThemeCues.map((cue, index) => {
                        const cueStartSec = vttToSeconds(cue.start);
                        const cueEndSec = vttToSeconds(cue.end);

                        return {
                            sequence: index + 1,
                            start: secondsToVtt(Math.max(0, cueStartSec - startSeconds)),
                            end: secondsToVtt(Math.max(0, cueEndSec - startSeconds)),
                            text: cue.text
                        };
                    });

                    // Note: adjustedCues are no longer saved to adjust.srt
                    // The shorts_creator will create its own trimmed SRT from original source

                    // Auto-save theme adjustment
                    autoSaveTheme();

                    // Update time extension inputs to reflect new theme boundaries
                    updateTimeExtensionInputs();
                }
                isDragging = null;
            });

            // Video buffer controls - adjust buffer on each side independently

            // Left side controls - adjust buffer before theme
            const leftDecreaseBtn = document.getElementById('video-buffer-decrease-left');
            const leftIncreaseBtn = document.getElementById('video-buffer-increase-left');
            const rightDecreaseBtn = document.getElementById('video-buffer-decrease-right');
            const rightIncreaseBtn = document.getElementById('video-buffer-increase-right');

            leftDecreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferLeftSeconds = Math.max(0, bufferLeftSeconds - 60);
                updateUI();
            });

            leftIncreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferLeftSeconds += 60;
                updateUI();
            });

            // Right side controls - adjust buffer after theme
            rightDecreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferRightSeconds = Math.max(0, bufferRightSeconds - 60);
                updateUI();
            });

            rightIncreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferRightSeconds += 60;
                updateUI();
            });

            // Helper function to convert time input (HH:MM:SS) to seconds
            const timeInputToSeconds = (timeInput) => {
                const parts = timeInput.split(':');
                if (parts.length === 3) {
                    const [h, m, s] = parts.map(Number);
                    return h * 3600 + m * 60 + s;
                }
                return 0;
            };

            // Apply left extension time from input fields
            const applyExtLeftBtn = document.getElementById('apply-ext-left');
            if (applyExtLeftBtn) {
                applyExtLeftBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();

                    const extLeftEnd = document.getElementById('ext-left-end');

                    if (extLeftEnd) {
                        const extensionSeconds = timeInputToSeconds(extLeftEnd.value);

                        // Move theme start earlier by the extension amount
                        const newStartSeconds = Math.max(0, originalStartSeconds - extensionSeconds);

                        // Handle formatting timestamp shift when theme start changes
                        const timeOffset = newStartSeconds - startSeconds;

                        if (Object.keys(allCueFormatting).length > 0 && timeOffset !== 0) {
                            const vttToSeconds = (vttTimestamp) => {
                                const [time, millis] = vttTimestamp.split('.');
                                const isNegative = time.startsWith('-');
                                const [h, m, s] = time.replace('-', '').split(':').map(Number);
                                const result = h * 3600 + m * 60 + s + (millis || 0) / 1000;
                                return isNegative ? -result : result;
                            };

                            const secondsToVtt = (totalSeconds) => {
                                const EPSILON = 0.001;
                                if (Math.abs(totalSeconds) < EPSILON) {
                                    totalSeconds = 0;
                                }
                                const isNegative = totalSeconds < 0;
                                const absSeconds = Math.abs(totalSeconds);
                                let h = Math.floor(absSeconds / 3600);
                                let m = Math.floor((absSeconds % 3600) / 60);
                                let s = absSeconds % 60;
                                let sInt = Math.floor(s);
                                let msInt = Math.round((s - sInt) * 1000);
                                if (msInt >= 1000) {
                                    msInt = 0;
                                    sInt += 1;
                                    if (sInt >= 60) {
                                        sInt = 0;
                                        m += 1;
                                        if (m >= 60) {
                                            m = 0;
                                            h += 1;
                                        }
                                    }
                                }
                                const sign = isNegative ? '-' : '';
                                return `${sign}${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${sInt.toString().padStart(2, '0')}.${msInt.toString().padStart(3, '0')}`;
                            };

                            // Update timestamps for each sequence key
                            for (const [seqKey, formatting] of Object.entries(allCueFormatting)) {
                                const oldSeconds = vttToSeconds(formatting.timestamp);
                                const newSeconds = oldSeconds - timeOffset;
                                allCueFormatting[seqKey].timestamp = secondsToVtt(newSeconds);
                            }

                            // Save formatting to server
                            fetch('/api/save-subtitle-formatting', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    folder: folderNumber,
                                    theme: themeNumber,
                                    formatting: allCueFormatting
                                })
                            }).then(res => res.json())
                              .then(data => console.log('   ‚úì Formatting saved'))
                              .catch(err => console.error('   ‚úó Failed to save formatting:', err));
                        }

                        startSeconds = newStartSeconds;

                        console.log(`üéØ Applied left extension: ${extLeftEnd.value} (${extensionSeconds}s earlier)`);
                        updateUI();
                        updatePreviewVideo();
                        reloadSubtitleTrack();

                        // Save adjusted theme boundaries to server
                        autoSaveTheme();
                    }
                });
            }

            // Apply right extension time from input fields
            const applyExtRightBtn = document.getElementById('apply-ext-right');
            if (applyExtRightBtn) {
                applyExtRightBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();

                    const extRightEnd = document.getElementById('ext-right-end');

                    if (extRightEnd) {
                        const extensionSeconds = timeInputToSeconds(extRightEnd.value);

                        // Move theme end later by the extension amount
                        const newEndSeconds = Math.min(fullVideoDuration, originalEndSeconds + extensionSeconds);

                        endSeconds = newEndSeconds;

                        console.log(`üéØ Applied right extension: ${extRightEnd.value} (${extensionSeconds}s later)`);
                        updateUI();
                        updatePreviewVideo();
                        reloadSubtitleTrack();

                        // Save adjusted theme boundaries to server
                        autoSaveTheme();
                    }
                });
            }

            // Reset timeline button - reset to original theme time range
            const resetTimelineBtn = document.getElementById('reset-timeline-btn');
            if (resetTimelineBtn) {
                resetTimelineBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    e.preventDefault();

                    const currentStart = startSeconds;
                    const timeOffset = originalStartSeconds - currentStart;

                    console.log('üîÑ Reset to original');
                    console.log(`   Current start: ${currentStart}s ‚Üí Original: ${originalStartSeconds}s`);
                    console.log(`   Time offset: ${timeOffset}s`);
                    console.log(`   Keys before:`, Object.keys(allCueFormatting));

                    // CRITICAL: Update timestamps only, don't regenerate keys
                    // Sequence keys are stable and don't change
                    if (Object.keys(allCueFormatting).length > 0 && timeOffset !== 0) {
                        const vttToSeconds = (vttTimestamp) => {
                            const [time, millis] = vttTimestamp.split('.');
                            const isNegative = time.startsWith('-');
                            const [h, m, s] = time.replace('-', '').split(':').map(Number);
                            const result = h * 3600 + m * 60 + s + (millis || 0) / 1000;
                            return isNegative ? -result : result;
                        };

                        const secondsToVtt = (totalSeconds) => {
                            const EPSILON = 0.001;
                            if (Math.abs(totalSeconds) < EPSILON) {
                                totalSeconds = 0;
                            }
                            const isNegative = totalSeconds < 0;
                            const absSeconds = Math.abs(totalSeconds);
                            let h = Math.floor(absSeconds / 3600);
                            let m = Math.floor((absSeconds % 3600) / 60);
                            let s = absSeconds % 60;
                            let sInt = Math.floor(s);
                            let msInt = Math.round((s - sInt) * 1000);
                            if (msInt >= 1000) {
                                msInt = 0;
                                sInt += 1;
                                if (sInt >= 60) {
                                    sInt = 0;
                                    m += 1;
                                    if (m >= 60) {
                                        m = 0;
                                        h += 1;
                                    }
                                }
                            }
                            const sign = isNegative ? '-' : '';
                            return `${sign}${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${sInt.toString().padStart(2, '0')}.${msInt.toString().padStart(3, '0')}`;
                        };

                        // Update timestamp field for each sequence key
                        for (const [seqKey, formatting] of Object.entries(allCueFormatting)) {
                            const oldSeconds = vttToSeconds(formatting.timestamp);
                            const newSeconds = oldSeconds - timeOffset;  // Subtract offset
                            allCueFormatting[seqKey].timestamp = secondsToVtt(newSeconds);
                            console.log(`   Sequence ${seqKey}: ${formatting.timestamp} ‚Üí ${allCueFormatting[seqKey].timestamp}`);
                        }

                        console.log(`   Keys after (unchanged):`, Object.keys(allCueFormatting));
                    }

                    // Save formatting to server with updated keys
                    console.log('   Saving to server...');
                    const saveResponse = await fetch('/api/save-subtitle-formatting', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            folder: folderNumber,
                            theme: themeNumber,
                            formatting: allCueFormatting
                        })
                    });

                    if (!saveResponse.ok) {
                        console.error('   ‚úó Failed to save formatting:', saveResponse.status);
                    } else {
                        const saveData = await saveResponse.json();
                        console.log('   ‚úì Formatting saved:', saveData);
                    }

                    // Reset to original values
                    startSeconds = originalStartSeconds;
                    endSeconds = originalEndSeconds;

                    // Keep currentCueInfo but don't clear formatting - styles should be preserved
                    currentCueInfo = null;

                    // Update UI (includes original video)
                    updateUI();

                    // IMPORTANT: Explicitly seek original video to the reset position
                    // This ensures the original video updates even if it's already in buffer range
                    originalVideo.currentTime = startSeconds;

                    // Update preview video with new time range
                    updatePreviewVideo();

                    // Reload subtitle track with new time range
                    reloadSubtitleTrack();

                    // Update time extension inputs - after reset they should be 00:00:00
                    updateTimeExtensionInputs();

                    // Delete the adjust file on server
                    try {
                        const response = await fetch('/api/reset-theme', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder: folderNumber,
                                theme: themeNumber
                            })
                        });

                        if (!response.ok) throw new Error('Failed to reset theme');

                        // Visual feedback
                        resetTimelineBtn.textContent = '‚úì Reset Complete';
                        setTimeout(() => {
                            resetTimelineBtn.innerHTML = '‚Ü∫ Reset to Original';
                        }, 1500);
                    } catch (error) {
// console.error('Error resetting theme:', error);
                        resetTimelineBtn.textContent = '‚úó Reset Failed';
                        setTimeout(() => {
                            resetTimelineBtn.innerHTML = '‚Ü∫ Reset to Original';
                        }, 1500);
                    }
                });
            }
        }

        // Setup custom video controls
        function setupVideoControls() {
            // Set initial volume
            originalVideo.volume = volumeSlider.value;

            // Play/Pause button
            playPauseBtn.addEventListener('click', () => {
                if (originalVideo.paused) {
                    originalVideo.play();
                    playPauseBtn.textContent = '‚è∏';
                } else {
                    originalVideo.pause();
                    playPauseBtn.textContent = '‚ñ∂';
                }
            });

            // Update play/pause button when video state changes
            originalVideo.addEventListener('play', () => {
                playPauseBtn.textContent = '‚è∏';
            });

            originalVideo.addEventListener('pause', () => {
                playPauseBtn.textContent = '‚ñ∂';
            });

            // Update seekbar as video plays
            originalVideo.addEventListener('timeupdate', () => {
                // Calculate position within buffer range
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);

                // Keep video within buffer range
                if (originalVideo.currentTime < bufferStart) {
                    originalVideo.currentTime = bufferStart;
                } else if (originalVideo.currentTime > bufferEnd) {
                    originalVideo.currentTime = bufferEnd;
                    originalVideo.pause();
                }

                // Update seekbar (0-100% of buffer)
                const positionInBuffer = originalVideo.currentTime - bufferStart;
                const percent = (positionInBuffer / bufferedDuration) * 100;
                seekbar.value = percent;

                // Update time display (showing time relative to buffer start)
                timeDisplay.textContent = `${formatTime(positionInBuffer)} / ${formatTime(bufferedDuration)}`;
            });

            // Seek when user drags seekbar
            seekbar.addEventListener('input', () => {
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const percent = seekbar.value;
                const positionInBuffer = (percent / 100) * bufferedDuration;
                originalVideo.currentTime = bufferStart + positionInBuffer;
            });

            // Jump to theme start
            jumpStartBtn.addEventListener('click', () => {
                originalVideo.currentTime = startSeconds;
            });

            // Jump to theme end
            jumpEndBtn.addEventListener('click', () => {
                originalVideo.currentTime = endSeconds;
            });

            // Volume control
            volumeSlider.addEventListener('input', () => {
                originalVideo.volume = volumeSlider.value;
            });

            // Click on video to play/pause
            originalVideo.addEventListener('click', () => {
                if (originalVideo.paused) {
                    originalVideo.play();
                } else {
                    originalVideo.pause();
                }
            });

            // Update seekbar theme markers
            const updateSeekbarTheme = () => {
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);

                // Calculate theme position within buffer (as percentage)
                const themeStartPercent = ((startSeconds - bufferStart) / bufferedDuration) * 100;
                const themeEndPercent = ((endSeconds - bufferStart) / bufferedDuration) * 100;

                // Set CSS custom properties for gradient
                seekbar.style.setProperty('--theme-start', `${themeStartPercent}%`);
                seekbar.style.setProperty('--theme-end', `${themeEndPercent}%`);
                seekbar.classList.add('theme-marked');

                // Position marker at center of theme range
                const themeCenterPercent = (themeStartPercent + themeEndPercent) / 2;
                themeMarker.style.left = `${themeCenterPercent}%`;

                // Update theme duration text
                const themeDuration = endSeconds - startSeconds;
                themeDurationText.textContent = formatTime(themeDuration);
            };

            // Set initial seekbar and time display
            seekbar.max = 100;

            // Calculate initial position in buffer (theme start position)
            const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
            const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);
            const positionInBuffer = originalVideo.currentTime - bufferStart;
            const seekbarPercent = (positionInBuffer / bufferedDuration) * 100;

            seekbar.value = seekbarPercent;
            timeDisplay.textContent = `${formatTime(positionInBuffer)} / ${formatTime(bufferedDuration)}`;

            // Apply theme markers to seekbar
            updateSeekbarTheme();

            // Update theme markers when theme range changes
            const originalUpdateUI = updateUI;
            updateUI = function() {
                originalUpdateUI();
                updateSeekbarTheme();
            };
        }

        // Update subtitle preview
        function updateSubtitlePreview() {
            const editor = document.getElementById('subtitle-text');
            let text = editor.innerText; // Get plain text for saving
            const html = editor.innerHTML; // Get HTML for display

//             console.log('üé® updateSubtitlePreview called');
//             console.log('   editor HTML:', html.substring(0, 100));

            const fontSize = document.getElementById('subtitle-size').value;
            const fontFamily = document.getElementById('subtitle-font').value;
            const color = document.getElementById('subtitle-color').value;
            const bgColor = document.getElementById('subtitle-bg').value;
            const bgOpacity = document.getElementById('subtitle-bg-opacity').value / 100;

            // Check individual position first, then use dropdown/global
            let effectivePosition = document.getElementById('subtitle-position').value;
            if (subtitleFormatting.position) {
                effectivePosition = subtitleFormatting.position;
            } else if (globalPosition) {
                effectivePosition = globalPosition;
            }

            const overlay = document.getElementById('subtitle-overlay');
            const textEl = document.getElementById('subtitle-preview-text');

            // For preview, use the innerHTML directly to show formatting
            let displayText = html;

            // Only show overlay if there's text
            if (displayText.trim()) {
                textEl.innerHTML = displayText;
                textEl.style.fontSize = `${fontSize}px`;
                textEl.style.fontFamily = fontFamily;
                // Don't set global color - let HTML inline styles handle individual word/phrase colors
                // Only set background color
                textEl.style.backgroundColor = `rgba(${hexToRgb(bgColor)}, ${bgOpacity})`;
                overlay.style.display = 'block';
                overlay.style.left = '50%';

                // Check if custom position exists (from drag or align buttons)
                if (customPosition && hasManualPosition) {
                    // Apply exact custom position with proper alignment
                    // For center alignment, use centerX with translateX(-50%)
                    // For left/right alignment, use left edge directly
                    const hAlign = horizontalAlign || 'center';
                    if (hAlign === 'center' && customPosition.centerX !== null) {
                        overlay.style.left = `${customPosition.centerX}px`;
                        overlay.style.transform = 'translateX(-50%)';
                    } else if (hAlign === 'right') {
                        // For right align, position from right edge
                        overlay.style.right = `${customPosition.left}px`;  // saved as right edge
                        overlay.style.left = 'auto';
                        overlay.style.transform = 'none';
                    } else {
                        // For left align, use left edge directly
                        overlay.style.left = `${customPosition.left}px`;
                        overlay.style.transform = 'none';
                    }
                    overlay.style.top = `${customPosition.top}px`;
                    overlay.style.bottom = 'auto';
                } else if (!hasManualPosition) {
                    // Position overlay using effective position (individual > global > dropdown)
                    if (effectivePosition === 'bottom') {
                        overlay.style.bottom = '40px';
                        overlay.style.top = 'auto';
                        overlay.style.transform = 'translateX(-50%)';
                    } else if (effectivePosition === 'top') {
                        overlay.style.top = '20px';
                        overlay.style.bottom = 'auto';
                        overlay.style.transform = 'translateX(-50%)';
                    } else {
                        overlay.style.top = '50%';
                        overlay.style.bottom = 'auto';
                        overlay.style.transform = 'translate(-50%, -50%)';
                    }
                }
            } else {
                overlay.style.display = 'none';
            }
        }

        // Helper: hex to rgb
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '0, 0, 0';
        }

        // Rich text toolbar functions
        function toggleStyle(style) {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            // Use execCommand which properly handles overlapping selections
            // and preserves existing formatting better than manual DOM manipulation
            document.execCommand(style === 'bold' ? 'bold' : 'italic', false, null);

            // Update the preview video overlay to show the change
            updateSubtitlePreview();

            // Save the formatting for the current cue
            saveCurrentCueFormatting();
        }

        function applyColor(color) {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            // Use execCommand which properly handles overlapping selections
            // styleWithCSS=false gives us <b> tags instead of <span style="font-weight: bold;">
            document.execCommand('styleWithCSS', false, false);
            document.execCommand('foreColor', false, color);

            // Update the preview video overlay to show the change
            updateSubtitlePreview();

            // Save the formatting for the current cue
            saveCurrentCueFormatting();
        }

        function applySize(multiplier) {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;
            if (selection.toString().trim().length === 0) return;

            // Find current font size value (1-7 scale)
            let currentSize = 3; // Default normal size
            let node = selection.anchorNode;
            while (node && node !== editor) {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    // Check for <font size="X"> tags
                    if (node.nodeName === 'FONT' && node.getAttribute('size')) {
                        currentSize = parseInt(node.getAttribute('size'));
                        break;
                    }
                    // Check for span with font-size
                    if (node.nodeName === 'SPAN' && node.style?.fontSize) {
                        // Approximate conversion from em to 1-7 scale
                        const match = node.style.fontSize.match(/([\d.]+)/);
                        if (match) {
                            const em = parseFloat(match[1]);
                            if (em < 0.8) currentSize = 1;
                            else if (em < 1.0) currentSize = 2;
                            else if (em < 1.3) currentSize = 3;
                            else if (em < 1.6) currentSize = 4;
                            else if (em < 1.9) currentSize = 5;
                            else if (em < 2.2) currentSize = 6;
                            else currentSize = 7;
                            break;
                        }
                    }
                }
                node = node.parentNode;
            }

            // Calculate new size (clamp to 1-7 range)
            let newSize = currentSize + (multiplier > 1 ? 1 : -1);
            if (newSize < 1) newSize = 1;
            if (newSize > 7) newSize = 7;

            // Apply the size
            document.execCommand('fontSize', false, newSize.toString());

            editor.focus();
            updateSubtitlePreview();
            saveCurrentCueFormatting();
        }

        function removeFormatting() {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);

                // Only apply if there's actual text selected
                if (range.toString().trim().length > 0) {
                    // Remove all formatting using execCommand
                    document.execCommand('removeFormat', false, null);
                }
            }

            // Update the preview video overlay to show the change
            updateSubtitlePreview();

            // Save the formatting for the current cue
            saveCurrentCueFormatting();
        }

        // Save formatting for the current cue
        async function saveCurrentCueFormatting() {
            if (!currentCueInfo) {
// console.log('‚ùå saveCurrentCueFormatting: No currentCueInfo');
                return;
            }

            const editor = document.getElementById('subtitle-text');

            // Save the actual HTML as the source of truth
            // We'll store the HTML and parse it when needed
            // Use sequence as key (stable SRT sequence number)
            const key = currentCueInfo.sequence;

            // CRITICAL: Cannot save without sequence number (cue matching failed)
            if (key === null) {
                console.error('‚ùå Cannot save formatting: sequence number is null');
                console.error('   allThemeCues.length:', allThemeCues.length);
                console.error('   currentCueInfo:', currentCueInfo);
                // Try to reload cues and retry once
                if (allThemeCues.length === 0) {
                    console.warn('‚ö†Ô∏è allThemeCues is empty, attempting to load...');
                    await loadThemeCues();
                    // Retry after loading
                    const retryCue = allThemeCues.find(cue =>
                        cue.start === currentCueInfo.timestamp &&
                        cue.end === currentCueInfo.end &&
                        cue.text === currentCueInfo.text
                    );
                    if (retryCue && retryCue.sequence) {
                        currentCueInfo.sequence = retryCue.sequence;
                        console.log('‚úÖ Found sequence after reload:', retryCue.sequence);
                        // Recursively call save after updating sequence
                        return await saveCurrentCueFormatting();
                    }
                }
                return; // Cannot save without sequence
            }

            allCueFormatting[key] = {
                sequence: key,
                timestamp: currentCueInfo.timestamp,
                html: editor.innerHTML,
                _text: currentCueInfo.text  // Store text for debugging
            };

            console.log('üíæ Saved formatting for sequence', key, `(${currentCueInfo.timestamp})`);
            console.log('   Text:', currentCueInfo.text.substring(0, 50));
            console.log('   HTML:', editor.innerHTML.substring(0, 100));

            // Also extract simplified formatting info for preview
            const bold = editor.querySelector('strong') !== null;
            const italic = editor.querySelector('em') !== null;

            // Extract color - check both font tags and span styles
            let color = null;
            const colorSpan = editor.querySelector('span[style*="color"]');
            if (colorSpan && colorSpan.style.color) {
                color = colorSpan.style.color;
            } else {
                // Check for font tag with color attribute
                const fontTag = editor.querySelector('font[color]');
                if (fontTag && fontTag.color) {
                    color = fontTag.color;
                }
            }

            // Check for font size in multiple formats
            let size = null;

            // Check span elements with font-size in em
            const sizeSpan = editor.querySelector('span[style*="font-size"]');
            if (sizeSpan && sizeSpan.style.fontSize) {
                // Check for em units first
                const emMatch = sizeSpan.style.fontSize.match(/([\d.]+)em/);
                if (emMatch) {
                    size = parseFloat(emMatch[1]);
                } else {
                    // If not em, it's probably pixels - convert back to em relative to base font size
                    // Base font size is typically 16px in browsers
                    const pxMatch = sizeSpan.style.fontSize.match(/([\d.]+)px/);
                    if (pxMatch) {
                        size = parseFloat(pxMatch[1]) / 16; // Convert to em (relative to 16px base)
                    }
                }
            }

            // Also check for HTML font tags (fallback from execCommand)
            if (!size) {
                const fontTag = editor.querySelector('font[size]');
                if (fontTag && fontTag.size) {
                    // HTML font size is 1-7, map to multipliers: 1=0.5, 2=0.7, 3=0.9, 4=1.0, 5=1.2, 6=1.4, 7=1.6
                    const fontSizeMap = { '1': 0.5, '2': 0.7, '3': 0.9, '4': 1.0, '5': 1.2, '6': 1.4, '7': 1.6 };
                    size = fontSizeMap[fontTag.size];
                }
            }

            allCueFormatting[key].bold = bold;
            allCueFormatting[key].italic = italic;
            allCueFormatting[key].color = color;
            allCueFormatting[key].size = size;

            // Get current position from dropdown
            const positionSelect = document.getElementById('subtitle-position');
            const position = positionSelect ? positionSelect.value : null;
            allCueFormatting[key].position = position;

            // Save custom position and alignment if set
            if (customPosition) {
                // Scale coordinates from preview to output resolution
                const previewVideo = document.getElementById('preview-video');
                const scaleX = 1080 / (previewVideo?.offsetWidth || 281);
                const scaleY = 1920 / (previewVideo?.offsetHeight || 500);

                allCueFormatting[key].customPosition = {
                    left: customPosition.left * scaleX,
                    top: customPosition.top * scaleY,
                    centerX: customPosition.centerX ? customPosition.centerX * scaleX : null,
                    width: customPosition.width ? customPosition.width * scaleX : null
                };
            }
            allCueFormatting[key].horizontalAlign = horizontalAlign;
            allCueFormatting[key].verticalAlign = verticalAlign;

            subtitleFormatting = { ...allCueFormatting[key] };

            // Debug: log what's being saved
// console.log('üíæ Saving formatting for', currentCueInfo.start);
// console.log('  HTML:', editor.innerHTML.substring(0, 150));
// console.log('  ‚Üí bold:', bold, 'italic:', italic, 'color:', color?.substring(0, 20), 'size:', size, 'position:', position);

            // Show saving indicator
            const indicator = document.getElementById('preview-autosave-indicator');
            indicator.textContent = '‚è≥ Saving...';
            indicator.classList.add('show', 'saving');

            // Save to server
            try {
                const response = await fetch('/api/save-subtitle-formatting', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        formatting: allCueFormatting
                    })
                });

                if (!response.ok) throw new Error('Failed to save formatting');

                indicator.textContent = '‚úì Saved';
                indicator.classList.remove('saving');

                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 2000);
            } catch (error) {
// console.error('Failed to save formatting:', error);
                indicator.textContent = '‚úó Save failed';
                indicator.classList.remove('saving');
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 2000);
            }
        }

        // Event listeners for subtitle settings
        document.getElementById('subtitle-text').addEventListener('input', () => {
            updateSubtitlePreview();
            // Only auto-save if this is a user edit, not a programmatic update
            if (!isProgrammaticUpdate) {
                autoSaveSubtitle(); // Auto-save subtitle edits
            }
        });
        document.getElementById('subtitle-font').addEventListener('change', updateSubtitlePreview);
        document.getElementById('subtitle-size').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-color').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-bg').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-bg-opacity').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-position').addEventListener('change', async () => {
            const newPosition = document.getElementById('subtitle-position').value;
            await handlePositionChange(newPosition);
        });

        // Position mode button event listeners
        document.querySelectorAll('.position-mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                setPositionMode(mode);
            });
        });

        // Horizontal align button event listeners
        document.querySelectorAll('.align-btn[data-align]').forEach(btn => {
            btn.addEventListener('click', async () => {
                const align = btn.dataset.align;
                horizontalAlign = align;
                updateAlignButtons(align, verticalAlign);
                await applyAlignment();
            });
        });

        // Vertical align button event listeners
        document.querySelectorAll('.align-btn[data-valign]').forEach(btn => {
            btn.addEventListener('click', async () => {
                const valign = btn.dataset.valign;
                verticalAlign = valign;
                updateAlignButtons(horizontalAlign, valign);
                await applyAlignment();
            });
        });

        // Custom color picker event listener
        const customColorPicker = document.getElementById('custom-color-picker');
        customColorPicker.addEventListener('input', (e) => {
            const color = e.target.value;
            applyColor(color);
            // Update CSS variable for color preview
            document.querySelector('.color-picker-wrapper').style.setProperty('--current-color', color);
        });

        customColorPicker.addEventListener('change', (e) => {
            // Save formatting when color selection is complete
            saveCurrentCueFormatting();
        });

        // Update align button visual states
        function updateAlignButtons(hAlign, vAlign) {
            horizontalAlign = hAlign;
            verticalAlign = vAlign;

            // Update horizontal buttons
            document.querySelectorAll('.align-btn[data-align]').forEach(btn => {
                if (btn.dataset.align === hAlign) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Update vertical buttons
            document.querySelectorAll('.align-btn[data-valign]').forEach(btn => {
                if (btn.dataset.valign === vAlign) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        // Apply alignment to subtitle
        async function applyAlignment() {
            const overlay = document.getElementById('subtitle-overlay');
            const parentRect = overlay.parentElement.getBoundingClientRect();

            // Calculate position based on alignment
            let newLeft, newTop;

            // Horizontal alignment
            if (customPosition && customPosition.width) {
                // Use custom width if available
                if (horizontalAlign === 'left') {
                    newLeft = customPosition.width / 2;
                } else if (horizontalAlign === 'right') {
                    newLeft = parentRect.width - customPosition.width / 2;
                } else {
                    newLeft = parentRect.width / 2;
                }
            } else {
                // Default to center
                newLeft = parentRect.width / 2;
            }

            // Vertical alignment
            if (verticalAlign === 'top') {
                newTop = 20;
            } else if (verticalAlign === 'bottom') {
                newTop = parentRect.height - 60;
            } else {
                newTop = parentRect.height / 2;
            }

            // Apply position
            overlay.style.left = `${newLeft}px`;
            overlay.style.top = `${newTop}px`;
            overlay.style.bottom = 'auto';
            overlay.style.transform = 'translate(-50%, -50%)';

            // Update custom position
            customPosition = {
                left: newLeft - (customPosition?.width || overlay.offsetWidth) / 2,
                top: newTop,
                width: customPosition?.width || overlay.offsetWidth,
                centerX: newLeft
            };

            // Clear manual position flag so preset positioning doesn't override
            hasManualPosition = true;

            // Save the formatting
            if (positionMode === 'global') {
                await saveGlobalPosition('custom');
            } else {
                await saveCurrentCueFormatting();
            }
        }

        // Theme name editing
        const themeNameElement = document.getElementById('theme-name');
        let originalThemeName = '';

        themeNameElement.addEventListener('focus', () => {
            originalThemeName = themeNameElement.textContent;
        });

        themeNameElement.addEventListener('blur', () => {
            const newName = themeNameElement.textContent.trim();
            if (newName && newName !== originalThemeName) {
                // Save the new name
                themeData.title = newName;
                autoSaveTheme();
                // Update header too
                document.getElementById('header-theme-name').textContent = newName;
            } else if (!newName) {
                // Revert if empty
                themeNameElement.textContent = originalThemeName;
            }
        });

        themeNameElement.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                themeNameElement.blur();
            } else if (e.key === 'Escape') {
                themeNameElement.textContent = originalThemeName;
                themeNameElement.blur();
            }
        });

        // Subtitles toggle
        document.getElementById('subtitles-toggle').addEventListener('change', (e) => {
            const track = originalVideo.textTracks[0];
            if (track) {
                track.mode = e.target.checked ? 'showing' : 'hidden';
            }
        });

        // Overlay toggle
        document.getElementById('overlay-toggle').addEventListener('change', (e) => {
            const overlay = document.getElementById('shorts-overlay');
            if (e.target.checked) {
                overlay.classList.remove('hidden');
            } else {
                overlay.classList.add('hidden');
            }
        });

        // Karaoke highlighting toggle
        async function toggleKaraoke(enabled) {
            // Show/hide style controls based on karaoke state
            const styleControls = document.getElementById('karaoke-style-controls');
            if (enabled) {
                styleControls.style.display = 'flex';
            } else {
                styleControls.style.display = 'none';
            }

            // If enabling karaoke, check if word timestamps exist
            if (enabled) {
                try {
                    const response = await fetch(`/api/check-word-timestamps?folder=${folderNumber}`);
                    const data = await response.json();

                    if (!data.exists) {
                        // Word timestamps don't exist - ask user to create them
                        const message = `Word timestamps are required for karaoke highlighting.\n\n` +
                                       `This will transcribe the video again to extract word-level timing data.\n\n` +
                                       `‚è±Ô∏è Estimated time: ${data.video_duration || 'a few minutes'}\n\n` +
                                       `Create word timestamps now?`;

                        if (!confirm(message)) {
                            // User cancelled - reset toggle and return
                            document.getElementById('karaoke-toggle').checked = false;
                            return;
                        }

                        // User confirmed - show progress and start transcription
                        const loadingDiv = document.getElementById('loading');
                        const contentDiv = document.getElementById('content');
                        loadingDiv.classList.remove('hidden');
                        loadingDiv.innerHTML = 'üé§ Creating word timestamps...<br><small>This may take a few minutes depending on video length.</small>';
                        contentDiv.classList.add('hidden');

                        try {
                            const transcribeResponse = await fetch('/api/create-word-timestamps', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ folder: folderNumber })
                            });

                            if (!transcribeResponse.ok) {
                                throw new Error('Failed to create word timestamps');
                            }

                            const transcribeData = await transcribeResponse.json();
                            if (transcribeData.error) {
                                throw new Error(transcribeData.error);
                            }

                            loadingDiv.innerHTML = '‚úÖ Word timestamps created!<br>Regenerating subtitles with karaoke...';
                            // Reload word timestamps for preview
                            await loadWordTimestamps();
                        } catch (error) {
                            loadingDiv.innerHTML = '‚ùå Failed to create word timestamps:<br>' + error.message;
                            setTimeout(() => {
                                loadingDiv.classList.add('hidden');
                                contentDiv.classList.remove('hidden');
                                document.getElementById('karaoke-toggle').checked = false;
                            }, 3000);
                            return;
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error checking word timestamps:', error);
                    // Continue anyway - the server will handle missing timestamps
                }
            }

            karaokeEnabled = enabled;
            console.log('üé§ Karaoke highlighting:', enabled ? 'ENABLED' : 'DISABLED');

            // Save karaoke setting to server
            try {
                const response = await fetch('/api/save-karaoke-setting', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        enabled: enabled
                    })
                });

                if (!response.ok) {
                    console.warn('‚ö†Ô∏è Failed to save karaoke setting');
                }
            } catch (error) {
                console.error('‚ùå Error saving karaoke setting:', error);
            }

            // Show toast and regenerate ASS files with new karaoke setting
            showToast(`üé§ Regenerating subtitles with karaoke ${enabled ? 'enabled' : 'disabled'}...`, 'info');

            // Regenerate ASS files with new karaoke setting
            try {
                const response = await fetch('/api/regenerate-ass', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        karaoke: enabled
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to regenerate ASS');
                }

                // Show success message
                showToast(`‚úÖ Karaoke ${enabled ? 'enabled' : 'disabled'} successfully!`, 'success');
                console.log(`‚úÖ Karaoke ${enabled ? 'enabled' : 'disabled'}, ASS regenerated`);
            } catch (error) {
                console.error('‚ùå Error regenerating ASS:', error);
                showToast('‚ùå Failed to update karaoke setting', 'error');
                // Reset toggle on error
                document.getElementById('karaoke-toggle').checked = !enabled;
            }
        }

        // Regenerate ASS file with current karaoke settings (for mode/font size changes)
        async function regenerateAssWithCurrentSettings() {
            console.log('üé§ regenerateAssWithCurrentSettings called, karaokeEnabled:', karaokeEnabled);

            // Only regenerate if karaoke is enabled
            if (!karaokeEnabled) {
                console.log('   ‚ö†Ô∏è Karaoke not enabled, skipping regeneration');
                return;
            }

            // Show toast message
            showToast('üé§ Regenerating subtitles with new karaoke settings...', 'info');

            console.log('   üì° Calling /api/regenerate-ass...');

            try {
                const response = await fetch('/api/regenerate-ass', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        karaoke: true
                    })
                });

                console.log('   üì° Response status:', response.status);

                if (!response.ok) {
                    throw new Error('Failed to regenerate ASS');
                }

                const result = await response.json();
                console.log('   ‚úÖ Regeneration result:', result);

                // Show success message
                showToast('‚úÖ Subtitles regenerated successfully!', 'success');
                console.log('   ‚úÖ ASS file regenerated, no page reload needed');
            } catch (error) {
                console.error('‚ùå Error regenerating ASS:', error);
                showToast('‚ùå Failed to update karaoke settings', 'error');
            }
        }

        // ============================================
        // Canvas + FFmpeg Karaoke Export Functions
        // ============================================

        let ffmpegLoaded = false;
        let ffmpegInstance = null;

        // Load ffmpeg.wasm library
        async function loadFFmpeg() {
            if (ffmpegLoaded && ffmpegInstance) {
                return ffmpegInstance;
            }

            // Check for SharedArrayBuffer support
            if (typeof SharedArrayBuffer === 'undefined') {
                throw new Error('SharedArrayBuffer is not available. Please ensure the server has COOP/COEP headers set.');
            }

            showToast('Loading ffmpeg.wasm... (~25MB one-time download)', 'info');

            try {
                // FFmpeg and fetchFile are globals from the UMD builds
                const { FFmpeg } = window.FFmpegWASM || { FFmpeg: window.FFmpeg };
                const FFmpegClass = typeof FFmpeg !== 'undefined' ? FFmpeg : window.FFmpeg;
                const fetchFileFunc = window.fetchFile;

                ffmpegInstance = new FFmpegClass();

                // Set up logging
                ffmpegInstance.on('log', ({ message }) => {
                    console.log('FFmpeg:', message);
                });

                ffmpegInstance.on('progress', ({ progress, time }) => {
                    const percent = Math.round(progress * 100) || Math.round((time / 1000000) * 100);
                    // Only show progress occasionally to avoid spam
                    if (percent % 10 === 0 || percent > 95) {
                        showToast(`FFmpeg encoding: ${percent}%`, 'info');
                    }
                });

                // Load ffmpeg.wasm core
                await ffmpegInstance.load({
                    coreURL: 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.js',
                });

                ffmpegLoaded = true;
                showToast('ffmpeg.wasm loaded successfully!', 'success');
                return ffmpegInstance;

            } catch (error) {
                console.error('Failed to load ffmpeg.wasm:', error);
                showToast('Failed to load ffmpeg.wasm: ' + error.message, 'error');
                throw error;
            }
        }

        // Generate frames from canvas
        async function generateCanvasFrames(canvas, themeStart, themeEnd) {
            const frames = [];
            const fps = 30;
            const duration = themeEnd - themeStart;
            const totalFrames = Math.floor(duration * fps);

            const previewVideo = document.getElementById('preview-video');

            // Fetch subtitle cues for this theme to get proper text at each time point
            let subtitleCues = [];
            try {
                const response = await fetch(`/api/theme-subtitles/${folderNumber}/${themeNumber}`);
                if (response.ok) {
                    const data = await response.json();
                    subtitleCues = data.cues || [];
                }
            } catch (error) {
                console.warn('Could not fetch subtitle cues:', error);
            }

            // Helper function to get subtitle text at a given time
            function getSubtitleTextAtTime(time) {
                for (const cue of subtitleCues) {
                    if (time >= cue.start && time <= cue.end) {
                        return cue.text;
                    }
                }
                return '';
            }

            // Helper function to seek video and wait for frame to be ready
            function seekVideoAndWait(time) {
                return new Promise((resolve) => {
                    const onSeeked = () => {
                        previewVideo.removeEventListener('seeked', onSeeked);
                        // Small delay to ensure frame is rendered
                        setTimeout(resolve, 50);
                    };
                    previewVideo.addEventListener('seeked', onSeeked);
                    previewVideo.currentTime = time;
                });
            }

            // Ensure canvas renderer is initialized
            if (!canvasRenderer) {
                const settings = {
                    mode: document.getElementById('karaoke-mode')?.value || 'normal',
                    fontSize: parseInt(document.getElementById('subtitle-size')?.value || '48'),
                    textColor: document.getElementById('highlight-text-color')?.value || '#ffff00',
                    past_color: document.getElementById('past-color')?.value || '#808080',
                    font_name: document.getElementById('subtitle-font')?.value || 'Arial',
                    font_weight: document.getElementById('highlight-font-weight')?.value || 'bold'
                };
                canvasRenderer = new KaraokeCanvasRenderer(canvas, previewVideo, wordTimestamps, settings);
            }

            // Store current video time to restore later
            const originalTime = previewVideo.currentTime;
            const wasPaused = previewVideo.paused;

            // Pause video for frame generation
            previewVideo.pause();

            for (let frame = 0; frame < totalFrames; frame++) {
                const currentTime = themeStart + (frame / fps);

                // Seek video to this time
                await seekVideoAndWait(currentTime);

                // Get subtitle text for this specific time
                const subtitleText = getSubtitleTextAtTime(currentTime);

                // Render frame (video is now at correct time)
                canvasRenderer.renderFrame(currentTime, subtitleText);

                // Capture frame as ArrayBuffer
                const blob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/png');
                });

                frames.push(await blob.arrayBuffer());

                // Show progress every 30 frames
                if (frame % 30 === 0) {
                    const progress = ((frame + 1) / totalFrames) * 100;
                    showToast(`Generating frames: ${progress.toFixed(0)}%`, 'info');

                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            // Restore video state
            await seekVideoAndWait(originalTime);
            if (!wasPaused) {
                previewVideo.play();
            }

            return frames;
        }

        // Export canvas karaoke video - generate frames client-side, encode server-side
        async function exportCanvasKaraokeVideo() {
            const previewVideo = document.getElementById('preview-video');

            if (!previewVideo) {
                showToast('Preview video not found', 'error');
                return;
            }

            // Check if word timestamps exist
            if (!wordTimestamps || wordTimestamps.length === 0) {
                showToast('No word timestamps available. Please enable karaoke first.', 'error');
                return;
            }

            // Get theme timing
            const themeStart = parseFloat(previewVideo.dataset.themeStart);
            const themeEnd = parseFloat(previewVideo.dataset.themeEnd);
            const duration = themeEnd - themeStart;

            if (!duration || duration <= 0) {
                showToast('Invalid theme duration', 'error');
                return;
            }

            try {
                // Get settings
                const settings = {
                    mode: document.getElementById('karaoke-mode')?.value || 'normal',
                    fontSize: parseInt(document.getElementById('subtitle-size')?.value || '48'),
                    textColor: document.getElementById('highlight-text-color')?.value || '#ffff00',
                    pastColor: document.getElementById('past-color')?.value || '#808080',
                    fontName: document.getElementById('subtitle-font')?.value || 'Arial',
                    fontWeight: document.getElementById('highlight-font-weight')?.value || 'bold'
                };

                // Start export (returns immediately with job_id)
                const startResponse = await fetch('/api/encode-canvas-karaoke', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        settings: settings
                    })
                });

                if (!startResponse.ok) {
                    const error = await startResponse.json();
                    throw new Error(error.error || 'Failed to start export');
                }

                const startResult = await startResponse.json();
                const jobId = startResult.job_id;

                // Show progress toast
                const progressToast = document.createElement('div');
                progressToast.className = 'karaoke-toast';
                progressToast.id = 'export-progress-toast';
                progressToast.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #333; color: white; padding: 15px 20px; border-radius: 8px; z-index: 10000; max-width: 400px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); border-left: 4px solid #2196F3;';
                progressToast.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div class="spinner" style="width: 20px; height: 20px; border: 2px solid #ffffff33; border-top-color: #2196F3; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <div style="flex: 1;">
                            <div style="font-weight: 600; margin-bottom: 4px;">üé¨ Rendering Canvas Karaoke</div>
                            <div id="export-stage" style="font-size: 12px; opacity: 0.8;">Starting...</div>
                            <div style="background: rgba(255,255,255,0.1); height: 4px; border-radius: 2px; margin-top: 8px; overflow: hidden;">
                                <div id="export-progress-bar" style="background: #2196F3; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="export-progress-text" style="font-size: 11px; opacity: 0.6; margin-top: 4px;">0%</div>
                        </div>
                    </div>
                    <style>
                        @keyframes spin { to { transform: rotate(360deg); } }
                    </style>
                `;
                document.body.appendChild(progressToast);

                // Poll for progress
                const pollInterval = setInterval(async () => {
                    try {
                        const progressResponse = await fetch(`/api/canvas-karaoke-progress/${jobId}`);
                        if (!progressResponse.ok) {
                            clearInterval(pollInterval);
                            throw new Error('Failed to get progress');
                        }

                        const progressData = await progressResponse.json();

                        // Update progress display
                        const stageEl = document.getElementById('export-stage');
                        const progressTextEl = document.getElementById('export-progress-text');
                        const progressBarEl = document.getElementById('export-progress-bar');

                        if (stageEl) {
                            stageEl.textContent = progressData.message || progressData.stage;
                        }
                        if (progressTextEl) {
                            progressTextEl.textContent = `${Math.round(progressData.progress)}%`;
                        }
                        if (progressBarEl) {
                            progressBarEl.style.width = `${Math.max(0, Math.min(100, progressData.progress))}%`;
                        }

                        // Check if complete or error
                        if (progressData.complete) {
                            clearInterval(pollInterval);
                            if (progressToast) progressToast.remove();

                            showToast(`‚úÖ Export complete!`, 'success');
                            showToast(`üìÅ Saved to: ${progressData.output_path}`, 'success');

                            // Provide download link
                            setTimeout(() => {
                                const link = document.createElement('a');
                                link.href = `/api/download-canvas-karaoke/${folderNumber}/${themeNumber}`;
                                link.download = `theme_${themeNumber}_canvas_karaoke.mp4`;
                                link.textContent = '‚¨áÔ∏è Click here to download';
                                link.style.display = 'block';
                                link.style.textAlign = 'center';
                                link.style.marginTop = '10px';
                                link.style.color = '#4CAF50';
                                link.style.textDecoration = 'none';
                                link.style.padding = '10px';
                                link.style.background = 'rgba(76, 175, 80, 0.1)';
                                link.style.borderRadius = '4px';

                                const container = document.querySelector('.karaoke-toast:last-child');
                                if (container) {
                                    container.appendChild(link);
                                }
                            }, 1000);
                        } else if (progressData.error) {
                            clearInterval(pollInterval);
                            if (progressToast) progressToast.remove();
                            throw new Error(progressData.error);
                        }

                    } catch (error) {
                        clearInterval(pollInterval);
                        if (progressToast) progressToast.remove();
                        console.error('Progress polling error:', error);
                    }
                }, 500);  // Poll every 500ms

            } catch (error) {
                console.error('Export error:', error);
                showToast('Export failed: ' + error.message, 'error');
            }
        }

        // Export button event listener
        document.getElementById('export-canvas-video')?.addEventListener('click', exportCanvasKaraokeVideo);

        // Toast notification system
        function showToast(message, type = 'info') {
            // Remove existing toast if any
            const existingToast = document.querySelector('.karaoke-toast');
            if (existingToast) {
                existingToast.remove();
            }

            // Create toast element
            const toast = document.createElement('div');
            toast.className = 'karaoke-toast';
            toast.textContent = message;

            // Style based on type
            const styles = {
                info: { background: '#2196F3', icon: '‚ÑπÔ∏è' },
                success: { background: '#4CAF50', icon: '‚úÖ' },
                error: { background: '#f44336', icon: '‚ùå' }
            };

            const style = styles[type] || styles.info;
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${style.background};
                color: white;
                padding: 16px 24px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-size: 14px;
                font-weight: 500;
                animation: slideIn 0.3s ease-out;
                max-width: 400px;
            `;

            // Add to page
            document.body.appendChild(toast);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Add CSS for toast animations
        const toastStyle = document.createElement('style');
        toastStyle.textContent = `
            @keyframes slideIn {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            @keyframes slideOut {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(100%);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(toastStyle);

        document.getElementById('karaoke-toggle').addEventListener('change', async (e) => {
            await toggleKaraoke(e.target.checked);
        });

        // Load karaoke setting on page load
        async function loadKaraokeSetting() {
            try {
                // Check if word timestamps exist first
                const checkResponse = await fetch(`/api/check-word-timestamps?folder=${folderNumber}`);
                let wordTimestampsExist = false;
                if (checkResponse.ok) {
                    const checkData = await checkResponse.json();
                    wordTimestampsExist = checkData.exists;
                }

                // Get karaoke setting from server
                const response = await fetch(`/api/get-karaoke-setting?folder=${folderNumber}&theme=${themeNumber}`);
                if (response.ok) {
                    const data = await response.json();
                    // Only enable karaoke if both setting is true AND word timestamps exist
                    karaokeEnabled = data.enabled && wordTimestampsExist;
                    document.getElementById('karaoke-toggle').checked = karaokeEnabled;
                    console.log('üé§ Karaoke setting loaded:', karaokeEnabled ? 'ENABLED' : 'DISABLED',
                               wordTimestampsExist ? '(word timestamps exist)' : '(no word timestamps)');

                    // Show/hide style controls based on karaoke state
                    const styleControls = document.getElementById('karaoke-style-controls');
                    console.log('Karaoke enabled:', karaokeEnabled, 'styleControls element:', styleControls, 'current display:', styleControls?.style.display);
                    if (karaokeEnabled) {
                        styleControls.style.display = 'flex';
                        console.log('‚úÖ Karaoke style controls shown, display is now:', styleControls.style.display);
                        // Load the saved highlight style
                        await loadHighlightStyle();
                    } else {
                        styleControls.style.display = 'none';
                        console.log('‚ùå Karaoke style controls hidden');
                    }
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Could not load karaoke setting, using default (disabled)');
                karaokeEnabled = false;
                document.getElementById('karaoke-toggle').checked = false;
            }
        }

        // Load word timestamps for preview karaoke highlighting
        async function loadWordTimestamps() {
            if (wordTimestamps !== null) {
                return wordTimestamps; // Already loaded
            }

            try {
                const response = await fetch(`/api/word-timestamps/${folderNumber}`);
                if (response.ok) {
                    const data = await response.json();
                    wordTimestamps = data.words || [];
                    console.log(`üìù Loaded ${wordTimestamps.length} word timestamps for preview`);
                    return wordTimestamps;
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Could not load word timestamps:', error);
            }

            wordTimestamps = [];
            return wordTimestamps;
        }

        // Update word highlighting in preview based on current video time
        // This uses a POSITIONAL approach, not text matching:
        // - Counts how many word timestamps occur during the current subtitle
        // - Highlights the Nth word in the subtitle based on that count
        // - Works regardless of language mismatches between audio and subtitles
        let lastSubtitleText = ''; // Track subtitle changes
        let subtitleWordCount = 0; // How many words have been spoken during current subtitle
        let lastProcessedWordIndex = -1; // Last word timestamp index we processed

        async function updatePreviewWordHighlighting(currentTime) {
            // Only highlight if karaoke is enabled and word timestamps exist
            if (!karaokeEnabled || !wordTimestamps || wordTimestamps.length === 0) {
                return;
            }

            // Get current subtitle text from the text element
            const textEl = document.getElementById('subtitle-preview-text');
            if (!textEl || !textEl.textContent.trim()) {
                return;
            }

            const subtitleText = textEl.textContent.trim();

            // Reset counter when subtitle changes
            if (lastSubtitleText !== subtitleText) {
                lastSubtitleText = subtitleText;
                subtitleWordCount = 0;
                lastProcessedWordIndex = -1;
                // Remove all highlights when subtitle changes
                document.querySelectorAll('.word-highlight').forEach(el => {
                    el.classList.remove('word-highlight');
                });
            }

            // Find the word currently being spoken based on time
            const currentSpokenWordIndex = wordTimestamps.findIndex(w =>
                currentTime >= w.start && currentTime < w.end
            );

            // No word being spoken right now
            if (currentSpokenWordIndex === -1) {
                return;
            }

            // Only process if this is a new word we haven't processed yet
            if (currentSpokenWordIndex > lastProcessedWordIndex) {
                // Count how many words have been spoken during this subtitle
                // Find the first word timestamp that occurred during this subtitle
                // For simplicity: we just increment our counter each time we get a new word
                subtitleWordCount++;
                lastProcessedWordIndex = currentSpokenWordIndex;

                // Remove previous highlight
                document.querySelectorAll('.word-highlight').forEach(el => {
                    el.classList.remove('word-highlight');
                });

                // Wrap words in spans if not already done
                if (!textEl.innerHTML.includes('data-word-index')) {
                    const words = subtitleText.split(/\s+/);
                    const wrappedHTML = words.map((w, i) => {
                        return `<span class="word-span" data-word-index="${i}">${w}</span>`;
                    }).join(' ');
                    textEl.innerHTML = wrappedHTML;
                }

                // Get all word elements
                const wordElements = textEl.querySelectorAll('.word-span');

                // Highlight the word at position = subtitleWordCount (1-based to 0-based)
                const targetIndex = subtitleWordCount - 1;
                if (targetIndex >= 0 && targetIndex < wordElements.length) {
                    wordElements[targetIndex].classList.add('word-highlight');
                }
            }
        }

        // Add CSS for word highlighting (using CSS variables for dynamic updates)
        const style = document.createElement('style');
        style.id = 'highlight-style';
        style.textContent = `
            .word-highlight {
                color: var(--highlight-text-color, #ffff00) !important;
                text-shadow: 0 0 var(--highlight-glow-blur, 10px) var(--highlight-glow-color, rgba(255, 255, 0, 0.8));
                font-weight: var(--highlight-font-weight, bold);
                transition: all 0.1s ease-in-out;
            }
        `;
        document.head.appendChild(style);

        // Update highlight style dynamically
        function updateHighlightStyle() {
            const textColor = document.getElementById('highlight-text-color').value;
            const glowColor = document.getElementById('highlight-glow-color').value;
            const glowBlur = document.getElementById('highlight-glow-blur').value;
            const fontWeight = document.getElementById('highlight-font-weight').value;

            // Convert hex glow color to rgba with opacity
            const r = parseInt(glowColor.slice(1, 3), 16);
            const g = parseInt(glowColor.slice(3, 5), 16);
            const b = parseInt(glowColor.slice(5, 7), 16);
            const glowColorRgba = `rgba(${r}, ${g}, ${b}, 0.8)`;

            // Update CSS variables on the root
            document.documentElement.style.setProperty('--highlight-text-color', textColor);
            document.documentElement.style.setProperty('--highlight-glow-color', glowColorRgba);
            document.documentElement.style.setProperty('--highlight-glow-blur', glowBlur + 'px');
            document.documentElement.style.setProperty('--highlight-font-weight', fontWeight);

            // Update blur value display
            document.getElementById('highlight-glow-blur-value').textContent = glowBlur + 'px';
        }

        // Save highlight style to server
        async function saveHighlightStyle() {
            // Convert font scale from percentage to decimal
            const fontScalePercent = parseInt(document.getElementById('font-size-scale').value);
            const fontScaleDecimal = fontScalePercent / 100;

            const styleData = {
                folder: folderNumber,
                preset: document.getElementById('highlight-preset').value,
                textColor: document.getElementById('highlight-text-color').value,
                glowColor: document.getElementById('highlight-glow-color').value,
                glowBlur: document.getElementById('highlight-glow-blur').value,
                fontWeight: document.getElementById('highlight-font-weight').value,
                // Karaoke mode settings
                karaokeMode: document.getElementById('karaoke-mode').value,
                fontSizeScale: fontScaleDecimal,
                pastColor: document.getElementById('past-color').value
            };

            try {
                const response = await fetch('/api/save-highlight-style', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(styleData)
                });

                if (!response.ok) {
                    console.warn('‚ö†Ô∏è Failed to save highlight style');
                }
            } catch (error) {
                console.error('‚ùå Error saving highlight style:', error);
            }
        }

        // Load highlight style from server
        async function loadHighlightStyle() {
            try {
                const response = await fetch(`/api/get-highlight-style?folder=${folderNumber}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.style) {
                        // Apply loaded style to inputs
                        document.getElementById('highlight-text-color').value = data.style.textColor || '#ffff00';
                        document.getElementById('highlight-glow-color').value = data.style.glowColor || '#ffff00';
                        document.getElementById('highlight-glow-blur').value = data.style.glowBlur || '10';
                        document.getElementById('highlight-font-weight').value = data.style.fontWeight || 'bold';

                        // Load karaoke mode settings
                        document.getElementById('karaoke-mode').value = data.style.karaoke_mode || 'normal';

                        // Convert font scale from decimal to percentage
                        const fontScaleDecimal = data.style.font_size_scale !== undefined ? data.style.font_size_scale : 1.0;
                        const fontScalePercent = Math.round(fontScaleDecimal * 100);
                        document.getElementById('font-size-scale').value = fontScalePercent;
                        document.getElementById('font-scale-value').textContent = fontScalePercent + '%';

                        // Load past color
                        document.getElementById('past-color').value = data.style.past_color || '#808080';

                        // Use saved preset if available, otherwise try to match
                        if (data.style.preset && highlightPresets[data.style.preset]) {
                            document.getElementById('highlight-preset').value = data.style.preset;
                        } else {
                            // Check if loaded style matches any preset
                            let matchedPreset = 'custom';
                            for (const [presetName, presetValues] of Object.entries(highlightPresets)) {
                                if (data.style.textColor === presetValues.textColor &&
                                    data.style.glowColor === presetValues.glowColor &&
                                    data.style.glowBlur === presetValues.glowBlur &&
                                    data.style.fontWeight === presetValues.fontWeight) {
                                    matchedPreset = presetName;
                                    break;
                                }
                            }
                            document.getElementById('highlight-preset').value = matchedPreset;
                        }

                        // Update the actual CSS
                        updateHighlightStyle();
                    }
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Could not load highlight style, using defaults');
            }
        }

        // Reset highlight style to defaults
        function resetHighlightStyle() {
            document.getElementById('highlight-text-color').value = '#ffff00';
            document.getElementById('highlight-glow-color').value = '#ffff00';
            document.getElementById('highlight-glow-blur').value = '10';
            document.getElementById('highlight-font-weight').value = 'bold';
            document.getElementById('highlight-preset').value = 'yellow-glow';
            document.getElementById('karaoke-mode').value = 'normal';
            document.getElementById('font-size-scale').value = '100';
            document.getElementById('font-scale-value').textContent = '100%';
            document.getElementById('past-color').value = '#808080';
            updateHighlightStyle();
            saveHighlightStyle();
        }

        // Preset style definitions
        const highlightPresets = {
            'yellow-glow': { textColor: '#ffff00', glowColor: '#ffff00', glowBlur: '10', fontWeight: 'bold' },
            'red-bold': { textColor: '#ff3333', glowColor: '#ff0000', glowBlur: '8', fontWeight: 'bold' },
            'cyan-neon': { textColor: '#00ffff', glowColor: '#00ffff', glowBlur: '20', fontWeight: 'bold' },
            'green-underline': { textColor: '#00ff00', glowColor: '#00ff00', glowBlur: '12', fontWeight: 'bold' },
            'pink-soft': { textColor: '#ff69b4', glowColor: '#ff1493', glowBlur: '15', fontWeight: '500' },
            'orange-fire': { textColor: '#ff8c00', glowColor: '#ff4500', glowBlur: '18', fontWeight: 'bold' },
            'white-clean': { textColor: '#ffffff', glowColor: '#ffffff', glowBlur: '5', fontWeight: 'normal' },
            'purple-vibe': { textColor: '#da70d6', glowColor: '#9932cc', glowBlur: '16', fontWeight: 'bold' }
        };

        // Apply preset style
        function applyPresetStyle(presetName) {
            if (presetName === 'custom') return; // Don't change if custom is selected

            const preset = highlightPresets[presetName];
            if (preset) {
                document.getElementById('highlight-text-color').value = preset.textColor;
                document.getElementById('highlight-glow-color').value = preset.glowColor;
                document.getElementById('highlight-glow-blur').value = preset.glowBlur;
                document.getElementById('highlight-font-weight').value = preset.fontWeight;
                updateHighlightStyle();
                saveHighlightStyle();
            }
        }

        // Setup event listeners for karaoke controls
        console.log('üé§ Setting up karaoke control event listeners...');

        const karaokeModeSelect = document.getElementById('karaoke-mode');
        const fontSizeScaleInput = document.getElementById('font-size-scale');
        const pastColorInput = document.getElementById('past-color');

        if (karaokeModeSelect) {
            console.log('   ‚úì karaoke-mode element found');
        } else {
            console.error('   ‚úó karaoke-mode element NOT found!');
        }

        if (fontSizeScaleInput) {
            console.log('   ‚úì font-size-scale element found');
        } else {
            console.error('   ‚úó font-size-scale element NOT found!');
        }

        if (pastColorInput) {
            console.log('   ‚úì past-color element found');
        } else {
            console.error('   ‚úó past-color element NOT found!');
        }

        // Add event listeners for new karaoke controls
        // These controls affect ASS generation, so they need to regenerate the ASS file
        document.getElementById('karaoke-mode').addEventListener('change', async (e) => {
            console.log('üé§ Karaoke mode changed to:', e.target.value);
            await saveHighlightStyle();
            await regenerateAssWithCurrentSettings();
        });
        document.getElementById('font-size-scale').addEventListener('change', async (e) => {
            const percent = e.target.value;
            console.log('üé§ Font size scale changed to:', percent + '%');
            document.getElementById('font-scale-value').textContent = percent + '%';
            await saveHighlightStyle();
            await regenerateAssWithCurrentSettings();
        });
        document.getElementById('past-color').addEventListener('change', async (e) => {
            console.log('üé§ Past color changed to:', e.target.value);
            await saveHighlightStyle();
            await regenerateAssWithCurrentSettings();
        });

        // Add event listeners for style controls
        document.getElementById('highlight-preset').addEventListener('change', (e) => {
            applyPresetStyle(e.target.value);
        });

        document.getElementById('highlight-text-color').addEventListener('input', () => {
            document.getElementById('highlight-preset').value = 'custom';
            updateHighlightStyle();
            saveHighlightStyle();
        });
        document.getElementById('highlight-glow-color').addEventListener('input', () => {
            document.getElementById('highlight-preset').value = 'custom';
            updateHighlightStyle();
            saveHighlightStyle();
        });
        document.getElementById('highlight-glow-blur').addEventListener('input', () => {
            document.getElementById('highlight-preset').value = 'custom';
            updateHighlightStyle();
            saveHighlightStyle();
        });
        document.getElementById('highlight-font-weight').addEventListener('change', () => {
            document.getElementById('highlight-preset').value = 'custom';
            updateHighlightStyle();
            saveHighlightStyle();
        });
        document.getElementById('reset-highlight-style').addEventListener('click', resetHighlightStyle);

        // Canvas mode LED toggle
        document.getElementById('canvas-mode-led').addEventListener('click', async () => {
            // Trigger the existing canvas mode toggle
            document.getElementById('toggle-canvas-mode').click();
        });

        // LED hover effect
        const ledContainer = document.getElementById('canvas-mode-led');
        ledContainer.addEventListener('mouseenter', () => {
            ledContainer.style.background = canvasMode ? 'rgba(0, 255, 0, 0.25)' : 'rgba(255, 255, 255, 0.1)';
        });
        ledContainer.addEventListener('mouseleave', () => {
            updateCanvasLED(); // Reset to proper state
        });

        // Canvas mode toggle button
        document.getElementById('toggle-canvas-mode').addEventListener('click', async () => {
            canvasMode = !canvasMode;
            const btn = document.getElementById('toggle-canvas-mode');
            const canvas = document.getElementById('karaoke-canvas');
            const canvasIndicator = document.getElementById('canvas-mode-indicator');
            const previewVideo = document.getElementById('preview-video');
            const subtitleOverlay = document.getElementById('subtitle-overlay');

            if (canvasMode) {
                // Enable canvas mode
                btn.textContent = 'Canvas Preview: ON';
                btn.style.background = '#4CAF50';
                updateCanvasLED(); // Update LED state

                // Set canvas to match the video wrapper's actual pixel size
                const wrapper = canvas.parentElement;
                const rect = wrapper.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;

                console.log('[Canvas] Canvas size set to:', canvas.width, 'x', canvas.height, 'wrapper rect:', rect);

                // Show canvas overlay (video remains visible underneath)
                canvas.style.display = 'block';
                canvasIndicator.style.display = 'block';
                subtitleOverlay.style.display = 'none';

                // Remove VTT track element completely (most aggressive hiding)
                const trackElements = previewVideo.querySelectorAll('track');
                trackElements.forEach(track => {
                    track.remove();
                    console.log('[Canvas] Removed track element:', track.src);
                });

                // Disable ALL VTT subtitles tracks
                console.log('[Canvas] Disabling VTT tracks, total tracks:', previewVideo.textTracks?.length);
                if (previewVideo.textTracks) {
                    for (let i = 0; i < previewVideo.textTracks.length; i++) {
                        const track = previewVideo.textTracks[i];
                        console.log('[Canvas] Disabling track', i, 'kind:', track.kind, 'mode was:', track.mode);
                        track.mode = 'disabled';
                    }
                }

                // Also add a class to the video to hide VTT cues via CSS
                previewVideo.classList.add('canvas-mode-active');

                // Initialize canvas renderer
                if (!canvasRenderer) {
                    // Make sure word timestamps are loaded
                    await loadWordTimestamps();

                    const canvasEl = document.getElementById('karaoke-canvas');
                    const settings = {
                        mode: document.getElementById('karaoke-mode')?.value || 'normal',
                        fontSize: parseInt(document.getElementById('subtitle-size')?.value || '48'),
                        textColor: document.getElementById('highlight-text-color')?.value || '#ffff00',
                        past_color: document.getElementById('past-color')?.value || '#808080',
                        font_name: document.getElementById('subtitle-font')?.value || 'Arial',
                        font_weight: document.getElementById('highlight-font-weight')?.value || 'bold'
                    };

                    console.log('Canvas renderer: wordTimestamps =', wordTimestamps ? wordTimestamps.length : 0, 'words');
                    canvasRenderer = new KaraokeCanvasRenderer(canvasEl, previewVideo, wordTimestamps, settings);
                    console.log('‚úÖ Canvas renderer initialized');
                }

                // Render initial frame - get text from editor and highlighted word index
                if (canvasRenderer && previewVideo) {
                    const editorEl = document.getElementById('subtitle-text');

                    // Try to get text from editor first, if empty, find current cue from allThemeCues
                    let subtitleText = editorEl?.innerText?.trim() || '';

                    if (!subtitleText && allThemeCues && allThemeCues.length > 0) {
                        const currentTime = previewVideo.currentTime;
                        console.log('[Canvas Init] Looking for cue at time:', currentTime);

                        // Find the current subtitle cue based on video time
                        const currentCue = allThemeCues.find(cue => {
                            const cueStart = parseTime(cue.start);
                            const cueEnd = parseTime(cue.end);
                            const match = currentTime >= cueStart && currentTime <= cueEnd;
                            if (match) {
                                console.log('[Canvas Init] Cue match:', { cueStart, cueEnd, currentTime, text: cue.text.substring(0, 30) });
                            }
                            return match;
                        });

                        if (currentCue) {
                            subtitleText = currentCue.text;
                            console.log('[Canvas Init] Found cue from allThemeCues:', currentCue);
                        } else {
                            // Find the nearest cue for debugging
                            const nearestCue = allThemeCues.find(cue => {
                                const cueStart = parseTime(cue.start);
                                return cueStart > currentTime - 5 && cueStart < currentTime + 5;
                            });
                            console.log('[Canvas Init] No cue found at current time, nearest:', nearestCue);
                        }
                    }

                    console.log('[Canvas Init] subtitleText:', subtitleText);
                    console.log('[Canvas Init] editorEl:', editorEl);
                    console.log('[Canvas Init] canvas size:', canvas.width, 'x', canvas.height);

                    // Get highlighted word index from DOM (if any)
                    const previewEl = document.getElementById('subtitle-preview-text');
                    let highlightedWordIndex = -1;
                    const highlightedSpans = previewEl?.querySelectorAll('.word-highlight');
                    if (highlightedSpans && highlightedSpans.length > 0) {
                        highlightedWordIndex = parseInt(highlightedSpans[0].dataset.wordIndex || '-1');
                    }

                    console.log('[Canvas Init] highlightedWordIndex:', highlightedWordIndex);

                    // Use renderFrameWithHighlight for preview (transparent canvas)
                    canvasRenderer.renderFrameWithHighlight(previewVideo.currentTime, subtitleText, highlightedWordIndex);
                    console.log('[Canvas Init] renderFrameWithHighlight called');
                }

                showToast('Canvas mode enabled', 'success');
            } else {
                // Disable canvas mode
                btn.textContent = 'Canvas Preview: OFF';
                btn.style.background = '#2196F3';
                updateCanvasLED(); // Update LED state

                // Show video, hide canvas
                canvas.style.display = 'none';
                canvasIndicator.style.display = 'none';
                previewVideo.style.opacity = '1';
                subtitleOverlay.style.display = 'block';

                // Remove canvas mode class to show VTT again
                previewVideo.classList.remove('canvas-mode-active');

                // Re-enable VTT subtitles tracks
                console.log('[Canvas] Re-enabling VTT tracks');
                if (previewVideo.textTracks) {
                    for (let i = 0; i < previewVideo.textTracks.length; i++) {
                        previewVideo.textTracks[i].mode = 'showing';
                    }
                }

                showToast('Canvas mode disabled', 'info');
            }
        });

        // Lock video controls button
        document.getElementById('lock-video-btn').addEventListener('click', () => {
            videoControlsLocked = !videoControlsLocked;
            const lockBtn = document.getElementById('lock-video-btn');
            const lockIcon = document.getElementById('lock-icon');
            const subtitleOverlay = document.getElementById('subtitle-overlay');

            if (videoControlsLocked) {
                lockBtn.classList.add('locked');
                lockIcon.textContent = 'üîí';
                // Update button text
                lockBtn.innerHTML = '<span id="lock-icon">üîí</span> Unlock';
                lockBtn.title = 'Unlock video controls to disable dragging';

                // Pause video if playing when locked
                if (!previewVideo.paused) {
                    previewVideo.pause();
                }

                // Enable subtitle dragging when locked
                if (subtitleOverlay) {
                    subtitleOverlay.classList.add('draggable');
                }
            } else {
                lockBtn.classList.remove('locked');
                lockIcon.textContent = 'üîì';
                // Update button text
                lockBtn.innerHTML = '<span id="lock-icon">üîì</span> Lock';
                lockBtn.title = 'Lock video controls to enable dragging';

                // Disable subtitle dragging when unlocked
                if (subtitleOverlay) {
                    subtitleOverlay.classList.remove('draggable');
                }
            }
        });

        // Subtitle dragging functionality
        const subtitleOverlay = document.getElementById('subtitle-overlay');
        let isDraggingSubtitle = false;
        let subtitleDragStart = { x: 0, y: 0 };
        let subtitleStartPos = { left: 0, top: 0 };
        let hasManualPosition = false; // Flag to indicate manual positioning

        subtitleOverlay.addEventListener('mousedown', (e) => {
            if (!videoControlsLocked) return;

            isDraggingSubtitle = true;
            hasManualPosition = true; // Mark as having manual position

            subtitleDragStart = { x: e.clientX, y: e.clientY };

            // Get current position from computed style
            const computedStyle = window.getComputedStyle(subtitleOverlay);
            const rect = subtitleOverlay.getBoundingClientRect();
            const parentRect = subtitleOverlay.parentElement.getBoundingClientRect();

            // Store initial position relative to parent
            subtitleStartPos = {
                left: rect.left - parentRect.left,
                top: rect.top - parentRect.top
            };

            e.preventDefault();
            e.stopPropagation();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingSubtitle || !videoControlsLocked) return;

            const deltaX = e.clientX - subtitleDragStart.x;
            const deltaY = e.clientY - subtitleDragStart.y;

            const parentRect = subtitleOverlay.parentElement.getBoundingClientRect();

            // Calculate new position
            let newX = subtitleStartPos.left + deltaX;
            let newY = subtitleStartPos.top + deltaY;

            // Constrain within parent bounds with some padding
            const padding = 10;
            const maxX = parentRect.width - subtitleOverlay.offsetWidth - padding;
            const maxY = parentRect.height - subtitleOverlay.offsetHeight - padding;

            newX = Math.max(padding, Math.min(newX, maxX));
            newY = Math.max(padding, Math.min(newY, maxY));

            // Update position
            subtitleOverlay.style.left = `${newX + subtitleOverlay.offsetWidth / 2}px`;
            subtitleOverlay.style.top = `${newY}px`;
            subtitleOverlay.style.bottom = 'auto';
            subtitleOverlay.style.transform = 'translateX(-50%)';

            // Add visual border during drag to see position clearly
            subtitleOverlay.style.border = '2px solid yellow';
        });

        document.addEventListener('mouseup', async () => {
            if (isDraggingSubtitle) {
                isDraggingSubtitle = false;

                // Remove drag border
                subtitleOverlay.style.border = '';

                // Get exact position relative to parent
                const rect = subtitleOverlay.getBoundingClientRect();
                const parentRect = subtitleOverlay.parentElement.getBoundingClientRect();

                const relativeLeft = rect.left - parentRect.left;
                const relativeTop = rect.top - parentRect.top;
                const centerX = relativeLeft + rect.width / 2;

                // Store exact custom position
                customPosition = {
                    left: relativeLeft,
                    top: relativeTop,
                    width: rect.width,
                    centerX: centerX
                };

                console.log('üñ±Ô∏è Drag ended - exact position:', {
                    left: relativeLeft,
                    top: relativeTop,
                    centerX: centerX,
                    parentWidth: parentRect.width,
                    parentHeight: parentRect.height
                });

                // Determine nearest preset for dropdown
                const positionSelect = document.getElementById('subtitle-position');
                const third = parentRect.height / 3;
                if (relativeTop < third) {
                    positionSelect.value = 'top';
                } else if (relativeTop > 2 * third) {
                    positionSelect.value = 'bottom';
                } else {
                    positionSelect.value = 'middle';
                }

                // Determine horizontal alignment based on center position
                const hThird = parentRect.width / 3;
                let hAlign = 'center';
                if (centerX < hThird) {
                    hAlign = 'left';
                } else if (centerX > 2 * hThird) {
                    hAlign = 'right';
                }

                // Determine vertical alignment
                const vThird = parentRect.height / 3;
                let vAlign = 'middle';
                if (relativeTop < vThird) {
                    vAlign = 'top';
                } else if (relativeTop > 2 * vThird) {
                    vAlign = 'bottom';
                }

                // Update align button states
                updateAlignButtons(hAlign, vAlign);

                updateSubtitlePreview();

                // Save based on current position mode
                console.log('üñ±Ô∏è Drag ended, align:', hAlign, vAlign, 'mode:', positionMode);

                if (positionMode === 'global') {
                    // Save custom position for global mode
                    await saveGlobalPosition('custom');
                } else {
                    // For current mode, save exact custom position
                    await saveCurrentCueFormatting();
                }
            }
        });

        // Keyboard controls for preview video
        document.addEventListener('keydown', (e) => {
            // Only handle keyboard events when not in textarea/input or editing theme name
            if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT' || e.target.id === 'theme-name') {
                return;
            }

            // Space key for play/pause
            if (e.code === 'Space') {
                e.preventDefault();
                if (!videoControlsLocked) {
                    if (previewVideo.paused) {
                        previewVideo.play();
                    } else {
                        previewVideo.pause();
                    }
                }
                return;
            }

            // Arrow keys for seeking (only when video controls are not locked)
            if (!videoControlsLocked && (e.code === 'ArrowLeft' || e.code === 'ArrowRight')) {
                e.preventDefault();

                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd);
                const seekAmount = 5; // Seek by 5 seconds

                if (e.code === 'ArrowLeft') {
                    // Seek backward
                    previewVideo.currentTime = Math.max(themeStart, previewVideo.currentTime - seekAmount);
                } else {
                    // Seek forward
                    previewVideo.currentTime = Math.min(themeEnd, previewVideo.currentTime + seekAmount);
                }
            }
        });

        // Subtitle Editor Modal
        let themeSubtitles = []; // Store all subtitles for the theme
        const subtitleModal = document.getElementById('subtitle-modal');
        const editAllSubsBtn = document.getElementById('edit-all-subs-btn');
        const closeSubsModal = subtitleModal.querySelector('.close');
        const cancelSubsBtn = document.getElementById('cancel-subs-btn');
        const saveSubsBtn = document.getElementById('save-subs-btn');

        // Open subtitle editor modal
        editAllSubsBtn.addEventListener('click', async () => {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = 'Loading subtitles...';
            messageDiv.className = '';

            try {
                const response = await fetch(`/api/theme-subtitles/${folderNumber}/${themeNumber}`);
                if (!response.ok) throw new Error('Failed to load subtitles');

                const data = await response.json();
                themeSubtitles = data.cues;

                renderSubtitleCues();
                subtitleModal.style.display = 'block';
                messageDiv.textContent = '';
                messageDiv.className = '';
            } catch (error) {
                messageDiv.textContent = `Error: ${error.message}`;
                messageDiv.className = 'error';
            }
        });

        // Close modal handlers
        closeSubsModal.addEventListener('click', () => {
            subtitleModal.style.display = 'none';
        });

        cancelSubsBtn.addEventListener('click', () => {
            subtitleModal.style.display = 'none';
        });

        window.addEventListener('click', (e) => {
            if (e.target === subtitleModal) {
                subtitleModal.style.display = 'none';
            }
        });

        // Render subtitle cues in the modal
        function renderSubtitleCues() {
            const container = document.getElementById('subtitle-cues-container');
            container.innerHTML = '';

            themeSubtitles.forEach((cue, index) => {
                const cueDiv = document.createElement('div');
                cueDiv.className = 'subtitle-cue-item';
                cueDiv.innerHTML = `
                    <div class="cue-header">
                        <strong>#${cue.sequence}</strong>
                        <label>Start:
                            <input type="text" class="cue-time-input" data-index="${index}" data-field="start" value="${cue.start}">
                        </label>
                        <label>End:
                            <input type="text" class="cue-time-input" data-index="${index}" data-field="end" value="${cue.end}">
                        </label>
                    </div>
                    <textarea class="cue-textarea" data-index="${index}" data-field="text">${cue.text}</textarea>
                `;
                container.appendChild(cueDiv);
            });

            // Add event listeners to inputs
            container.querySelectorAll('.cue-time-input, .cue-textarea').forEach(input => {
                input.addEventListener('input', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const field = e.target.dataset.field;
                    themeSubtitles[index][field] = e.target.value;
                });
            });
        }

        // Save subtitles
        saveSubsBtn.addEventListener('click', async () => {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = 'Subtitles are saved automatically when timeline is adjusted';
            messageDiv.className = 'success';
            subtitleModal.style.display = 'none';

            setTimeout(() => {
                messageDiv.textContent = '';
                messageDiv.className = '';
            }, 3000);
        });

        // Initialize
        if (folderNumber && themeNumber) {
            loadTheme().then(() => {
                // Initialize position mode buttons after theme loads
                setPositionMode('global'); // Default to global mode
                // Load karaoke setting
                loadKaraokeSetting();
                // Load word timestamps for preview highlighting
                loadWordTimestamps();
            });
        } else {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('error').textContent = 'Missing folder or theme number';
            document.getElementById('error').classList.remove('hidden');
        }
    </script>
</body>
</html>
