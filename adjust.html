<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adjust Theme - YouTube Shorts Creator</title>
    <!-- ffmpeg.wasm for client-side video encoding -->
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.7/dist/umd/ffmpeg.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.1/dist/umd/index.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a15 0%, #1a1a2e 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .back-link {
            color: #00ff9d;
            text-decoration: none;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .container {
            display: grid;
            grid-template-columns: 7fr 3fr;
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }

        .panel {
            background: rgba(30, 30, 45, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
        }

        .panel h2 {
            color: #00ff9d;
            font-size: 16px;
            margin-bottom: 16px;
        }

        /* Video containers */
        .video-wrapper {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 16/9;
            margin-bottom: 16px;
        }

        .buffer-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            font-family: monospace;
            z-index: 200;
            pointer-events: none;
        }

        .autosave-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 255, 157, 0.9);
            color: #000;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .autosave-indicator.show {
            opacity: 1;
        }

        .autosave-indicator.saving {
            background: rgba(255, 193, 7, 0.9);
        }

        .preview-autosave {
            top: 10px;
            right: 10px;
            left: auto;
        }

        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 8px;
            z-index: 9999;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            font-size: 14px;
            font-weight: 500;
            min-width: 300px;
            text-align: center;
        }

        .notification.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from { transform: translate(-50%, -40px); opacity: 0; }
            to { transform: translate(-50%, 0); opacity: 1; }
        }

        .notification.success {
            background: rgba(43, 166, 64, 0.95);
            border: 1px solid #28a745;
            color: white;
        }

        .notification.error {
            background: rgba(220, 53, 69, 0.95);
            border: 1px solid #dc3545;
            color: white;
        }

        /* Custom Video Controls */
        .video-controls-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 200;
            pointer-events: none;
        }

        .video-wrapper:hover:not(.controls-locked) .video-controls-overlay {
            opacity: 1;
            pointer-events: auto;
        }

        .video-wrapper.controls-locked .video-controls-overlay {
            display: none !important;
        }

        .controls-progress {
            width: 100%;
            margin-bottom: 8px;
            position: relative;
        }

        .seekbar {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        /* Seekbar with theme range marked in red */
        .seekbar.theme-marked {
            background: linear-gradient(to right,
                rgba(255, 255, 255, 0.3) var(--theme-start),
                rgba(244, 67, 54, 0.85) var(--theme-start),
                rgba(244, 67, 54, 0.85) var(--theme-end),
                rgba(255, 255, 255, 0.3) var(--theme-end)
            );
        }

        /* Theme marker flag */
        .theme-marker {
            position: absolute;
            top: -30px;
            left: 0;
            transform: translateX(-50%);
            pointer-events: none;
            transition: left 0.2s;
        }

        .theme-marker-flag {
            position: relative;
            background: rgba(244, 67, 54, 0.9);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            font-weight: 500;
        }

        .theme-marker-flag::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid rgba(244, 67, 54, 0.9);
        }

        .seekbar::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }

        .seekbar::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .controls-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .control-icon {
            background: none;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            padding: 4px 8px;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .control-icon:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .control-jump {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .control-jump:hover {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
        }

        .time-display {
            color: #fff;
            font-size: 13px;
            font-family: monospace;
            flex-grow: 1;
        }

        .volume-slider {
            width: 80px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        .volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* Theme clip preview - 9:16 aspect ratio for YouTube Shorts */
        .preview-wrapper {
            aspect-ratio: 9/16;
            max-height: 500px;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Preview video should crop to fill the 9:16 frame */
        #preview-video {
            object-fit: cover;
        }

        /* Universal Subtitle Canvas */
        #karaoke-canvas, #original-karaoke-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Default to pass through clicks to video */
            z-index: 100;
        }

        /* Enable interaction when editing or dragging */
        .controls-locked #karaoke-canvas, .controls-locked #original-karaoke-canvas {
            pointer-events: auto;
            cursor: move;
        }

        /* Preview seekbar container */
        .preview-seekbar-container {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 10px;
            z-index: 200;
            display: flex;
            flex-direction: column;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .preview-wrapper:hover:not(.controls-locked) .preview-seekbar-container {
            opacity: 1;
            pointer-events: auto;
        }

        .preview-wrapper.controls-locked .preview-seekbar-container {
            display: none !important;
        }

        .preview-controls-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .preview-time-row {
            display: flex;
            justify-content: center;
        }

        .preview-control-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #00ff9d;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .preview-control-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        .preview-seekbar {
            flex-grow: 1;
        }

        .preview-time-display {
            font-size: 13px;
            color: #00ff9d;
            font-family: monospace;
        }

        /* Universal Subtitle Canvas */
        #karaoke-canvas, #original-karaoke-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Default to pass through clicks to video */
            z-index: 100;
        }

        /* Enable interaction when editing or dragging */
        .controls-locked #karaoke-canvas, .controls-locked #original-karaoke-canvas {
            pointer-events: auto;
            cursor: move;
        }

        /* Shorts 9:16 crop overlay */
        .shorts-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .shorts-crop-area {
            width: 56.25%;
            height: 100%;
            border: 3px solid rgba(0, 255, 157, 0.8);
            background: rgba(0, 255, 157, 0.1);
            position: relative;
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.3);
        }

        .shorts-crop-area::before {
            content: '9:16';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 157, 0.9);
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        /* Timeline */
        .timeline-container {
            margin-top: 16px;
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        /* Video buffer controls (on sides of video) */
        .video-buffer-btn {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: #00ff9d;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            flex-shrink: 0;
            pointer-events: auto;
        }

        .video-buffer-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        /* Buffer button containers */
        .video-buffer-controls-left,
        .video-buffer-controls-right {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 200;
        }

        .video-buffer-controls-left {
            left: 10px;
        }

        .video-buffer-controls-right {
            right: 10px;
        }

        /* Position buffer buttons inside video on edges */
        .video-buffer-btn.video-buffer-left {
            position: static;
            transform: none;
        }

        .video-buffer-btn.video-buffer-right {
            position: static;
            transform: none;
        }

        .buffer-label {
            font-size: 12px;
            color: #aaa;
        }

        .reset-timeline-btn {
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid rgba(255, 87, 34, 0.5);
            background: rgba(255, 87, 34, 0.1);
            color: #ff5722;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .reset-timeline-btn:hover {
            background: rgba(255, 87, 34, 0.2);
            border-color: rgba(255, 87, 34, 0.8);
            transform: translateY(-1px);
        }

        .reset-timeline-btn:active {
            transform: translateY(0);
            background: rgba(255, 87, 34, 0.3);
        }

        .timeline-track {
            position: relative;
            height: 60px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            overflow: hidden;
        }

        /* Buffer range band (shows the buffered portion of the video) */
        .buffer-range {
            position: absolute;
            height: 100%;
            background: rgba(100, 150, 200, 0.2);
            border-radius: 6px;
        }

        .theme-box {
            position: absolute;
            height: 100%;
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.5), rgba(255, 87, 34, 0.5));
            border: 2px solid #f44336;
            border-radius: 6px;
            cursor: default;
            transition: border-color 0.2s;
        }

        .theme-box.highlight-left {
            border-left: 4px solid #ff9800;
        }

        .theme-box.highlight-right {
            border-right: 4px solid #ff9800;
        }

        .theme-box-handle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: #f44336;
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: ew-resize;
            z-index: 10;
            transition: background 0.2s, border-color 0.2s;
        }

        .theme-box-handle:hover {
            background: #ff9800 !important;
            border-color: #fff !important;
        }

        .theme-box-handle.left {
            left: -8px; /* Position outside left edge */
        }

        .theme-box-handle.right {
            right: -8px; /* Position outside right edge */
        }

        .midpoint-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: repeating-linear-gradient(
                to bottom,
                #00ff9d,
                #00ff9d 4px,
                transparent 4px,
                transparent 8px
            );
            opacity: 0.6;
            z-index: 4;
            pointer-events: none;
        }

        .theme-box-content {
            position: absolute;
            top: 50%;
            left: 20px;
            right: 20px;
            transform: translateY(-50%);
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .time-markers {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 11px;
            color: #aaa;
        }

        /* Time start marker inside timeline */
        .time-start-marker-inside {
            position: absolute;
            bottom: 4px;
            left: 8px;
            font-size: 11px;
            color: #00ff9d;
            font-weight: 500;
            pointer-events: none;
            z-index: 5;
        }

        /* Time end marker inside timeline */
        .time-end-marker-inside {
            position: absolute;
            bottom: 4px;
            right: 8px;
            font-size: 11px;
            color: #00ff9d;
            font-weight: 500;
            pointer-events: none;
            z-index: 5;
        }

        /* Info display */
        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            color: #aaa;
            font-size: 13px;
        }

        .info-value {
            font-weight: 600;
            font-size: 14px;
        }

        #folder-location {
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: inline-block;
            vertical-align: bottom;
            cursor: help;
        }

        #folder-location:hover {
            overflow: visible;
            white-space: normal;
            word-wrap: break-word;
        }

        .duration-value {
            color: #00ff9d;
            font-size: 18px;
        }

        /* Subtitle editor */
        .subtitle-editor {
            margin-top: 20px;
        }

        .lock-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .lock-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        .lock-btn.locked {
            background: rgba(255, 152, 0, 0.2);
            border-color: #ff9800;
        }

        .subtitle-section {
            margin-bottom: 20px;
        }

        .subtitle-section h3 {
            font-size: 14px;
            color: #00ff9d;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
        }

        .subtitle-section h3::after {
            content: '‚ñº';
            font-size: 10px;
            transition: transform 0.3s ease;
            margin-left: 8px;
        }

        .subtitle-section.collapsed h3::after {
            transform: rotate(-90deg);
        }

        .section-content {
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out, margin-top 0.3s ease-out;
            max-height: 1000px;
            opacity: 1;
            overflow: visible;
        }

        .collapsed .section-content {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
            margin-bottom: 0;
            overflow: hidden;
            pointer-events: none;
        }

        .form-row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .form-group {
            flex: 1;
        }

        .form-group label {
            display: block;
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
        }

        .form-group select option {
            background-color: #1a1a2e;
            color: #fff;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #00ff9d;
        }

        .form-group input[type="color"] {
            height: 40px;
            padding: 4px;
        }

        .position-mode-group {
            display: flex;
            gap: 2px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 2px;
        }

        .position-mode-btn {
            flex: 1;
            padding: 6px 8px;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .position-mode-btn:hover {
            color: rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.05);
        }

        .position-mode-btn.active {
            background: #00ff9d;
            color: #000;
            font-weight: 600;
        }

        .position-mode-btn.active:hover {
            background: #00cc7d;
        }

        .align-group {
            display: flex;
            gap: 2px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 2px;
        }

        .align-btn {
            flex: 1;
            padding: 6px 2px;
            background: transparent;
            border: none;
            border-radius: 4px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            line-height: 1;
        }

        .align-btn:hover {
            color: rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.05);
        }

        .align-btn.active {
            background: #00ff9d;
            color: #000;
        }

        .subtitle-text-area {
            width: 100%;
            height: 64px;
            min-height: 64px;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            /* Don't set color here - let inline styles work */
            font-size: 14px;
            line-height: 1.5;
            font-family: inherit;
            overflow-y: auto;
            resize: none;
        }

        .subtitle-text-area:focus {
            outline: none;
            border-color: #00ff9d;
        }

        .subtitle-text-area:empty:before {
            content: attr(data-placeholder);
            color: rgba(255, 255, 255, 0.4);
        }

        .subtitle-text-area strong {
            font-weight: bold;
        }

        .subtitle-text-area em {
            font-style: italic;
        }

        .rich-text-toolbar {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .toolbar-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toolbar-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        .toolbar-btn.active {
            background: rgba(0, 255, 157, 0.3);
            border-color: #00ff9d;
        }

        .toolbar-divider {
            width: 1px;
            background: rgba(255, 255, 255, 0.2);
            margin: 0 4px;
        }

        /* Custom color picker */
        .color-picker-wrapper {
            position: relative;
            width: 36px;
            height: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-picker-wrapper:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        .color-picker-wrapper::before {
            content: 'üé®';
            font-size: 14px;
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }

        /* Color preview dot (shows current/last selected color) */
        .color-picker-wrapper::after {
            content: '';
            position: absolute;
            bottom: 3px;
            right: 3px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.5);
            background: var(--current-color, #ff00ff);
            pointer-events: none;
            z-index: 2;
        }

        #custom-color-picker {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        #custom-color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        #custom-color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 4px;
        }

        /* Actions toolbar (for Edit All, Lock, Clear buttons) */
        .actions-toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .actions-group {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .action-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
        }

        #lock-video-btn.locked {
            background: rgba(255, 152, 0, 0.2);
            border-color: #ff9800;
            color: #ff9800;
        }

        #lock-video-btn.locked:hover {
            background: rgba(255, 152, 0, 0.3);
        }

        /* Buttons */
        .buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00bfff, #00ff9d);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 255, 157, 0.3);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Loading and messages */
        .loading {
            text-align: center;
            padding: 60px 20px;
            color: #aaa;
        }

        .error {
            background: rgba(255, 59, 48, 0.2);
            border: 1px solid rgba(255, 59, 48, 0.5);
            border-radius: 8px;
            padding: 16px;
            color: #ff6b6b;
        }

        .success {
            background: rgba(0, 255, 157, 0.2);
            border: 1px solid rgba(0, 255, 157, 0.5);
            border-radius: 8px;
            padding: 16px;
            color: #00ff9d;
        }

        .hidden {
            display: none !important;
        }

        /* Custom tooltip for directory location */
        .custom-tooltip {
            position: relative;
            display: inline-block;
        }

        .custom-tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-5px);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background-color: #1e1e1e;
            margin: 5% auto;
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header h2 {
            margin: 0;
            font-size: 20px;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover,
        .close:focus {
            color: #fff;
        }

        .modal-body {
            padding: 20px;
        }

        .subtitle-cue-item {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
        }

        .cue-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 8px;
            font-size: 13px;
            color: #aaa;
        }

        .cue-time-input {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            width: 90px;
        }

        .cue-textarea {
            width: 100%;
            min-height: 60px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: #fff;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
        }

        .cue-textarea:focus {
            outline: none;
            border-color: #00ff9d;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            padding: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Time extension controls */
        .time-extension-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            margin: 16px 0;
            padding: 12px 16px;
            background: rgba(0, 255, 157, 0.08);
            border: 1px solid rgba(0, 255, 157, 0.2);
            border-radius: 8px;
        }

        .extension-input-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .extension-divider {
            color: #aaa;
            font-size: 14px;
            margin: 0 4px;
        }

        .extension-label {
            color: #00ff9d;
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
        }

        .extension-time-input {
            background: rgba(30, 30, 45, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 13px;
            padding: 6px 8px;
            font-family: monospace;
            width: 115px;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s;
        }

        /* Make the time input spinner icon white */
        .extension-time-input::-webkit-calendar-picker-indicator {
            filter: invert(1);
            cursor: pointer;
        }

        .extension-time-input::-webkit-calendar-picker-indicator:hover {
            filter: invert(1) brightness(1.2);
        }

        .extension-time-input:hover {
            border-color: rgba(0, 255, 157, 0.4);
        }

        .extension-time-input:focus {
            outline: none;
            border-color: #00ff9d;
            background: rgba(30, 30, 45, 1);
        }

        .time-separator {
            color: #aaa;
            font-size: 12px;
        }

        .extension-apply-btn {
            background: rgba(0, 255, 157, 0.15);
            border: 1px solid rgba(0, 255, 157, 0.4);
            border-radius: 4px;
            color: #00ff9d;
            font-size: 12px;
            font-weight: 500;
            padding: 6px 14px;
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s, transform 0.1s;
        }

        .extension-apply-btn:hover {
            background: rgba(0, 255, 157, 0.25);
            border-color: #00ff9d;
        }

        .extension-apply-btn:active {
            transform: scale(0.96);
        }

        .nudge-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .nudge-btn {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }

        .nudge-btn:hover {
            background: rgba(0, 255, 157, 0.2);
            border-color: #00ff9d;
            color: #00ff9d;
        }

        .nudge-btn:active {
            transform: scale(0.9);
            background: rgba(0, 255, 157, 0.3);
        }
    </style>
</head>
<body>
    <div id="notification" class="notification"></div>
    <div class="header">
        <a href="index.html" class="back-link">
            <span>‚Üê</span> Back to Main
        </a>
        <div style="flex-grow: 1; text-align: center;">
            <h1 style="margin: 0; font-size: 18px;" id="header-title">Adjust Theme</h1>
            <p style="margin: 0; font-size: 13px; color: #aaa;" id="header-theme-name"></p>
        </div>
        <div></div>
    </div>

    <div id="loading" class="loading">Loading theme details...</div>
    <div id="error" class="error hidden"></div>

    <div id="content" class="container hidden">
        <!-- Left Panel: Original Video + Timeline -->
        <div class="panel">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                <h2 style="margin: 0;">Original Video</h2>
                <div style="display: flex; gap: 16px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="subtitles-toggle" checked style="width: 18px; height: 18px;">
                        <span style="font-size: 13px; color: #aaa;">Show Subtitles</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="overlay-toggle" style="width: 18px; height: 18px;">
                        <span style="font-size: 13px; color: #aaa;">Show 9:16 Crop Overlay</span>
                    </label>
                </div>
            </div>

            <div class="video-wrapper">
                <video id="original-video"></video>
                
                <!-- Canvas for subtitles on original video side -->
                <canvas id="original-karaoke-canvas"></canvas>

                <div id="shorts-overlay" class="shorts-overlay hidden">
                    <div class="shorts-crop-area"></div>
                </div>
                <div class="buffer-info" id="buffer-info">Buffer range: 00:00:00 - 00:00:00</div>
                <div class="autosave-indicator" id="autosave-indicator"></div>

                <!-- Custom Video Controls -->
                <div class="video-controls-overlay">
                    <div class="controls-progress">
                        <input type="range" id="seekbar" class="seekbar" min="0" max="100" value="0" step="0.1">
                        <div id="theme-marker" class="theme-marker">
                            <div class="theme-marker-flag">Theme length: <span id="theme-duration-text">00:00</span></div>
                        </div>
                    </div>
                    <div class="controls-row">
                        <button id="play-pause-btn" class="control-icon">‚ñ∂</button>
                        <button id="jump-start-btn" class="control-jump" title="Jump to theme start">‚èÆ Start</button>
                        <button id="jump-end-btn" class="control-jump" title="Jump to theme end">End ‚è≠</button>
                        <span id="time-display" class="time-display">00:00 / 00:00</span>
                        <input type="range" id="volume-slider" class="volume-slider" min="0" max="1" value="1" step="0.1">
                    </div>
                </div>

                <!-- Video buffer controls inside video -->
                <div class="video-buffer-controls-left">
                    <button id="video-buffer-decrease-left" class="video-buffer-btn" title="Reduce buffer by 1 min">‚àí</button>
                    <button id="video-buffer-increase-left" class="video-buffer-btn" title="Increase buffer by 1 min">+</button>
                </div>
                <div class="video-buffer-controls-right">
                    <button id="video-buffer-decrease-right" class="video-buffer-btn" title="Reduce buffer by 1 min">‚àí</button>
                    <button id="video-buffer-increase-right" class="video-buffer-btn" title="Increase buffer by 1 min">+</button>
                </div>
            </div>

            <div class="timeline-container">
                <div class="timeline-header">
                    <span class="buffer-label" id="buffer-display">L: ¬±5min | R: ¬±5min</span>
                    <div style="display: flex; gap: 8px;">
                        <button id="toggle-zoom-btn" class="reset-timeline-btn" style="border-color: rgba(0, 255, 157, 0.5); background: rgba(0, 255, 157, 0.1); color: #00ff9d;" title="Zoom timeline to fill with buffer range">üîç Zoom to Buffer</button>
                        <button id="reset-timeline-btn" class="reset-timeline-btn" title="Reset to original theme time range">‚Ü∫ Reset to Original</button>
                    </div>
                </div>
                <div class="timeline-track" id="timeline-track">
                    <div class="buffer-range" id="buffer-range">
                        <div id="midpoint-marker" class="midpoint-marker" title="Original Midpoint"></div>
                        <div class="theme-box" id="theme-box">
                            <div class="theme-box-handle left" id="handle-left"></div>
                            <div class="theme-box-content" id="theme-box-content">00:30 - 01:30</div>
                            <div class="theme-box-handle right" id="handle-right"></div>
                        </div>
                    </div>
                    <span class="time-start-marker-inside" id="time-start-marker">00:00</span>
                    <span class="time-end-marker-inside" id="time-end-marker">00:00</span>
                </div>
                <div class="time-markers">
                </div>
            </div>

            <!-- Manual time extension inputs -->
            <div class="time-extension-controls">
                <div class="nudge-group">
                    <button class="nudge-btn" onclick="nudgeTheme('left', -1)" title="Start Earlier by 1s">--</button>
                    <button class="nudge-btn" onclick="nudgeTheme('left', -0.1)" title="Start Earlier by 0.1s">-</button>
                    <div class="extension-input-group">
                        <label class="extension-label">Ext Left</label>
                        <button id="apply-ext-left" class="extension-apply-btn">Apply</button>
                    </div>
                    <button class="nudge-btn" onclick="nudgeTheme('left', 0.1)" title="Start Later by 0.1s">+</button>
                    <button class="nudge-btn" onclick="nudgeTheme('left', 1)" title="Start Later by 1s">++</button>
                </div>
                
                <input type="time" id="ext-left-end" class="extension-time-input" step="1" min="00:00:00" max="01:00:00">
                <div class="extension-divider">|</div>
                <input type="time" id="ext-right-end" class="extension-time-input" step="1" min="00:00:00" max="01:00:00">
                
                <div class="nudge-group">
                    <button class="nudge-btn" onclick="nudgeTheme('right', -1)" title="End Earlier by 1s">--</button>
                    <button class="nudge-btn" onclick="nudgeTheme('right', -0.1)" title="End Earlier by 0.1s">-</button>
                    <div class="extension-input-group">
                        <button id="apply-ext-right" class="extension-apply-btn">Apply</button>
                        <label class="extension-label">Ext Right</label>
                    </div>
                    <button class="nudge-btn" onclick="nudgeTheme('right', 0.1)" title="End Later by 0.1s">+</button>
                    <button class="nudge-btn" onclick="nudgeTheme('right', 1)" title="End Later by 1s">++</button>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <div class="info-row">
                    <span class="info-label">Theme</span>
                    <span class="info-value" id="theme-number">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Theme Name</span>
                    <span class="info-value" id="theme-name" style="color: #00ff9d; cursor: pointer;" contenteditable="true" title="Click to edit">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Start Time</span>
                    <span class="info-value" id="display-start">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">End Time</span>
                    <span class="info-value" id="display-end">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Duration</span>
                    <span class="info-value duration-value" id="display-duration">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Directory location</span>
                    <span class="info-value" id="folder-location" title="">-</span>
                </div>

            </div>
        </div>

        <!-- Right Panel: Theme Clip Preview + Subtitle Editor -->
        <div class="panel" style="position: relative;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                <h2 style="margin: 0; color: #00ff9d; font-size: 16px;">üé¨ LIVE Subtitle Preview (WYSIWYG)</h2>
            </div>
            <div class="video-wrapper preview-wrapper">
                <video id="preview-video" loop playsinline></video>
                <div class="autosave-indicator preview-autosave" id="preview-autosave-indicator"></div>

                <!-- Canvas for unified subtitle rendering -->
                <canvas id="karaoke-canvas"></canvas>

                <!-- Custom controls for preview video -->
                <div class="preview-seekbar-container">
                    <div class="preview-controls-row">
                        <button id="preview-play-btn" class="preview-control-btn">‚ñ∂</button>
                        <button id="preview-prev-frame" class="preview-control-btn" title="Previous Frame" style="font-size: 14px;">-1f</button>
                        <input type="range" id="preview-seekbar" class="seekbar preview-seekbar" min="0" max="100" value="0" step="0.1">
                        <button id="preview-next-frame" class="preview-control-btn" title="Next Frame" style="font-size: 14px;">+1f</button>
                    </div>
                    <div class="preview-time-row">
                        <span id="preview-time-display" class="preview-time-display">00:00 / 00:00</span>
                    </div>
                </div>
            </div>

                        <div class="subtitle-editor" id="subtitle-editor">
                            <div class="subtitle-section" id="subtitle-text-section">
                                <h3 onclick="toggleSection('subtitle-text-section')">Subtitle Text</h3>
                                <div class="section-content">
                                    <!-- Action buttons toolbar -->
                                    <div class="actions-toolbar">
                                        <div class="actions-group">
                                            <button id="edit-all-subs-btn" class="action-btn" title="Edit all subtitles for this theme">üìù Edit All</button>
                                            <button id="lock-video-btn" class="action-btn" title="Lock video controls to enable dragging">
                                                <span id="lock-icon">üîì</span> Lock
                                            </button>
                                        </div>
                                        <div class="actions-group">
                                            <button class="toolbar-btn" onmousedown="event.preventDefault(); removeFormatting()" title="Clear all formatting">üóë Clear</button>
                                        </div>
                                    </div>
            
                                    <!-- Rich text formatting toolbar -->
                                    <div class="rich-text-toolbar">
                                        <button class="toolbar-btn" data-style="bold" onmousedown="event.preventDefault(); toggleStyle('bold')"><b>Bold</b></button>
                                        <button class="toolbar-btn" data-style="italic" onmousedown="event.preventDefault(); toggleStyle('italic')"><i>Italic</i></button>
                                        <button class="toolbar-btn" data-style="color" onmousedown="event.preventDefault(); applyColor('#ff0000')">üî¥</button>
                                        <button class="toolbar-btn" data-style="color" onmousedown="event.preventDefault(); applyColor('#00ff00')">üü¢</button>
                                        <button class="toolbar-btn" data-style="color" onmousedown="event.preventDefault(); applyColor('#00ffff')">üîµ</button>
                                        <button class="toolbar-btn" data-style="color" onmousedown="event.preventDefault(); applyColor('#ffff00')">üü°</button>
                                        <button class="toolbar-btn" data-style="color" onmousedown="event.preventDefault(); applyColor('#ffffff')">‚ö™</button>
                                        <div class="color-picker-wrapper">
                                            <input type="color" id="custom-color-picker" value="#ff00ff" title="Custom color">
                                        </div>
                                        <div class="toolbar-divider"></div>
                                        <button class="toolbar-btn" data-style="size" onmousedown="event.preventDefault(); applySize(1.2)">A+</button>
                                        <button class="toolbar-btn" data-style="size" onmousedown="event.preventDefault(); applySize(0.8)">a-</button>
                                        <div class="toolbar-divider"></div>
                                        <button class="toolbar-btn" onmousedown="event.preventDefault(); splitSubtitleAtCursor()" title="Split current subtitle at cursor position">‚úÇÔ∏è Split</button>
                                        <button class="toolbar-btn" onmousedown="event.preventDefault(); joinWithPrevious()" title="Join with previous subtitle">üîó Join Prev</button>
                                        <button class="toolbar-btn" onmousedown="event.preventDefault(); joinWithNext()" title="Join with next subtitle">üîó Join Next</button>
                                    </div>
                                    <div class="subtitle-text-area" id="subtitle-text" contenteditable="true" data-placeholder="Edit subtitle text here..."></div>
                                    <div id="subtitle-duration-info" style="margin-top: 8px; font-size: 12px; color: #00ff9d; font-weight: 500; display: flex; justify-content: flex-start; align-items: center; gap: 12px;">
                                        <div class="nudge-group" style="gap: 4px;">
                                            <span style="color: #aaa; margin-right: 4px;">Start:</span>
                                            <button class="nudge-btn" style="width: 22px; height: 22px; font-size: 10px;" onclick="nudgeCueTiming('start', -0.1)" title="Earlier by 0.1s">-</button>
                                            <button class="nudge-btn" style="width: 22px; height: 22px; font-size: 10px;" onclick="nudgeCueTiming('start', 0.1)" title="Later by 0.1s">+</button>
                                        </div>
                                        
                                        <div style="display: flex; align-items: center; gap: 6px; background: rgba(255,255,255,0.05); padding: 2px 8px; border-radius: 4px;">
                                            <span style="color: #aaa; font-weight: normal; font-size: 11px;">Duration:</span>
                                            <span id="subtitle-duration-value" style="min-width: 40px; text-align: center;">0.00s</span>
                                        </div>
            
                                        <div class="nudge-group" style="gap: 4px;">
                                            <button class="nudge-btn" style="width: 22px; height: 22px; font-size: 10px;" onclick="nudgeCueTiming('end', -0.1)" title="Earlier by 0.1s">-</button>
                                            <button class="nudge-btn" style="width: 22px; height: 22px; font-size: 10px;" onclick="nudgeCueTiming('end', 0.1)" title="Later by 0.1s">+</button>
                                            <span style="color: #aaa; margin-left: 4px;">:End</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
            
                            <div class="subtitle-section" id="global-settings-section">
                                    <h3 onclick="toggleSection('global-settings-section')">Global Subtitle Settings</h3>

                                    <div class="section-content">

                                        <div class="form-row">

                                            <div class="form-group">

                                                <label>Font Family</label>

                                                <select id="subtitle-font">

                                                    <option value="Arial">Arial</option>

                                                    <option value="Calibri">Calibri</option>

                                                    <option value="Times New Roman">Times New Roman</option>

                                                    <option value="Courier New">Courier New</option>

                                                    <option value="Georgia">Georgia</option>

                                                    <option value="Verdana">Verdana</option>

                                                </select>

                                            </div>

                                            <div class="form-group">

                                                <label>Font Size (px)</label>

                                                <div style="display: flex; align-items: center; gap: 10px;">

                                                    <input type="number" id="subtitle-size" value="80" min="20" max="200" style="flex: 1;">

                                                    <label style="display: flex; align-items: center; gap: 5px; margin-bottom: 0; cursor: pointer; white-space: nowrap;">

                                                        <input type="checkbox" id="subtitle-bold" style="width: 16px; height: 16px;">

                                                        <span style="font-size: 12px;">Bold</span>

                                                    </label>

                                                </div>

                                            </div>

                                        </div>

                                        <div class="form-row">

                                            <div class="form-group">

                                                <label>Text Color</label>

                                                <input type="color" id="subtitle-color" value="#ffffff">

                                            </div>

                                            <div class="form-group">

                                                <label>Background Color</label>

                                                <input type="color" id="subtitle-bg" value="#000000">

                                            </div>

                                            <div class="form-group">

                                                <label>Background Opacity</label>

                                                <input type="range" id="subtitle-bg-opacity" min="0" max="100" value="70" step="1">

                                            </div>

                                        </div>

                                        <div class="form-row">

                                            <div class="form-group">

                                                <label>Position Mode</label>

                                                <div class="position-mode-group">

                                                    <button class="position-mode-btn active" data-mode="global">Global</button>

                                                    <button class="position-mode-btn" data-mode="current">Current</button>

                                                </div>

                                            </div>

                                            <div class="form-group">

                                                <label>Position</label>

                                                <select id="subtitle-position">

                                                    <option value="bottom">Bottom</option>

                                                    <option value="middle">Middle</option>

                                                    <option value="top">Top</option>

                                                    <option value="custom">Custom (Draggable)</option>

                                                </select>

                                            </div>

                                        </div>

                                        <div class="form-row" style="justify-content: center;">

                                            <div class="form-group" style="flex: 0; min-width: 140px;">

                                                <label style="text-align: center;">H: ‚¨Ö ‚¨å ‚û°</label>

                                                <div class="align-group">

                                                    <button class="align-btn" data-align="left" title="Align Left">‚¨Ö</button>

                                                    <button class="align-btn active" data-align="center" title="Align Center">‚¨å</button>

                                                    <button class="align-btn" data-align="right" title="Align Right">‚û°</button>

                                                </div>

                                            </div>

                                            <div class="form-group" style="flex: 0; min-width: 140px;">

                                                <label style="text-align: center;">V: ‚¨Ü ‚¨ç ‚¨á</label>

                                                <div class="align-group">

                                                    <button class="align-btn" data-valign="top" title="Align Top">‚¨Ü</button>

                                                    <button class="align-btn active" data-valign="middle" title="Align Middle">‚¨ç</button>

                                                    <button class="align-btn" data-valign="bottom" title="Align Bottom">‚¨á</button>

                                                </div>

                                            </div>

                                        </div>

                                    </div>

                                </div>

                <!-- Subtitle Effect & Karaoke Section -->
                <div class="subtitle-section" id="karaoke-section">
                    <h3 onclick="toggleSection('karaoke-section')">Subtitle Style / Effect</h3>
                    <div class="section-content">
                        <div class="form-row">
                            <div class="form-group" style="width: 100%;">
                                <label style="font-size: 13px; color: #00ff9d; font-weight: 600;">Subtitle Style / Effect</label>
                                <select id="effect-type" style="padding: 8px 10px; background: #2a2a2a; color: #fff; border: 1px solid #444; border-radius: 4px; font-size: 13px; width: 100%; margin-bottom: 10px;">
                                    <option value="none">No Karaoke (Standard Subtitles)</option>
                                    <option value="standard">üé§ Standard Karaoke Highlight</option>
                                    <optgroup label="Animation Effects">
                                        <option value="pop">Word Pop / Bounce</option>
                                        <option value="slide">Slide Reveal</option>
                                        <option value="typewriter">Typewriter</option>
                                    </optgroup>
                                    <optgroup label="Advanced Karaoke Styles">
                                        <option value="progressive_fill">Progressive Color Fill</option>
                                        <option value="wave">Wave / Wiggle</option>
                                        <option value="flash">Flash (Center Focus)</option>
                                    </optgroup>
                                    <optgroup label="Visual Styling">
                                        <option value="neon_glitch">Neon Glitch</option>
                                        <option value="dynamic_box">Dynamic Box / Ribbon</option>
                                        <option value="shadow_3d">Multi-Layer Shadow (3D)</option>
                                    </optgroup>
                                    <optgroup label="Audio-Reactive">
                                        <option value="volume_shake">Volume Shake</option>
                                        <option value="pulsing_glow">Pulsing Glow</option>
                                    </optgroup>
                                </select>

                                <div id="karaoke-style-controls" style="display: none; flex-direction: column; gap: 15px; padding: 15px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333;">
                                    <!-- Emphasis Options -->
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                            <input type="checkbox" id="auto-emoji" style="width: 16px; height: 16px;">
                                            <span style="font-size: 12px; color: #aaa;">Auto-Emoji üöÄ</span>
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-left: 20px;">
                                            <input type="checkbox" id="keyword-scaling" style="width: 16px; height: 16px;">
                                            <span style="font-size: 12px; color: #aaa;">Keyword Scaling</span>
                                        </label>
                                    </div>

                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                                                            <!-- Karaoke Mode -->
                                                                            <div style="display: flex; flex-direction: column; gap: 5px;">
                                                                                <label style="font-size: 12px; color: #aaa; font-weight: 500;">Highlight Behavior</label>
                                                                                <select id="karaoke-mode" style="padding: 6px 8px; background: #2a2a2a; color: #fff; border: 1px solid #444; border-radius: 4px; font-size: 12px;">
                                                                                    <option value="normal" selected>Normal (Highlight & Fade)</option>
                                                                                    <option value="cumulative">Cumulative (Stay Highlighted)</option>
                                                                                </select>
                                                                            </div>
                                        
                                                                            <!-- Past Words Color (for cumulative mode) -->
                                                                            <div style="display: flex; align-items: center; gap: 10px; grid-column: 1 / -1;">
                                                                                <label style="font-size: 12px; color: #aaa; font-weight: 500; min-width: 120px;">Past Words Color:</label>
                                                                                <input type="color" id="past-color" value="#808080" style="width: 50px; height: 28px; cursor: pointer; border: none; border-radius: 4px;">
                                                                                <span style="font-size: 11px; color: #666;">(for cumulative mode)</span>
                                                                            </div>
                                        <!-- Divider -->
                                        <div style="grid-column: 1 / -1; height: 1px; background: #333; margin: 10px 0;"></div>

                                        <!-- Color Preset -->
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <label style="font-size: 12px; color: #aaa; font-weight: 500; min-width: 70px;">Preset:</label>
                                            <select id="highlight-preset" style="flex: 1; padding: 6px 8px; background: #2a2a2a; color: #fff; border: 1px solid #444; border-radius: 4px; font-size: 12px;">
                                                <option value="custom">Custom</option>
                                                <option value="yellow-glow" selected>Yellow Glow</option>
                                                <option value="red-bold">Red Bold</option>
                                                <option value="cyan-neon">Cyan Neon</option>
                                                <option value="green-glow">Green Glow</option>
                                                <option value="pink-soft">Pink Soft</option>
                                                <option value="orange-fire">Orange Fire</option>
                                                <option value="white-clean">White Clean</option>
                                                <option value="purple-vibe">Purple Vibe</option>
                                            </select>
                                        </div>

                                        <!-- Text Color -->
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <label style="font-size: 12px; color: #aaa; font-weight: 500; min-width: 70px;">Text Color:</label>
                                            <input type="color" id="highlight-text-color" value="#ffff00" style="width: 50px; height: 28px; cursor: pointer; border: none; border-radius: 4px;">
                                        </div>

                                        <!-- Glow Color -->
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <label style="font-size: 12px; color: #aaa; font-weight: 500; min-width: 70px;">Glow Color:</label>
                                            <input type="color" id="highlight-glow-color" value="#ffff00" style="width: 50px; height: 28px; cursor: pointer; border: none; border-radius: 4px;">
                                        </div>

                                        <!-- Glow Blur -->
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <label style="font-size: 12px; color: #aaa; font-weight: 500; min-width: 70px;">Glow Blur:</label>
                                            <select id="highlight-glow-blur" style="flex: 1; padding: 6px 8px; background: #2a2a2a; color: #fff; border: 1px solid #444; border-radius: 4px; font-size: 12px;">
                                                <option value="0">None (0px)</option>
                                                <option value="2">Minimal (2px)</option>
                                                <option value="5">Soft (5px)</option>
                                                <option value="10" selected>Normal (10px)</option>
                                                <option value="15">Strong (15px)</option>
                                                <option value="20">Extra (20px)</option>
                                                <option value="30">Max (30px)</option>
                                            </select>
                                        </div>

                                        <!-- Font Weight -->
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <label style="font-size: 12px; color: #aaa; font-weight: 500; min-width: 70px;">Font Weight:</label>
                                            <select id="highlight-font-weight" style="flex: 1; padding: 6px 8px; background: #2a2a2a; color: #fff; border: 1px solid #444; border-radius: 4px; font-size: 12px;">
                                                <option value="normal">Normal</option>
                                                <option value="bold">Bold</option>
                                                <option value="100">Thin (100)</option>
                                                <option value="300">Light (300)</option>
                                                <option value="500">Medium (500)</option>
                                                <option value="700">Extra Bold (700)</option>
                                                <option value="900">Black (900)</option>
                                            </select>
                                        </div>

                                        <div style="grid-column: 1 / -1; display: flex; justify-content: center; margin-top: 10px;">
                                            <button id="reset-highlight-style" style="padding: 8px 20px; background: #444; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Reset to Default</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Export Video Button (Outside collapsible areas) -->
                <div style="margin-top: 24px; padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: center;">
                    <button id="export-canvas-video" style="width: 100%; padding: 12px 24px; background: linear-gradient(135deg, #4CAF50, #45a049); color: #fff; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; box-shadow: 0 4px 12px rgba(0,0,0,0.2); transition: transform 0.2s, box-shadow 0.2s;">üé¨ Export Final Short (with Subtitles)</button>
                </div>
            </div>  <!-- End of karaoke-section -->
            </div>

            <div id="message" style="margin-top: 16px;"></div>
        </div>
    </div>



    <!-- Subtitle Editor Modal -->
    <div id="subtitle-modal" class="modal">
        <div class="modal-content" style="max-width: 800px; max-height: 80vh; display: flex; flex-direction: column;">
            <div class="modal-header">
                <h2>Edit All Subtitles</h2>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body" style="flex: 1; overflow-y: auto;">
                <div id="subtitle-cues-container"></div>
            </div>
            <div class="modal-footer" style="padding: 16px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: flex-end; gap: 12px;">
                <button id="cancel-subs-btn" class="btn btn-secondary">Cancel</button>
                <button id="save-subs-btn" class="btn btn-primary">Save Subtitles</button>
            </div>
        </div>
    </div>

    <script>
        // State
        let themeData = null;
        let fullVideoDuration = 0;  // Full video duration
        let bufferedDuration = 0;   // Buffered range duration (for timeline)
        let videoPath = '';
        let startSeconds = 0;
        let endSeconds = 0;
        let originalStartSeconds = 0;  // Original theme time from themes.md (for reset)
        let originalEndSeconds = 0;    // Original theme time from themes.md (for reset)
        let bufferLeftSeconds = 300; // 5 minutes buffer before theme
        let bufferRightSeconds = 300; // 5 minutes buffer after theme
        let isDragging = null;
        let dragStartX = 0;
        let dragStartValue = 0;
        let dragStartValueEnd = 0;
        let videoControlsLocked = false; // Video controls lock state
        let timelineZoomed = false; // Timeline zoom state (zoom to buffer)
        let videoFps = 30; // Default FPS, will be updated from metadata if possible

        // DOM Elements
        const originalVideo = document.getElementById('original-video');
        const originalCanvas = document.getElementById('original-karaoke-canvas');
        const previewVideo = document.getElementById('preview-video');
        const canvas = document.getElementById('karaoke-canvas');
        const previewSeekbar = document.getElementById('preview-seekbar');
        const previewPlayBtn = document.getElementById('preview-play-btn');
        const themeBox = document.getElementById('theme-box');
        const handleLeft = document.getElementById('handle-left');
        const handleRight = document.getElementById('handle-right');
        const timelineTrack = document.getElementById('timeline-track');
        const bufferRange = document.getElementById('buffer-range');
        const themeBoxContent = document.getElementById('theme-box-content');

        // Custom video control elements
        const seekbar = document.getElementById('seekbar');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const jumpStartBtn = document.getElementById('jump-start-btn');
        const jumpEndBtn = document.getElementById('jump-end-btn');
        const timeDisplay = document.getElementById('time-display');
        const volumeSlider = document.getElementById('volume-slider');
        const themeMarker = document.getElementById('theme-marker');
        const themeDurationText = document.getElementById('theme-duration-text');

        // Parse URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const folderNumber = urlParams.get('folder');
        const themeNumber = parseInt(urlParams.get('theme'));
        
        console.log('üèÅ adjust.html script loaded', {folderNumber, themeNumber});

        // Global notification function - defined early and attached to window
        window.showNotification = function(message, type = 'success', customTimeout = null) {
            const notification = document.getElementById('notification');
            if (!notification) {
                console.warn("Notification element not found:", message);
                return;
            }
            
            notification.textContent = message;
            notification.className = `notification ${type} show`;

            // For error notifications, keep visible longer or add click to dismiss
            if (type === 'error') {
                notification.style.cursor = 'pointer';
                notification.onclick = () => notification.classList.remove('show');
            } else {
                // Hide after 3 seconds (or custom timeout) for non-error notifications
                setTimeout(() => {
                    notification.classList.remove('show');
                }, customTimeout || 3000);
            }
        };

        // Format time
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        // Parse time string to seconds (supports -HH:MM:SS.mmm)
        function parseTime(timeStr) {
            if (!timeStr) return 0;
            const isNegative = timeStr.startsWith('-');
            const cleanStr = isNegative ? timeStr.slice(1) : timeStr;
            const parts = cleanStr.split(':');
            if (parts.length !== 3) return 0;
            const seconds = parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseFloat(parts[2].replace(',', '.'));
            return isNegative ? -seconds : seconds;
        }

        // Helper to convert seconds to timestamp string (supports negative values)
        function formatVttTime(totalSeconds) {
            const EPSILON = 0.0001;
            if (Math.abs(totalSeconds) < EPSILON) totalSeconds = 0;

            const isNegative = totalSeconds < 0;
            const absSeconds = Math.abs(totalSeconds);

            // Correctly handle millisecond rounding to avoid 1000ms overflow
            const roundedTotalMs = Math.round(absSeconds * 1000);
            const ms = roundedTotalMs % 1000;
            const totalS = Math.floor(roundedTotalMs / 1000);
            const sec = totalS % 60;
            const min = Math.floor(totalS / 60) % 60;
            const hour = Math.floor(totalS / 3600);

            const sign = isNegative ? '-' : '';
            return `${sign}${hour.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
        }

        // Auto-save theme adjustment
        let autoSaveTimeout = null;
        let subtitleAutoSaveTimeout = null;
        let currentCueInfo = null; // Track current cue: sequence, timestamp, start, end, text
        let allThemeCues = []; // Full list of cues for the theme
        let subtitleEdits = {}; // Cache subtitle text edits: "start_end": "edited text"
        let allCueFormatting = {}; // Store formatting for all cues: sequence: [sequence, timestamp, html, _text]
        let isProgrammaticUpdate = false; // Flag to prevent auto-save during programmatic updates
        let themeStartBeforeDrag = null; // Track theme start before drag to calculate timestamp shift
        let themeEndBeforeDrag = null; // Track theme end before drag

        // Position mode: 'global' (all subtitles) or 'current' (individual subtitle)
        let positionMode = 'global';
        let globalPosition = 'bottom'; // Default global position for all subtitles
        let karaokeEnabled = true; // Karaoke word highlighting (default: enabled)
        let wordTimestamps = null; // Word timestamps for preview karaoke effect

        let canvasRenderer = null;
        let originalCanvasRenderer = null;

        // UniversalSubtitleRenderer class for canvas-based rendering of all subtitle styles
        class UniversalSubtitleRenderer {
            constructor(canvas, videoElement, wordTimestamps, settings) {
                this.canvas = canvas;
                this.video = videoElement;
                this.ctx = canvas.getContext('2d');
                this.wordTimestamps = wordTimestamps || [];
                this.settings = settings || {};
                
                // The logical resolution for our coordinates (matching backend export)
                this.refWidth = 1080;
                this.refHeight = 1920;
                
                // Emoji map for preview
                this.EMOJI_MAP = {
                    "fire": "üî•", "lit": "üî•", "hot": "üî•",
                    "love": "‚ù§Ô∏è", "heart": "‚ù§Ô∏è",
                    "laugh": "üòÇ", "funny": "üòÇ", "lol": "üòÇ",
                    "sad": "üò¢", "cry": "üò¢",
                    "angry": "üò°", "mad": "üò°",
                    "wow": "üòÆ", "amazing": "üòÆ", "surprised": "üòÆ",
                    "cool": "üòé", "chill": "üòé",
                    "money": "üí∞", "cash": "üí∞", "rich": "üí∞",
                    "goal": "‚öΩ", "soccer": "‚öΩ",
                    "basketball": "üèÄ",
                    "brain": "üß†", "think": "üß†", "smart": "üß†",
                    "light": "üí°", "idea": "üí°",
                    "stop": "üõë", "halt": "üõë",
                    "go": "üöÄ", "fast": "üöÄ", "speed": "üöÄ",
                    "time": "‚è∞", "clock": "‚è∞", "watch": "‚è∞",
                    "danger": "‚ö†Ô∏è", "warning": "‚ö†Ô∏è",
                    "success": "üèÜ", "winner": "üèÜ", "win": "üèÜ",
                    "islam": "üïå", "muslim": "üïå", "prayer": "üïå", "dua": "ü§≤",
                    "quran": "üìñ", "book": "üìñ", "read": "üìñ",
                    "allah": "‚òùÔ∏è", "god": "‚òùÔ∏è"
                };
            }

            // Helper to get effect modifications for a word
            getEffectMods(wordObj, currentTime, wordStart, wordEnd, isHighlighted) {
                const effectType = this.settings.effect_type || 'none';
                const duration = wordEnd - wordStart;
                const progress = duration > 0 ? (currentTime - wordStart) / duration : 0;
                const isActive = (progress >= 0 && progress <= 1) || isHighlighted;
                
                const mods = {
                    scale: 1.0,
                    offsetX: 0,
                    offsetY: 0,
                    opacity: 1.0,
                    text: wordObj.text,
                    color: isHighlighted ? (this.settings.textColor || '#ffff00') : (wordObj.color || this.settings.primaryColor || '#ffffff'),
                    glowBlur: this.settings.glowBlur || 0,
                    sizeMultiplier: wordObj.sizeMultiplier || 1.0,
                    emoji: null,
                    customShadow: false
                };

                // Apply individual effects
                if (effectType === 'pop' && isActive) {
                    const bounce = Math.sin(Math.max(0, Math.min(1, progress)) * Math.PI) * 0.3;
                    mods.scale += bounce;
                    mods.offsetY -= bounce * (30 * (this.canvas.height / 1920));
                } else if (effectType === 'slide' && isActive) {
                    if (progress < 0.4) {
                        const slideProg = progress / 0.4;
                        mods.offsetY = (40 * (this.canvas.height / 1920)) * (1.0 - slideProg);
                        mods.opacity = slideProg;
                    }
                } else if (effectType === 'typewriter' && isActive) {
                    const chars = Math.floor(wordObj.text.length * Math.max(0, Math.min(1, progress)));
                    mods.text = wordObj.text.substring(0, chars);
                } else if (effectType === 'flash') {
                    if (!isActive) {
                        mods.opacity = 0;
                        mods.text = "";
                    } else {
                        mods.scale = 1.5;
                    }
                } else if (effectType === 'wave') {
                    const phase = (currentTime * 6) + (wordStart * 3);
                    mods.offsetY = Math.sin(phase) * (8 * (this.canvas.height / 1920));
                    if (isActive) mods.offsetY *= 1.5;
                } else if (effectType === 'neon_glitch' && isActive) {
                    if (Math.floor(currentTime * 30) % 4 === 0) {
                        mods.offsetX = (Math.random() - 0.5) * 16;
                        mods.glowBlur *= 2.5;
                    }
                } else if (effectType === 'shadow_3d' && isActive) {
                    mods.customShadow = true;
                }

                // AI Emphasis Effects
                if (this.settings.keyword_scaling) {
                    const clean = mods.text.toLowerCase().replace(/[.,!?;:"'\s]/g, '');
                    if (clean.length > 5 || (mods.text[0] >= 'A' && mods.text[0] <= 'Z')) {
                        mods.sizeMultiplier *= 1.25;
                    }
                }

                if (this.settings.auto_emoji && isActive) {
                    const clean = mods.text.toLowerCase().replace(/[.,!?;:"'\s]/g, '');
                    if (this.EMOJI_MAP[clean]) {
                        mods.emoji = this.EMOJI_MAP[clean];
                    }
                }

                return mods;
            }

            // Helper to parse HTML into styled word objects
            parseSubtitleHTML(html) {
                if (!html) return [];
                const div = document.createElement('div');
                div.innerHTML = html;
                const result = [];
                
                const walk = (node, currentStyle) => {
                    if (node.nodeType === Node.TEXT_NODE) {
                        const words = node.textContent.split(/(\s+)/);
                        words.forEach(word => {
                            if (word.length > 0) {
                                result.push({ text: word, ...currentStyle });
                            }
                        });
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        const newStyle = { ...currentStyle };
                        const name = node.nodeName.toUpperCase();
                        if (name === 'B' || name === 'STRONG') newStyle.bold = true;
                        if (name === 'I' || name === 'EM') newStyle.italic = true;
                        if (name === 'FONT') {
                            if (node.hasAttribute('color')) newStyle.color = node.getAttribute('color');
                            if (node.hasAttribute('size')) {
                                const sizeMap = { '1': 0.5, '2': 0.7, '3': 0.9, '4': 1.0, '5': 1.2, '6': 1.4, '7': 1.6 };
                                newStyle.sizeMultiplier = sizeMap[node.getAttribute('size')] || 1.0;
                            }
                        }
                        if (node.style.color) newStyle.color = node.style.color;
                        if (node.style.fontWeight === 'bold' || parseInt(node.style.fontWeight) >= 700) newStyle.bold = true;
                        if (node.style.fontStyle === 'italic') newStyle.italic = true;
                        if (node.style.fontSize) {
                            const emMatch = node.style.fontSize.match(/([\d.]+)em/);
                            if (emMatch) newStyle.sizeMultiplier = parseFloat(emMatch[1]);
                            else {
                                const pxMatch = node.style.fontSize.match(/([\d.]+)px/);
                                if (pxMatch) newStyle.sizeMultiplier = parseFloat(pxMatch[1]) / 16;
                            }
                        }
                        node.childNodes.forEach(child => walk(child, newStyle));
                    }
                };
                walk(div, { bold: false, italic: false, color: null, sizeMultiplier: 1.0 });
                return result.filter(item => item.text.trim().length > 0);
            }

            renderFrame(currentTime, subtitleData, highlightedWordIndex = -1) {
                const ctx = this.ctx;
                const canvas = this.canvas;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!subtitleData) return;

                const scale = canvas.height / 1920;
                const baseFontSize = (this.settings.fontSize || 80) * scale;
                const fontFamily = this.settings.font_name || 'Arial';
                const baseFontWeight = this.settings.font_weight || 'normal';
                const outlineColor = this.settings.outlineColor || '#000000';
                const primaryColor = this.settings.primaryColor || '#ffffff';
                const effectType = this.settings.effect_type || 'none';

                let words = [];
                if (typeof subtitleData === 'string' && (subtitleData.includes('<') || subtitleData.includes('&'))) {
                    words = this.parseSubtitleHTML(subtitleData);
                } else if (typeof subtitleData === 'string') {
                    words = subtitleData.split(/\s+/).filter(w => w.length > 0).map(w => ({
                        text: w, bold: false, italic: false, color: null, sizeMultiplier: 1.0
                    }));
                } else if (Array.isArray(subtitleData)) {
                    words = subtitleData;
                }
                if (words.length === 0) return;

                const setWordFont = (wordObj, scaleMultiplier = 1.0) => {
                    const weight = wordObj.bold ? 'bold' : baseFontWeight;
                    const style = wordObj.italic ? 'italic' : '';
                    const size = baseFontSize * (wordObj.sizeMultiplier || 1.0) * scaleMultiplier;
                    ctx.font = `${style} ${weight} ${size}px ${fontFamily}`;
                };

                const maxWidth = canvas.width - (80 * scale);
                ctx.font = `${baseFontWeight} ${baseFontSize}px ${fontFamily}`;
                const spaceWidth = ctx.measureText(' ').width;
                const lines = [];
                let currentLine = [];
                let lineWidth = 0;

                for (const wordObj of words) {
                    setWordFont(wordObj);
                    const wordWidth = ctx.measureText(wordObj.text).width;
                    const testWidth = currentLine.length > 0 ? lineWidth + spaceWidth + wordWidth : wordWidth;
                    if (testWidth <= maxWidth) {
                        currentLine.push({ ...wordObj, width: wordWidth });
                        lineWidth = testWidth;
                    } else {
                        if (currentLine.length > 0) lines.push(currentLine);
                        currentLine = [{ ...wordObj, width: wordWidth }];
                        lineWidth = wordWidth;
                    }
                }
                if (currentLine.length > 0) lines.push(currentLine);

                const lineHeight = baseFontSize * 1.2;
                const totalHeight = lines.length * lineHeight;
                let startY;

                if (effectType === 'flash') startY = (canvas.height - lineHeight) / 2;
                else if (this.settings.subtitle_position === 'top') startY = 100 * scale;
                else if (this.settings.subtitle_position === 'middle') startY = (canvas.height - totalHeight) / 2;
                else if (this.settings.subtitle_position === 'custom' && this.settings.subtitle_top !== null) {
                    startY = ((this.settings.subtitle_top / 1920) * canvas.height) - (totalHeight / 2);
                } else startY = canvas.height - (100 * scale) - totalHeight;

                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';

                let globalWordCounter = 0;
                for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                    const line = lines[lineIndex];
                    const lineY = startY + lineIndex * lineHeight;
                    let lineTextWidth = 0;
                    for (let i = 0; i < line.length; i++) {
                        lineTextWidth += line[i].width;
                        if (i < line.length - 1) lineTextWidth += spaceWidth;
                    }

                    let xCenter;
                    if (effectType === 'flash' || effectType === 'dynamic_box') xCenter = canvas.width / 2;
                    else if (this.settings.subtitle_position === 'custom' && this.settings.subtitle_left !== null) {
                        xCenter = (this.settings.subtitle_left / 1080) * canvas.width;
                    } else xCenter = canvas.width / 2;
                    
                    let xPosStart;
                    if (this.settings.subtitle_position === 'custom' && effectType !== 'flash' && effectType !== 'dynamic_box') {
                        if (this.settings.subtitle_h_align === 'left') xPosStart = xCenter;
                        else if (this.settings.subtitle_h_align === 'right') xPosStart = xCenter - lineTextWidth;
                        else xPosStart = xCenter - (lineTextWidth / 2);
                    } else xPosStart = xCenter - (lineTextWidth / 2);

                    // Pass 1: Background box
                    if (effectType !== 'dynamic_box' && effectType !== 'flash') {
                        const boxPadding = 10 * scale;
                        const bgRgb = hexToRgb(this.settings.bgColor || '#000000');
                        ctx.fillStyle = `rgba(${bgRgb}, ${this.settings.bgOpacity})`;
                        ctx.fillRect(xPosStart - boxPadding, lineY, lineTextWidth + (boxPadding * 2), lineHeight);
                    }

                    // Pass 2: Words
                    let currentX = xPosStart;
                    for (let i = 0; i < line.length; i++) {
                        const wordObj = line[i];
                        const isHighlighted = (globalWordCounter === highlightedWordIndex);
                        
                        // Try to get timing for precise effects
                        let wStart = currentTime, wEnd = currentTime + 1;
                        if (this.wordTimestamps && this.wordTimestamps.length > 0) {
                            // This is a bit simplified, ideally we match precisely
                            const ts = this.wordTimestamps.find(wt => 
                                wt.word.toLowerCase().replace(/[.,!?;:"'\s]/g, '') === 
                                wordObj.text.toLowerCase().replace(/[.,!?;:"'\s]/g, '')
                            );
                            if (ts) { wStart = ts.start; wEnd = ts.end; }
                        }

                        const mods = this.getEffectMods(wordObj, currentTime, wStart, wEnd, isHighlighted);
                        if (mods.opacity > 0 && mods.text) {
                            setWordFont(wordObj, mods.scale * (mods.sizeMultiplier || 1.0));
                            const wordWidth = ctx.measureText(mods.text).width;
                            const drawX = currentX + (line[i].width / 2) + mods.offsetX;
                            const drawY = lineY + (lineHeight / 2) + mods.offsetY;

                            ctx.globalAlpha = mods.opacity;

                            // Dynamic Box
                            if (effectType === 'dynamic_box' && isHighlighted) {
                                ctx.fillStyle = this.settings.textColor || '#ffff00';
                                ctx.fillRect(currentX - 5*scale, lineY, line[i].width + 10*scale, lineHeight);
                                mods.color = this.settings.bgColor || '#000000';
                            }

                            // 3D Shadow
                            if (mods.customShadow) {
                                ctx.fillStyle = 'black';
                                for (let step = 1; step <= 4; step++) {
                                    ctx.fillText(mods.text, drawX + step * scale, drawY + step * scale);
                                }
                            } else {
                                ctx.strokeStyle = outlineColor;
                                ctx.lineWidth = Math.max(2 * scale, (baseFontSize * mods.scale) / 12);
                                ctx.strokeText(mods.text, drawX, drawY);
                            }

                            // Text & Glow
                            ctx.fillStyle = mods.color;
                            if (isHighlighted && mods.glowBlur > 0) {
                                ctx.shadowColor = this.settings.glowColor || mods.color;
                                ctx.shadowBlur = mods.glowBlur * scale;
                            } else ctx.shadowBlur = 0;

                            // Progressive Fill
                            if (effectType === 'progressive_fill' && isHighlighted) {
                                // Draw base
                                ctx.fillStyle = primaryColor;
                                ctx.fillText(mods.text, drawX, drawY);
                                // Clip and draw highlight
                                ctx.save();
                                const prog = Math.max(0, Math.min(1, (currentTime - wStart) / (wEnd - wStart)));
                                ctx.beginPath();
                                ctx.rect(currentX, lineY, line[i].width * prog, lineHeight);
                                ctx.clip();
                                ctx.fillStyle = mods.color;
                                ctx.fillText(mods.text, drawX, drawY);
                                ctx.restore();
                            } else {
                                ctx.fillText(mods.text, drawX, drawY);
                            }
                            
                            // Emoji
                            if (mods.emoji) {
                                ctx.font = `${24 * scale}px Arial`;
                                ctx.fillText(mods.emoji, drawX, lineY - 10 * scale);
                            }

                            ctx.globalAlpha = 1.0;
                            ctx.shadowBlur = 0;
                        }
                        currentX += line[i].width + spaceWidth;
                        globalWordCounter++;
                    }
                }
            }
        }

        // Custom position and alignment
        let customPosition = null; // left, top, width, centerX
        let horizontalAlign = 'center'; // 'left', 'center', 'right'
        let verticalAlign = 'middle'; // 'top', 'middle', 'bottom'

        function autoSaveTheme() {
            // Clear existing timeout
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }

            // Show saving indicator
            const indicator = document.getElementById('autosave-indicator');
            indicator.textContent = '‚è≥ Saving...';
            indicator.classList.add('show', 'saving');

            // Debounce save to avoid too many requests
            autoSaveTimeout = setTimeout(async () => {
                try {
                    const updates = {
                        folder: folderNumber,
                        theme: themeNumber,
                        title: document.getElementById('theme-name').textContent,
                        start: formatTime(startSeconds),
                        end: formatTime(endSeconds)
                    };

                    const response = await fetch('/api/update-theme', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(updates)
                    });

                    if (!response.ok) throw new Error('Failed to auto-save');

                    indicator.textContent = '‚úì Saved';
                    indicator.classList.remove('saving');

                    // Hide after 2 seconds
                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                } catch (error) {
                    indicator.textContent = '‚úó Save failed';
                    indicator.classList.remove('saving');
                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                }
            }, 500); // Wait 500ms after drag ends before saving
        }

        // Fine control nudge function
        function nudgeTheme(handle, delta) {
            const oldStart = startSeconds;
            const oldEnd = endSeconds;
            const midPoint = (originalStartSeconds + originalEndSeconds) / 2;
            
            const bufferStart = Math.max(0, originalStartSeconds - bufferLeftSeconds);
            const bufferEnd = Math.min(fullVideoDuration, originalEndSeconds + bufferRightSeconds);

            if (handle === 'left') {
                // Adjust start time
                let newStart = startSeconds + delta;
                // Restriction: between buffer start and midpoint-1s
                newStart = Math.max(bufferStart, Math.min(newStart, midPoint - 1.0));
                
                const timeOffset = newStart - startSeconds;
                
                // Shift subtitle formatting timestamps if start time changed
                if (Object.keys(allCueFormatting).length > 0 && timeOffset !== 0) {
                    for (const [seqKey, formatting] of Object.entries(allCueFormatting)) {
                        const oldTs = parseTime(formatting.timestamp);
                        const newTs = oldTs - timeOffset;
                        allCueFormatting[seqKey].timestamp = formatVttTime(newTs);
                    }
                    
                    // Save shifted formatting
                    fetch('/api/save-subtitle-formatting', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            folder: folderNumber,
                            theme: themeNumber,
                            formatting: allCueFormatting
                        })
                    });
                }
                
                startSeconds = newStart;
            } else if (handle === 'right') {
                // Adjust end time
                let newEnd = endSeconds + delta;
                // Restriction: between midpoint+1s and current buffer end
                newEnd = Math.max(midPoint + 1.0, Math.min(newEnd, bufferEnd));
                endSeconds = newEnd;
            }

            // Only update if something actually changed
            if (startSeconds !== oldStart || endSeconds !== oldEnd) {
                updateUI();
                
                // Update preview boundaries and seek to relevant part
                updatePreviewBoundaries();
                
                if (handle === 'left') {
                    originalVideo.currentTime = startSeconds;
                    // If start changed, we need a full preview video reload to reset boundaries
                    updatePreviewVideo();
                } else {
                    // Just update end boundary
                    if (previewVideo) previewVideo.dataset.themeEnd = endSeconds;
                }
                
                reloadSubtitleTrack();
                autoSaveTheme();
                updateTimeExtensionInputs();
            }
        }

        // Fine control nudge function for individual subtitle cues
        async function nudgeCueTiming(field, delta) {
            if (!currentCueInfo || !allThemeCues) return;

            // Find the cue in our local array
            const cueIndex = allThemeCues.findIndex(c => c.sequence === currentCueInfo.sequence);
            if (cueIndex === -1) return;

            const cue = allThemeCues[cueIndex];
            const oldStart = cue.start;
            const oldEnd = cue.end;

            // Calculate new times
            let newStartSec = parseTime(cue.start);
            let newEndSec = parseTime(cue.end);

            if (field === 'start') {
                newStartSec = Math.max(0, newStartSec + delta);
                // Ensure start doesn't cross end
                if (newStartSec >= newEndSec - 0.1) newStartSec = newEndSec - 0.1;
            } else {
                newEndSec = newEndSec + delta;
                // Ensure end doesn't cross start
                if (newEndSec <= newStartSec + 0.1) newEndSec = newStartSec + 0.1;
            }

            const newStart = formatVttTime(newStartSec).replace('.', ',');
            const newEnd = formatVttTime(newEndSec).replace('.', ',');

            // Update local objects
            cue.start = newStart;
            cue.end = newEnd;
            
            // If there's an edit cached for the old key, migrate it
            const oldKey = `${oldStart}_${oldEnd}`;
            const newKey = `${newStart}_${newEnd}`;
            if (subtitleEdits[oldKey]) {
                subtitleEdits[newKey] = subtitleEdits[oldKey];
                delete subtitleEdits[oldKey];
            }

            // Sync UI
            currentCueInfo.start = newStart;
            currentCueInfo.end = newEnd;
            
            // Force duration display update
            const durationValueEl = document.getElementById('subtitle-duration-value');
            if (durationValueEl) {
                const duration = newEndSec - newStartSec;
                durationValueEl.textContent = `${duration.toFixed(2)}s`;
                durationValueEl.style.color = duration < 0.8 ? '#ff9800' : '#00ff9d';
            }

            // Save to server
            try {
                const themeStart = parseFloat(previewVideo.dataset.themeStart) || 0;
                await fetch('/api/save-cue-timing', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        theme_start: themeStart,
                        sequence: cue.sequence,
                        old_start: oldStart,
                        old_end: oldEnd,
                        new_start: newStart,
                        new_end: newEnd
                    })
                });
                
                // Re-sync renderer
                updateSubtitlePreview();
            } catch (error) {
                console.error("Failed to save cue timing:", error);
            }
        }

        // Subtitle Split & Join functionality
        function resequenceCues() {
            const newFormatting = {};
            allThemeCues.forEach((c, i) => {
                const oldSeq = c.sequence;
                const newSeq = i + 1;
                // If this cue already had a sequence and it's in our formatting map, move it
                if (oldSeq && allCueFormatting[oldSeq]) {
                    newFormatting[newSeq] = allCueFormatting[oldSeq];
                    newFormatting[newSeq].sequence = newSeq;
                }
                c.sequence = newSeq;
            });
            allCueFormatting = newFormatting;
        }

        async function saveSubtitleRestructure() {
            console.log("üíæ Saving restructured subtitles to server...", allThemeCues.length, "cues");
            try {
                const themeStart = parseFloat(previewVideo.dataset.themeStart) || 0;
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd) || 0;
                const response = await fetch('/api/save-subtitle-restructure', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        theme_start: themeStart,
                        theme_end: themeEnd,
                        cues: allThemeCues
                    })
                });
                
                if (!response.ok) {
                    const errData = await response.json();
                    throw new Error(errData.error || 'Failed to save restructure');
                }

                // Also save the updated/shifted formatting map to server
                await fetch('/api/save-subtitle-formatting', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        formatting: allCueFormatting
                    })
                });
                
                showNotification("Subtitles restructured successfully", "success");
                console.log("‚úÖ Restructure saved successfully");
            } catch (error) {
                console.error("‚ùå Failed to save restructure:", error);
                showNotification("Restructure failed: " + error.message, "error");
            }
        }

        async function splitSubtitleAtCursor() {
            console.log("‚úÇÔ∏è Split requested");
            const editor = document.getElementById('subtitle-text');
            if (!editor) { console.error("Editor not found"); return; }
            
            const selection = window.getSelection();
            if (!selection.rangeCount) {
                console.warn("No selection range found");
                showNotification("Place cursor inside text area to split", "error");
                return;
            }
            
            const range = selection.getRangeAt(0);
            if (!editor.contains(range.startContainer)) {
                console.warn("Selection is outside editor");
                showNotification("Place cursor inside text area to split", "error");
                return;
            }

            const currentTime = previewVideo.currentTime;
            const cueIndex = allThemeCues.findIndex(c => {
                const s = parseTime(c.start);
                const e = parseTime(c.end);
                return currentTime >= s - 0.05 && currentTime <= e + 0.05;
            });
            
            console.log("Current Time:", currentTime, "Found Cue Index:", cueIndex);

            if (cueIndex === -1) {
                showNotification("No active subtitle to split at this time", "error");
                return;
            }
            
            const cue = allThemeCues[cueIndex];
            
            // Get content before and after cursor, preserving HTML
            const preRange = range.cloneRange();
            preRange.selectNodeContents(editor);
            preRange.setEnd(range.startContainer, range.startOffset);
            const part1Html = document.createElement('div');
            part1Html.appendChild(preRange.cloneContents());
            
            const postRange = range.cloneRange();
            postRange.selectNodeContents(editor);
            postRange.setStart(range.startContainer, range.startOffset);
            const part2Html = document.createElement('div');
            part2Html.appendChild(postRange.cloneContents());

            const part1 = part1Html.innerHTML.trim();
            const part2 = part2Html.innerHTML.trim();
            
            console.log("Split parts:", { part1, part2 });

            if (!part1 || !part2) {
                showNotification("Place cursor inside text to split (not at ends)", "error");
                return;
            }
            
            // Use text length for timing ratio
            const fullText = editor.innerText;
            const cursorOffset = preRange.toString().length;
            const ratio = cursorOffset / Math.max(1, fullText.length);
            
            const startSec = parseTime(cue.start);
            const endSec = parseTime(cue.end);
            const midSec = startSec + (endSec - startSec) * ratio;
            
            console.log("Splitting cue at:", midSec, "Ratio:", ratio);

            const newCue1 = {
                ...cue,
                text: part1,
                end: formatVttTime(midSec).replace('.', ',')
            };
            
            const newCue2 = {
                ...cue,
                start: formatVttTime(midSec).replace('.', ','),
                text: part2
            };
            
            allThemeCues.splice(cueIndex, 1, newCue1, newCue2);
            
            // Clear formatting for the original cue since it's now two separate parts
            delete allCueFormatting[cue.sequence];
            
            resequenceCues();
            
            // Clean up cached edits for the old cue
            delete subtitleEdits[`${cue.start}_${cue.end}`];
            
            await saveSubtitleRestructure();
            currentCueInfo = null; // Force UI refresh
            updateSubtitlePreview();
        }

        async function joinWithPrevious() {
            console.log("üîó Join Prev requested");
            const currentTime = previewVideo.currentTime;
            const cueIndex = allThemeCues.findIndex(c => {
                const s = parseTime(c.start);
                const e = parseTime(c.end);
                return currentTime >= s - 0.05 && currentTime <= e + 0.05;
            });
            
            console.log("Current Time:", currentTime, "Cue Index:", cueIndex);

            if (cueIndex <= 0) {
                showNotification("No previous subtitle to join with", "error");
                return;
            }
            
            const currentCue = allThemeCues[cueIndex];
            const prevCue = allThemeCues[cueIndex - 1];
            
            const oldKeyCurrent = `${currentCue.start}_${currentCue.end}`;
            const oldKeyPrev = `${prevCue.start}_${prevCue.end}`;
            
            prevCue.text = (prevCue.text + " " + currentCue.text).trim();
            prevCue.end = currentCue.end;
            
            allThemeCues.splice(cueIndex, 1);
            
            // Clear formatting for both original cues
            delete allCueFormatting[currentCue.sequence];
            delete allCueFormatting[prevCue.sequence];
            
            resequenceCues();
            
            // Clean up cached edits
            delete subtitleEdits[oldKeyCurrent];
            delete subtitleEdits[oldKeyPrev];
            
            await saveSubtitleRestructure();
            currentCueInfo = null; // Force UI refresh
            updateSubtitlePreview();
        }

        async function joinWithNext() {
            console.log("üîó Join Next requested");
            const currentTime = previewVideo.currentTime;
            const cueIndex = allThemeCues.findIndex(c => {
                const s = parseTime(c.start);
                const e = parseTime(c.end);
                return currentTime >= s - 0.05 && currentTime <= e + 0.05;
            });
            
            console.log("Current Time:", currentTime, "Cue Index:", cueIndex);

            if (cueIndex === -1 || cueIndex >= allThemeCues.length - 1) {
                showNotification("No next subtitle to join with", "error");
                return;
            }
            
            const currentCue = allThemeCues[cueIndex];
            const nextCue = allThemeCues[cueIndex + 1];
            
            const oldKeyCurrent = `${currentCue.start}_${currentCue.end}`;
            const oldKeyNext = `${nextCue.start}_${nextCue.end}`;
            
            currentCue.text = (currentCue.text + " " + nextCue.text).trim();
            currentCue.end = nextCue.end;
            
            allThemeCues.splice(cueIndex + 1, 1);
            
            // Clear formatting for both original cues
            delete allCueFormatting[currentCue.sequence];
            delete allCueFormatting[nextCue.sequence];
            
            resequenceCues();
            
            // Clean up cached edits
            delete subtitleEdits[oldKeyCurrent];
            delete subtitleEdits[oldKeyNext];
            
            await saveSubtitleRestructure();
            currentCueInfo = null; // Force UI refresh
            updateSubtitlePreview();
        }

        // Helper function to convert seconds to time input format (HH:MM:SS)
        function secondsToTimeInput(totalSeconds) {
            if (totalSeconds === null || totalSeconds === undefined || isNaN(totalSeconds)) {
                return '00:00:00';
            }
            totalSeconds = Math.round(Number(totalSeconds));
            const h = Math.floor(totalSeconds / 3600);
            const m = Math.floor((totalSeconds % 3600) / 60);
            const s = totalSeconds % 60;
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        // Helper function to get current subtitle styling settings
        function getCurrentSubtitleSettings() {
            const effectType = document.getElementById('effect-type')?.value || 'none';
            return {
                mode: effectType !== 'none' ? 
                      (document.getElementById('karaoke-mode')?.value || 'normal') : 'standard',
                effect_type: effectType,
                auto_emoji: document.getElementById('auto-emoji')?.checked || false,
                keyword_scaling: document.getElementById('keyword-scaling')?.checked || false,
                fontSize: parseInt(document.getElementById('subtitle-size')?.value || '48'),
                primaryColor: document.getElementById('subtitle-color')?.value || '#ffffff',
                textColor: document.getElementById('highlight-text-color')?.value || '#ffff00',
                pastColor: document.getElementById('past-color')?.value || '#808080',
                font_name: document.getElementById('subtitle-font')?.value || 'Arial',
                fontName: document.getElementById('subtitle-font')?.value || 'Arial',
                font_weight: document.getElementById('subtitle-bold')?.checked ? 'bold' : 'normal',
                glowColor: document.getElementById('highlight-glow-color')?.value || '#ffff00',
                glowBlur: parseInt(document.getElementById('highlight-glow-blur')?.value || '10'),
                bgColor: document.getElementById('subtitle-bg')?.value || '#000000',
                bgOpacity: parseInt(document.getElementById('subtitle-bg-opacity')?.value || '70') / 100,
                outlineColor: '#000000',
                subtitle_position: globalPosition,
                subtitle_h_align: horizontalAlign,
                subtitle_v_align: verticalAlign,
                subtitle_top: customPosition ? customPosition.top : null,
                subtitle_left: customPosition ? customPosition.centerX : null
            };
        }

        // Helper function to update time extension inputs
        function updateTimeExtensionInputs() {

            const extLeftEnd = document.getElementById('ext-left-end');
            const extRightEnd = document.getElementById('ext-right-end');


            if (extLeftEnd && extRightEnd &&
                originalStartSeconds !== null && originalStartSeconds !== undefined &&
                originalEndSeconds !== null && originalEndSeconds !== undefined &&
                startSeconds !== null && startSeconds !== undefined &&
                endSeconds !== null && endSeconds !== undefined) {

                const leftExtension = Math.max(0, originalStartSeconds - startSeconds);
                const rightExtension = Math.max(0, endSeconds - originalEndSeconds);


                extLeftEnd.value = secondsToTimeInput(leftExtension);
                extRightEnd.value = secondsToTimeInput(rightExtension);

            } else {
            }
        }

        // ============================================
        // Position Mode Functions (Global vs Current)
        // ============================================

        // Switch position mode (global or current)
        function setPositionMode(mode) {
            positionMode = mode;

            // Update button UI
            const buttons = document.querySelectorAll('.position-mode-btn');
            buttons.forEach(btn => {
                if (btn.dataset.mode === mode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Update position dropdown to match current value for the mode
            const positionSelect = document.getElementById('subtitle-position');
            if (mode === 'global') {
                // Show global position
                positionSelect.value = globalPosition;
            } else {
                // Show current cue's individual position (if exists)
                if (currentCueInfo && currentCueInfo.sequence) {
                    const formatting = allCueFormatting[currentCueInfo.sequence];
                    if (formatting && formatting.position) {
                        positionSelect.value = formatting.position;
                    } else {
                        // No individual position set, use global
                        positionSelect.value = globalPosition;
                    }
                } else {
                    positionSelect.value = globalPosition;
                }
            }

            updateSubtitlePreview();
        }

        // Save global position to server
        async function saveGlobalPosition(position) {

            // Get preview video element to calculate scale factor
            const previewVideo = document.getElementById('preview-video');
            const previewHeight = previewVideo.offsetHeight || 500;  // Default to 500px if not available
            const previewWidth = previewVideo.offsetWidth || 281;   // Default ~281px for 9:16

            // Target output resolution
            const targetWidth = 1080;
            const targetHeight = 1920;

            // Calculate scale factors
            const scaleX = targetWidth / previewWidth;
            const scaleY = targetHeight / previewHeight;


            // Calculate correct X position
            // We now always save the center point for custom positions to match our standardized rendering
            let leftToSave = null;
            let topToSave = null;
            if (customPosition) {
                // customPosition.centerX and top are already in logical 1080x1920 coords
                leftToSave = Math.round(customPosition.centerX);
                topToSave = Math.round(customPosition.top);
            }

            try {
                const response = await fetch('/api/save-global-position', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        position: position,
                        // Include scaled custom coordinates
                        left: leftToSave,
                        top: topToSave,
                        h_align: horizontalAlign,
                        v_align: verticalAlign,
                        // Include styling fields
                        fontSize: document.getElementById('subtitle-size').value,
                        subtitleBold: document.getElementById('subtitle-bold').checked,
                        primaryColor: document.getElementById('subtitle-color').value,
                        bgColor: document.getElementById('subtitle-bg').value,
                        bgOpacity: document.getElementById('subtitle-bg-opacity').value,
                        fontName: document.getElementById('subtitle-font').value
                    })
                });


                if (!response.ok) {
                    const errorText = await response.text();
                    return false;
                }

                const result = await response.json();

                globalPosition = position;
                return true;
            } catch (error) {
                return false;
            }
        }

        // Load global position from server
        async function loadGlobalPosition() {

            try {
                const response = await fetch(`/api/get-global-position?folder=${folderNumber}&theme=${themeNumber}`);

                if (!response.ok) {
                    globalPosition = 'bottom';
                    customPosition = null;
                    return 'bottom';
                }

                const data = await response.json();
                globalPosition = data.position || 'bottom';

                // Check if it's a custom position with coordinates
                if (data.position === 'custom' && data.left !== null && data.top !== null) {
                    const hAlign = data.h_align || 'center';

                    // Get preview video element to calculate scale factor
                    const previewVideo = document.getElementById('preview-video');
                    const previewHeight = previewVideo?.offsetHeight || 500;
                    const previewWidth = previewVideo?.offsetWidth || 281;

                    // Target output resolution
                    const targetWidth = 1080;
                    const targetHeight = 1920;

                    // Calculate scale factors (output -> preview)
                    const scaleX = previewWidth / targetWidth;
                    const scaleY = previewHeight / targetHeight;


                    // Scale coordinates from output resolution to preview resolution
                    const scaledLeft = data.left * scaleX;
                    const scaledTop = data.top * scaleY;

                    // Convert saved position back to preview coordinates
                    let leftEdge;
                    if (hAlign === 'center') {
                        // Saved value is center point - use directly with transform
                        leftEdge = scaledLeft;
                    } else if (hAlign === 'right') {
                        // Saved value is right edge - estimate left edge
                        leftEdge = scaledLeft - 200; // Will be adjusted by preview positioning
                    } else {
                        // Saved value is left edge - use directly
                        leftEdge = scaledLeft;
                    }

                    customPosition = {
                        left: data.left,
                        top: data.top,
                        centerX: data.left,
                        width: null
                    };
                    horizontalAlign = hAlign;
                    verticalAlign = data.v_align || 'middle';
                    hasManualPosition = true;  // Mark as having manual position since we loaded custom coordinates

                    // Update align buttons to match loaded values
                    updateAlignButtons(horizontalAlign, verticalAlign);

                } else {
                    customPosition = null;
                }

                // Update dropdown to match global position
                const positionSelect = document.getElementById('subtitle-position');
                if (positionSelect && positionMode === 'global') {
                    positionSelect.value = globalPosition;
                }
                
                // Load and apply additional styling fields if present
                if (data.font_size !== undefined && data.font_size !== null) document.getElementById('subtitle-size').value = data.font_size;
                if (data.subtitle_bold !== undefined && data.subtitle_bold !== null) document.getElementById('subtitle-bold').checked = data.subtitle_bold;
                if (data.primary_color) document.getElementById('subtitle-color').value = data.primary_color;
                if (data.bg_color) document.getElementById('subtitle-bg').value = data.bg_color;
                if (data.bg_opacity !== undefined && data.bg_opacity !== null) {
                    const opacity = parseFloat(data.bg_opacity);
                    document.getElementById('subtitle-bg-opacity').value = opacity > 1 ? opacity : opacity * 100;
                }
                if (data.font_name) document.getElementById('subtitle-font').value = data.font_name;

                return globalPosition;
            } catch (error) {
                globalPosition = 'bottom';
                customPosition = null;
                return 'bottom';
            }
        }

        // Handle position dropdown change based on current mode
        async function handlePositionChange(newPosition) {

            // Clear custom position only when a preset is selected
            if (newPosition !== 'custom') {
                customPosition = null;
                hasManualPosition = false;
            } else {
                // If switching TO custom but we don't have a position yet,
                // initialize it from current rendering center
                if (!customPosition) {
                    const scale = canvas.height / 1920;
                    let initialTop = canvas.height - (100 * scale);
                    if (globalPosition === 'top') initialTop = (100 * scale);
                    else if (globalPosition === 'middle') initialTop = canvas.height / 2;
                    
                    customPosition = {
                        left: canvas.width / 2,
                        top: initialTop,
                        centerX: canvas.width / 2,
                        width: 0
                    };
                }
                hasManualPosition = true;
            }

            if (positionMode === 'global') {
                globalPosition = newPosition;
                // Save to global (adjust.md)
                await saveGlobalPosition(newPosition);
                updateSubtitlePreview();
            } else {
                // Save to current cue (JSON)
                updateSubtitlePreview();
                await saveCurrentCueFormatting();
            }
        }

        // Load all theme cues for editing
        async function loadThemeCues() {
            console.log("üì• Loading theme cues...");
            try {

                // Load ALL cues from original SRT (not filtered by theme range)
                // This allows styling subtitles in expanded timeline areas
                // Add cache-buster to ensure we get fresh response
                const cacheBuster = Date.now();
                const response = await fetch(`/api/all-subtitles/${folderNumber}?theme=${themeNumber}&_=${cacheBuster}`);


                if (!response.ok) {
                    console.warn("‚ö†Ô∏è API all-subtitles failed, using fallback");
                    // Fallback to theme-filtered API
                    const fallbackResponse = await fetch(`/api/theme-subtitles/${folderNumber}/${themeNumber}`);
                    if (!fallbackResponse.ok) return [];
                    const data = await fallbackResponse.json();
                    allThemeCues = data.cues;
                    console.log("‚úÖ Loaded", allThemeCues.length, "cues from fallback");

                    // Load subtitle edits from server into cache
                    if (data.edits && Object.keys(data.edits).length > 0) {
                        subtitleEdits = {};
                        for (const [key, editData] of Object.entries(data.edits)) {
                            subtitleEdits[key] = typeof editData === 'string' ? editData : editData.text;
                        }
                    }

                    return allThemeCues;
                }

                const data = await response.json();
                allThemeCues = data.cues;
                console.log("‚úÖ Loaded", allThemeCues.length, "cues from primary API");

                // Load subtitle edits from server into cache
                // This ensures edits persist across page refreshes
                if (data.edits && Object.keys(data.edits).length > 0) {
                    subtitleEdits = {};
                    for (const [key, editData] of Object.entries(data.edits)) {
                        // editData is either a string (old format) or an object with 'text' property (new format)
                        subtitleEdits[key] = typeof editData === 'string' ? editData : editData.text;
                    }
                }

                // Apply any cached subtitle edits
                for (const [key, editText] of Object.entries(subtitleEdits)) {
                    const [startKey, endKey] = key.split('_');
                    
                    // First try exact match
                    let cueIndex = allThemeCues.findIndex(cue => cue.start === startKey && cue.end === endKey);
                    
                    // Fallback: match by start and end time with tolerance
                    if (cueIndex === -1) {
                        const targetStart = parseTime(startKey);
                        const targetEnd = parseTime(endKey);
                        cueIndex = allThemeCues.findIndex(cue => 
                            Math.abs(parseTime(cue.start) - targetStart) < 0.1 &&
                            Math.abs(parseTime(cue.end) - targetEnd) < 0.1
                        );
                    }

                    if (cueIndex !== -1) {
                        allThemeCues[cueIndex].text = editText;
                    }
                }

                return allThemeCues;
            } catch (error) {
                return [];
            }
        }

        // Load subtitle formatting metadata
        async function loadSubtitleFormatting() {
            try {
                const response = await fetch(`/api/subtitle-formatting/${folderNumber}/${themeNumber}`);
                if (!response.ok) return;

                const data = await response.json();
                allCueFormatting = data.formatting || {};

                // CRITICAL FIX: Convert absolute timestamps to relative timestamps
                // If the JSON has entries with absolute timestamps (e.g., "00:00:10.000")
                // convert them to relative times (e.g., "00:00:00.000") by subtracting themeStart
                if (startSeconds !== null && startSeconds !== undefined && Object.keys(allCueFormatting).length > 0) {
                    const absoluteKeysToRemove = [];
                    const newEntries = {};

                    for (const [timestamp, formatting] of Object.entries(allCueFormatting)) {
                        const timestampSeconds = parseTime(timestamp);

                        // Check if this looks like an absolute timestamp (>= theme start)
                        if (timestampSeconds >= startSeconds - 0.5) { // Allow 0.5s tolerance
                            // This looks like an absolute timestamp, convert to relative
                            const relativeSeconds = timestampSeconds - startSeconds;
                            const relativeTimestamp = formatVttTime(relativeSeconds);

                            // Check if a relative version already exists
                            if (allCueFormatting[relativeTimestamp]) {
                                // Relative version exists, keep it and remove absolute
                                absoluteKeysToRemove.push(timestamp);
                            } else {
                                // No relative version exists, move the formatting
                                newEntries[relativeTimestamp] = formatting;
                                absoluteKeysToRemove.push(timestamp);
                            }
                        }
                    }

                    // Remove absolute timestamp entries
                    for (const key of absoluteKeysToRemove) {
                        delete allCueFormatting[key];
                    }

                    // Add converted entries
                    Object.assign(allCueFormatting, newEntries);

                    if (absoluteKeysToRemove.length > 0) {
                        // Save the corrected version
                        fetch('/api/save-subtitle-formatting', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder: folderNumber,
                                theme: themeNumber,
                                formatting: allCueFormatting
                            })
                        });
                    }
                }

                // Clean up duplicate entries (caused by Math.max(0, ...) bug fix)
                // Remove entries like "00:00:00.000" if "-00:00:00.001" exists (same subtitle)
                const keysToRemove = [];
                const keys = Object.keys(allCueFormatting);

                // Find duplicates: positive and negative versions of ~same time
                for (const key of keys) {
                    if (key.startsWith('-')) {
                        const absSeconds = Math.abs(parseTime(key));
                        // Check if there's a corresponding positive key
                        for (const otherKey of keys) {
                            if (!otherKey.startsWith('-')) {
                                const otherSeconds = parseTime(otherKey);
                                // If positive key is within 1 second of absolute negative key
                                if (Math.abs(otherSeconds - absSeconds) < 0.01) {
                                    // Mark positive key for removal (keep negative version)
                                    if (!keysToRemove.includes(otherKey)) {
                                        keysToRemove.push(otherKey);
                                    }
                                }
                            }
                        }
                    }
                }

                // Remove duplicates
                for (const key of keysToRemove) {
                    delete allCueFormatting[key];
                }

                if (keysToRemove.length > 0) {
                    // Save cleaned up version
                    fetch('/api/save-subtitle-formatting', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            folder: folderNumber,
                            theme: themeNumber,
                            formatting: allCueFormatting
                        })
                    });
                }

                // MIGRATION: Detect old format (timestamp_hash keys) and migrate to sequence keys
                // Old format keys contain ':' or '_' (e.g., "00:00:00.000_364d")
                // New format keys are simple numbers (e.g., "1", "2", "3")
                const formattingKeys = Object.keys(allCueFormatting);
                const hasOldFormatKeys = formattingKeys.some(key => key.includes(':') || key.includes('_'));

                if (hasOldFormatKeys && formattingKeys.length > 0) {

                    // Ensure allThemeCues is loaded
                    if (allThemeCues.length === 0) {
                        await loadThemeCues();
                    }

                    // Helper to extract timestamp from old key (handle both "timestamp" and "timestamp_hash")
                    const extractTimestamp = (key) => {
                        if (key.includes('_')) {
                            return key.split('_')[0]; // "00:00:00.000_364d" ‚Üí "00:00:00.000"
                        }
                        return key; // Already just timestamp
                    };

                    // Create new formatting with sequence keys
                    const newFormatting = {};
                    let migratedCount = 0;

                    for (const [oldKey, formatting] of Object.entries(allCueFormatting)) {
                        const timestamp = extractTimestamp(oldKey);

                        // Find matching cue by timestamp and text
                        const matchingCue = allThemeCues.find(cue => {
                            // Match by timestamp and optionally by text if available
                            const timestampMatch = cue.start === timestamp;
                            const textMatch = !formatting._text || cue.text === formatting._text;
                            return timestampMatch && textMatch;
                        });

                        if (matchingCue && matchingCue.sequence) {
                            // Migrate to new format with sequence key
                            newFormatting[matchingCue.sequence] = {
                                sequence: matchingCue.sequence,
                                timestamp: timestamp,
                                html: formatting.html,
                                _text: formatting._text || matchingCue.text
                            };
                            migratedCount++;
                        } else {
                            // Couldn't find match, keep old entry (will be cleaned up later)
                            newFormatting[oldKey] = formatting;
                        }
                    }

                    // Update allCueFormatting with migrated data
                    allCueFormatting = newFormatting;

                    // Save migrated format to server
                    if (migratedCount > 0) {
                        fetch('/api/save-subtitle-formatting', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder: folderNumber,
                                theme: themeNumber,
                                formatting: allCueFormatting
                            })
                        }).then(() => {
                        }).catch(err => {
                        });
                    }
                }

                // Convert <font> tags to <span style="..."> for better CSS compatibility
                const fontSizeMap = { '1': 0.6, '2': 0.8, '3': 1.0, '4': 1.2, '5': 1.4, '6': 1.6, '7': 1.8 };

                const convertFontTags = (html) => {
                    // Pattern: <font color="#..." size="X">text</font>
                    return html.replace(/<font\s+([^>]+)>/gi, (match, attributes) => {
                        let color = '';
                        let size = '';

                        // Extract color attribute
                        const colorMatch = attributes.match(/color="([^"]+)"/);
                        if (colorMatch) {
                            color = `color: ${colorMatch[1]}; `;
                        }

                        // Extract size attribute and convert to em
                        const sizeMatch = attributes.match(/size="([^"]+)"/);
                        if (sizeMatch) {
                            const sizeValue = sizeMatch[1];
                            const emValue = fontSizeMap[sizeValue] || 1.0;
                            size = `font-size: ${emValue}em; `;
                        }

                        return `<span style="${color}${size}">`;
                    }).replace(/<\/font>/gi, '</span>');
                };

                for (const cueStart in allCueFormatting) {
                    const cueData = allCueFormatting[cueStart];
                    if (cueData.html) {
                        const originalHtml = cueData.html;
                        cueData.html = convertFontTags(cueData.html);
                        if (originalHtml !== cueData.html) {
                        }
                    }
                }


                // Don't apply formatting here - let the cuechange handler apply it
                // when each cue becomes active (avoids applying wrong cue's formatting)
            } catch (error) {
            }
        }

        // Auto-save subtitle edit
        function autoSaveSubtitle() {
            if (subtitleAutoSaveTimeout) {
                clearTimeout(subtitleAutoSaveTimeout);
            }

            subtitleAutoSaveTimeout = setTimeout(async () => {
                try {
                    const textarea = document.getElementById('subtitle-text');
                    const newText = textarea.innerText.trim();

                    // Don't save if there's no text or no current cue
                    if (!newText || !currentCueInfo || currentCueInfo.start == null || currentCueInfo.end == null) {
                        return;
                    }

                    // Show saving indicator
                    const indicator = document.getElementById('preview-autosave-indicator');
                    indicator.textContent = '‚è≥ Saving...';
                    indicator.classList.add('show', 'saving');

                    // Save to server
                    const themeStart = parseFloat(previewVideo.dataset.themeStart) || 0;
                    const saveResponse = await fetch('/api/save-cue-text', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            folder: folderNumber,
                            theme: themeNumber,
                            theme_start: themeStart,
                            cue_start: currentCueInfo.start,
                            cue_end: currentCueInfo.end,
                            text: newText
                        })
                    });

                    if (!saveResponse.ok) {
                        const errorData = await saveResponse.json();
                        throw new Error(errorData.error || 'Failed to save to server');
                    }

                    const saveResult = await saveResponse.json();

                    // Store edit in local cache for persistence across page interactions
                    const editKey = `${currentCueInfo.start}_${currentCueInfo.end}`;
                    subtitleEdits[editKey] = newText;

                    // Update in-memory cues
                    const cueIndex = allThemeCues.findIndex(cue =>
                        cue.start === currentCueInfo.start && cue.end === currentCueInfo.end
                    );

                    if (cueIndex !== -1) {
                        allThemeCues[cueIndex].text = newText;
                    }

                    // Update canvas renderer
                    updateSubtitlePreview();

                    indicator.textContent = '‚úì Saved';
                    indicator.classList.remove('saving');

                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                } catch (error) {
                    const indicator = document.getElementById('preview-autosave-indicator');
                    indicator.textContent = '‚úó Save failed';
                    indicator.classList.remove('saving');
                    setTimeout(() => {
                        indicator.classList.remove('show');
                    }, 2000);
                }
            }, 800); // Wait 800ms after typing stops
        }

        // Load theme details
        async function loadTheme() {
            try {
                const response = await fetch(`/api/folder/${folderNumber}/themes`);
                if (!response.ok) throw new Error('Failed to load theme');

                const data = await response.json();
                themeData = data.themes.find(t => t.number === themeNumber);
                
                if (data.fps) {
                    videoFps = parseFloat(data.fps);
                    console.log(`üé¨ Video FPS: ${videoFps}`);
                }

                if (!themeData) throw new Error('Theme not found');

                // Store ORIGINAL values from themes.md (for reset button)
                originalStartSeconds = parseTime(themeData.start);
                originalEndSeconds = parseTime(themeData.end);

                // Use ADJUSTED values for display if they exist, otherwise use original
                if (themeData.adjusted_start && themeData.adjusted_end) {
                    startSeconds = parseTime(themeData.adjusted_start);
                    endSeconds = parseTime(themeData.adjusted_end);
                } else {
                    startSeconds = originalStartSeconds;
                    endSeconds = originalEndSeconds;
                }

                // Use adjusted title if available
                const displayTitle = themeData.adjusted_title || themeData.title || '';

                // Construct video path from folder and actual video filename
                if (data.video_filename) {
                    videoPath = `videos/${data.folder}/${encodeURIComponent(data.video_filename)}`;
                } else {
                    // Fallback: try to construct from title (old behavior)
                    videoPath = `videos/${data.folder}/${encodeURIComponent(data.title)}.mp4`;
                }

                // Update info display
                document.getElementById('theme-number').textContent = `Theme ${themeData.number}`;
                document.getElementById('theme-name').textContent = displayTitle;
                const fullPath = `videos/${data.folder}`;
                const folderLocationEl = document.getElementById('folder-location');
                folderLocationEl.textContent = fullPath;
                folderLocationEl.title = fullPath;

                // Update header with theme info
                document.getElementById('header-title').textContent = `Adjust Theme ${themeData.number}`;
                document.getElementById('header-theme-name').textContent = displayTitle;

                // Load all theme cues for subtitle editing (must be awaited for sequence matching)
                await loadThemeCues();

                // Initialize subtitle-text from loaded cues if possible, otherwise fall back to themeData
                // This ensures edited text is shown immediately on load
                const firstCue = allThemeCues.find(cue => {
                    const cueStart = parseTime(cue.start);
                    return cueStart >= startSeconds - 0.5;
                });
                document.getElementById('subtitle-text').innerHTML = firstCue ? firstCue.text : (themeData.text || '');

                // Load subtitle formatting metadata and apply to editor
                await loadSubtitleFormatting();

                // Load global position from adjust.md
                await loadGlobalPosition();

                // Promise wrapper for video loading
                const loadVideo = (video, src) => {
                    return new Promise((resolve, reject) => {
                        video.addEventListener('loadedmetadata', () => {
                            fullVideoDuration = video.duration;
                            resolve();
                        }, { once: true });

                        video.addEventListener('error', (e) => {
                            reject(new Error('Failed to load video'));
                        }, { once: true });

                        video.src = src;
                    });
                };

                // Load original video first to get full duration
                await loadVideo(originalVideo, videoPath);

                // Calculate buffer range
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);
                bufferedDuration = bufferEnd - bufferStart;

                // Load preview with theme clip range
                previewVideo.src = `${videoPath}#t=${startSeconds},${endSeconds}`;

                // Wait for preview to load
                await loadVideo(previewVideo, previewVideo.src);

                // Load original video with buffered range - this makes seekbar show buffer duration
                originalVideo.src = `${videoPath}#t=${bufferStart},${bufferEnd}`;

                // Wait for original video to reload with range
                await new Promise(resolve => {
                    originalVideo.addEventListener('loadedmetadata', () => {
                        // Update buffer info display
                        document.getElementById('buffer-info').textContent =
                            `Buffer range: ${formatTime(bufferStart)} - ${formatTime(bufferEnd)} (${formatTime(bufferedDuration)})`;

                        // Set video position to theme start time
                        originalVideo.currentTime = startSeconds;

                        resolve();
                    }, { once: true });
                });

                // Show content
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('content').classList.remove('hidden');

                // Initial UI update
                updateUI();
                setupDragHandlers();

                // Setup custom video controls
                setupVideoControls();

                // Initialize time extension inputs with current theme extension values
                updateTimeExtensionInputs();

            } catch (error) {
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('error').textContent = error.message;
                document.getElementById('error').classList.remove('hidden');
            }
        }

        // Update original video playback range (buffered range)
        function updateOriginalVideoRange() {
            if (!videoPath || !fullVideoDuration || startSeconds === null || startSeconds === undefined || endSeconds === null || endSeconds === undefined) return;

            const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
            const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);
            bufferedDuration = bufferEnd - bufferStart;

            // Set video to buffer start position if outside range
            if (originalVideo.currentTime < bufferStart || originalVideo.currentTime > bufferEnd) {
                originalVideo.currentTime = bufferStart;
            }
        }

        // Update preview video with clipped range
        function reloadSubtitleTrack() {
            // VTT track is no longer used, we now render everything on Canvas
            if (!previewVideo || !folderNumber || !themeNumber) return;

            // Clear editor and preview state
            currentCueInfo = null;
            const subtitleText = document.getElementById('subtitle-text');
            if (subtitleText) subtitleText.innerHTML = '';

            // Renderer will automatically pick up changes on next frame update
            if (previewVideo.paused) {
                previewVideo.dispatchEvent(new Event('timeupdate'));
            }
        }

        function updatePreviewBoundaries() {
            // Update only the theme boundaries without resetting video
            // This is called during timeline drag to keep preview in sync
            if (!previewVideo || startSeconds === null || startSeconds === undefined || endSeconds === null || endSeconds === undefined) return;

            // Update boundary markers
            previewVideo.dataset.themeStart = startSeconds;
            previewVideo.dataset.themeEnd = endSeconds;
        }

        function updatePreviewVideo() {
            if (!videoPath || startSeconds === null || startSeconds === undefined || endSeconds === null || endSeconds === undefined) return;

            // Load full video and use JavaScript to enforce theme boundaries
            // Add cache-busting parameter to force reload when src doesn't change
            previewVideo.src = videoPath + (videoPath.includes('?') ? '&' : '?') + 't=' + Date.now();
            previewVideo.loop = true;
            previewVideo.muted = false;

            // Store theme boundaries for enforcement
            previewVideo.dataset.themeStart = startSeconds;
            previewVideo.dataset.themeEnd = endSeconds;

            // Remove old listeners
            if (previewVideo.boundariesHandler) {
                previewVideo.removeEventListener('timeupdate', previewVideo.boundariesHandler);
            }
            if (previewVideo.timeUpdateHandler) {
                previewVideo.removeEventListener('timeupdate', previewVideo.timeUpdateHandler);
            }
            if (previewVideo.subtitleSyncHandler) {
                previewVideo.removeEventListener('timeupdate', previewVideo.subtitleSyncHandler);
            }
            if (previewVideo.seekbarHandler) {
                previewSeekbar.removeEventListener('input', previewVideo.seekbarHandler);
            }
            if (previewVideo.playBtnHandler) {
                previewPlayBtn.removeEventListener('click', previewVideo.playBtnHandler);
            }
            if (previewVideo.clickHandler) {
                previewVideo.removeEventListener('click', previewVideo.clickHandler);
            }
            if (previewVideo.playHandler) {
                previewVideo.removeEventListener('play', previewVideo.playHandler);
            }
            if (previewVideo.pauseHandler) {
                previewVideo.removeEventListener('pause', previewVideo.pauseHandler);
            }

            // Enforce theme boundaries and loop
            const enforceThemeBoundaries = () => {
                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd);

                // If video is past theme end and playing, loop back to start
                if (previewVideo.currentTime >= themeEnd && !previewVideo.paused) {
                    previewVideo.currentTime = themeStart;
                }
            };

            // Sync current subtitle from our local cues to textarea based on video time
            const syncSubtitleToTextarea = () => {
                if (!allThemeCues || allThemeCues.length === 0) return;

                const currentTime = previewVideo.currentTime;
                const subtitleText = document.getElementById('subtitle-text');
                const durationValueEl = document.getElementById('subtitle-duration-value');

                // Find matching cue in our stable list
                const matchingCue = allThemeCues.find(cue => {
                    const cueStart = parseTime(cue.start);
                    const cueEnd = parseTime(cue.end);
                    return currentTime >= cueStart && currentTime <= cueEnd;
                });

                if (matchingCue) {
                    const currentCueText = subtitleEdits[`${matchingCue.start}_${matchingCue.end}`] || matchingCue.text;
                    
                    // Update duration display
                    if (durationValueEl) {
                        const cueStart = parseTime(matchingCue.start);
                        const cueEnd = parseTime(matchingCue.end);
                        const duration = cueEnd - cueStart;
                        durationValueEl.textContent = `${duration.toFixed(2)}s`;
                        // Highlight short durations (less than 0.8s) in orange/red
                        durationValueEl.style.color = duration < 0.8 ? '#ff9800' : '#00ff9d';
                    }

                    const newCueInfo = {
                        sequence: matchingCue.sequence,
                        start: matchingCue.start,
                        end: matchingCue.end,
                        text: currentCueText
                    };

                    // Only update if we've moved to a different cue
                    if (!currentCueInfo || currentCueInfo.start !== newCueInfo.start) {
                        currentCueInfo = newCueInfo;
                        isProgrammaticUpdate = true;

                        // Load saved formatting
                        const formatting = allCueFormatting[matchingCue.sequence];
                        if (formatting && formatting.html) {
                            subtitleText.focus();
                            document.execCommand('selectAll', false, null);
                            document.execCommand('insertHTML', false, formatting.html);
                            
                            // Update positioning state
                            if (formatting.customPosition) {
                                const rect = previewVideo.getBoundingClientRect();
                                const scaleX = rect.width / 1080;
                                const scaleY = rect.height / 1920;
                                customPosition = {
                                    left: formatting.customPosition.left * scaleX,
                                    top: formatting.customPosition.top * scaleY,
                                    centerX: (formatting.customPosition.centerX || formatting.customPosition.left) * scaleX
                                };
                            }
                        } else {
                            subtitleText.innerHTML = currentCueText;
                        }
                        
                        isProgrammaticUpdate = false;
                        updateSubtitlePreview();
                    }
                } else {
                    // No active cue
                    if (currentCueInfo !== null) {
                        currentCueInfo = null;
                        subtitleText.innerHTML = '';
                        if (durationValueEl) {
                            durationValueEl.textContent = '0.00s';
                            durationValueEl.style.color = '#00ff9d';
                        }
                        updateSubtitlePreview();
                    }
                }
            };

            // Update time display and seekbar
            const updateTimeDisplay = () => {
                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd);
                const currentTime = previewVideo.currentTime;

                // Show time relative to theme start
                const relativeTime = currentTime - themeStart;
                const themeDuration = themeEnd - themeStart;

                // Update seekbar position (0-100% of theme duration)
                const seekbarPercent = (Math.max(0, relativeTime) / themeDuration) * 100;
                previewSeekbar.value = seekbarPercent;

                // Update time display
                document.getElementById('preview-time-display').textContent =
                    `${formatTime(Math.max(0, relativeTime))} / ${formatTime(themeDuration)}`;
            };

            // Handle seekbar input
            const handleSeekbarInput = () => {
                if (videoControlsLocked) return;

                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd);
                const themeDuration = themeEnd - themeStart;

                // Calculate target time based on seekbar percentage
                const relativeTime = (previewSeekbar.value / 100) * themeDuration;
                previewVideo.currentTime = themeStart + relativeTime;
            };

            // Toggle play/pause
            const togglePlayPause = () => {
                if (videoControlsLocked) return;

                if (previewVideo.paused) {
                    previewVideo.play();
                } else {
                    previewVideo.pause();
                }
            };

            // Update play button icon
            const updatePlayButton = () => {
                previewPlayBtn.textContent = previewVideo.paused ? '‚ñ∂' : '‚è∏';
            };

            // Add new listeners
            previewVideo.boundariesHandler = enforceThemeBoundaries;
            previewVideo.addEventListener('timeupdate', enforceThemeBoundaries);

            previewVideo.subtitleSyncHandler = syncSubtitleToTextarea;
            previewVideo.addEventListener('timeupdate', syncSubtitleToTextarea);

            previewVideo.timeUpdateHandler = updateTimeDisplay;
            previewVideo.addEventListener('timeupdate', updateTimeDisplay);

            // Add word highlighting handler for karaoke preview
            previewVideo.wordHighlightHandler = () => {
                if (karaokeEnabled) {
                    updatePreviewWordHighlighting(previewVideo.currentTime);
                }

                // Canvas rendering handler
                if (canvasRenderer) {
                    try {
                        let subtitleText = '';
                        let currentCue = null;
                        const editor = document.getElementById('subtitle-text');

                        if (allThemeCues && allThemeCues.length > 0) {
                            const currentTime = previewVideo.currentTime;
                            currentCue = allThemeCues.find(cue => {
                                const cueStart = parseTime(cue.start);
                                const cueEnd = parseTime(cue.end);
                                return currentTime >= cueStart && currentTime <= cueEnd;
                            });

                            if (editor && editor.innerHTML.trim()) {
                                // Use editor's HTML for rich-text preview if it's not empty
                                subtitleText = editor.innerHTML.trim();
                            } else if (currentCue) {
                                // Use saved HTML if available for this cue
                                const formatting = allCueFormatting[currentCue.sequence];
                                subtitleText = (formatting && formatting.html) ? formatting.html : currentCue.text;
                            }
                        }

                        // Get the currently highlighted word index from word timestamps (if applicable)
                        let highlightedWordIndex = -1;
                        const mode = canvasRenderer.settings.mode || 'standard';
                        
                        if (mode !== 'standard' && wordTimestamps && wordTimestamps.length > 0 && subtitleText && currentCue) {
                            const currentTime = previewVideo.currentTime;
                            const currentCueStart = parseTime(currentCue.start);
                            const currentCueEnd = parseTime(currentCue.end);
                            const wordsInCurrentCue = subtitleText.split(/\s+/).filter(w => w.length > 0);

                            const EPSILON = 0.05;
                            const wordsInCueRange = wordTimestamps.filter(wt => 
                                wt.start >= currentCueStart - EPSILON && wt.start < currentCueEnd - EPSILON
                            );

                            if (wordsInCueRange.length > 0) {
                                const activeWordTsIndex = wordsInCueRange.findIndex(w => currentTime >= w.start && currentTime < w.end);
                                if (activeWordTsIndex !== -1) {
                                    // POSITIONAL matching: highlight the i-th word in the subtitle
                                    highlightedWordIndex = activeWordTsIndex;
                                }
                            }
                        }

                        // Use unified renderer
                        canvasRenderer.renderFrame(previewVideo.currentTime, subtitleText, highlightedWordIndex);
                    } catch (error) {
                        console.error("Canvas render error:", error);
                    }
                }
            };
            previewVideo.addEventListener('timeupdate', previewVideo.wordHighlightHandler);

            previewVideo.seekbarHandler = handleSeekbarInput;
            previewSeekbar.addEventListener('input', handleSeekbarInput);

            previewVideo.playBtnHandler = togglePlayPause;
            previewPlayBtn.addEventListener('click', togglePlayPause);

            previewVideo.clickHandler = togglePlayPause;
            previewVideo.addEventListener('click', togglePlayPause);

            previewVideo.playHandler = updatePlayButton;
            previewVideo.addEventListener('play', updatePlayButton);

            previewVideo.pauseHandler = updatePlayButton;
            previewVideo.addEventListener('pause', updatePlayButton);

            // Frame navigation with robust long-press support
            const prevFrameBtn = document.getElementById('preview-prev-frame');
            const nextFrameBtn = document.getElementById('preview-next-frame');
            let scanInterval = null;
            let scanDelayTimeout = null;

            const doStep = (direction) => {
                const frameDuration = 1 / videoFps;
                const themeStart = parseFloat(previewVideo.dataset.themeStart) || 0;
                const themeEnd = parseFloat(previewVideo.dataset.themeEnd) || previewVideo.duration;

                if (direction === 'prev') {
                    previewVideo.currentTime = Math.max(themeStart, previewVideo.currentTime - frameDuration);
                } else {
                    previewVideo.currentTime = Math.min(themeEnd, previewVideo.currentTime + frameDuration);
                }
            };

            const startScanning = (e, direction) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Clear any existing state
                stopScanning();
                
                previewVideo.pause();
                
                // Immediate first step
                doStep(direction);

                // Wait 400ms before starting continuous scan (auto-repeat)
                scanDelayTimeout = setTimeout(() => {
                    // Repeat every 60ms (~16fps) for a smooth feel
                    scanInterval = setInterval(() => {
                        // Optional: skip if video is still busy seeking
                        if (!previewVideo.seeking) {
                            doStep(direction);
                        }
                    }, 60);
                }, 400);
            };

            const stopScanning = () => {
                if (scanDelayTimeout) {
                    clearTimeout(scanDelayTimeout);
                    scanDelayTimeout = null;
                }
                if (scanInterval) {
                    clearInterval(scanInterval);
                    scanInterval = null;
                }
            };

            if (prevFrameBtn) {
                prevFrameBtn.addEventListener('mousedown', (e) => startScanning(e, 'prev'));
                prevFrameBtn.addEventListener('touchstart', (e) => startScanning(e, 'prev'), {passive: false});
                prevFrameBtn.addEventListener('mouseup', stopScanning);
                prevFrameBtn.addEventListener('mouseleave', stopScanning);
                prevFrameBtn.addEventListener('touchend', stopScanning);
                prevFrameBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); });
            }

            if (nextFrameBtn) {
                nextFrameBtn.addEventListener('mousedown', (e) => startScanning(e, 'next'));
                nextFrameBtn.addEventListener('touchstart', (e) => startScanning(e, 'next'), {passive: false});
                nextFrameBtn.addEventListener('mouseup', stopScanning);
                nextFrameBtn.addEventListener('mouseleave', stopScanning);
                nextFrameBtn.addEventListener('touchend', stopScanning);
                nextFrameBtn.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); });
            }

            // When video loads metadata, seek to theme start
            previewVideo.addEventListener('loadedmetadata', () => {
                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                previewVideo.currentTime = themeStart;
                updateTimeDisplay();
                updatePlayButton();

                // Clear ALL subtitle state to prevent stale display
                // Do NOT enable track here - let reloadSubtitleTrack() handle it
                currentCueInfo = null;

                const subtitleText = document.getElementById('subtitle-text');
                if (subtitleText) {
                    subtitleText.innerHTML = '';
                }

                // Do NOT enable track here - reloadSubtitleTrack() will handle it
                // Enabling the track here would cause old cues to be displayed before
                // reloadSubtitleTrack() replaces the track with the updated one
            }, { once: true });

            // Fallback: Also seek after a delay in case loadedmetadata doesn't fire
            // This can happen when the browser thinks the video src hasn't changed
            setTimeout(() => {
                const themeStart = parseFloat(previewVideo.dataset.themeStart);
                if (previewVideo.currentTime !== themeStart && previewVideo.readyState >= 2) {
                    previewVideo.currentTime = themeStart;
                    updateTimeDisplay();
                }
            }, 500);

            // Reset subtitle state for current theme
            currentCueInfo = null;

            const subtitleTextClear = document.getElementById('subtitle-text');
            if (subtitleTextClear) {
                subtitleTextClear.innerHTML = '';
            }

            if (folderNumber && themeNumber) {
            }


            // Don't autoplay
            // previewVideo.play().catch(() => {});
        }

        // Update UI
        function updateUI() {
            if (!fullVideoDuration) return;

            const clipDuration = endSeconds - startSeconds;
            // Buffer range is relative to ORIGINAL theme boundaries
            const bufferStart = Math.max(0, originalStartSeconds - bufferLeftSeconds);
            const bufferEnd = Math.min(fullVideoDuration, originalEndSeconds + bufferRightSeconds);
            bufferedDuration = bufferEnd - bufferStart;

            if (timelineZoomed) {
                // ZOOMED MODE: Track width = bufferedDuration
                bufferRange.style.left = '0%';
                bufferRange.style.width = '100%';

                const themeLeftPercent = ((startSeconds - bufferStart) / bufferedDuration) * 100;
                const themeWidthPercent = (clipDuration / bufferedDuration) * 100;
                themeBox.style.left = `${themeLeftPercent}%`;
                themeBox.style.width = `${themeWidthPercent}%`;

                document.getElementById('time-start-marker').textContent = formatTime(bufferStart);
                document.getElementById('time-end-marker').textContent = formatTime(bufferEnd);
                
                // Update button text
                const zoomBtn = document.getElementById('toggle-zoom-btn');
                if (zoomBtn) zoomBtn.textContent = 'üîç Full View';
            } else {
                // FULL VIEW: Track width = fullVideoDuration
                const bufferLeftPercent = (bufferStart / fullVideoDuration) * 100;
                const bufferWidthPercent = (bufferedDuration / fullVideoDuration) * 100;
                bufferRange.style.left = `${bufferLeftPercent}%`;
                bufferRange.style.width = `${bufferWidthPercent}%`;

                const themeLeftPercent = ((startSeconds - bufferStart) / bufferedDuration) * 100;
                const themeWidthPercent = (clipDuration / bufferedDuration) * 100;
                themeBox.style.left = `${themeLeftPercent}%`;
                themeBox.style.width = `${themeWidthPercent}%`;

                document.getElementById('time-start-marker').textContent = '00:00:00';
                document.getElementById('time-end-marker').textContent = formatTime(fullVideoDuration);
                
                // Update button text
                const zoomBtn = document.getElementById('toggle-zoom-btn');
                if (zoomBtn) zoomBtn.textContent = 'üîç Zoom to Buffer';
            }

            themeBoxContent.textContent = `${formatTime(startSeconds)} - ${formatTime(endSeconds)}`;

            // Position midpoint marker
            const midPoint = (originalStartSeconds + originalEndSeconds) / 2;
            const midPointMarker = document.getElementById('midpoint-marker');
            if (midPointMarker) {
                // Since midpoint-marker is now inside buffer-range, calculate position relative to buffer
                const midPointPercent = ((midPoint - bufferStart) / bufferedDuration) * 100;
                midPointMarker.style.left = `${midPointPercent}%`;
                // Show only if within buffer range
                midPointMarker.style.display = (midPoint >= bufferStart && midPoint <= bufferEnd) ? 'block' : 'none';
            }

            // Update info display
            document.getElementById('display-start').textContent = formatTime(startSeconds);
            document.getElementById('display-end').textContent = formatTime(endSeconds);
            document.getElementById('display-duration').textContent = formatTime(clipDuration);

            // Update buffer display with separate left/right values
            const bufferLeftMin = Math.round(bufferLeftSeconds / 60);
            const bufferRightMin = Math.round(bufferRightSeconds / 60);
            document.getElementById('buffer-display').textContent = `L: ¬±${bufferLeftMin}min | R: ¬±${bufferRightMin}min`;

            // Update buffer info on video
            document.getElementById('buffer-info').textContent =
                `Buffer range: ${formatTime(bufferStart)} - ${formatTime(bufferEnd)} (${formatTime(bufferedDuration)})`;

            // Update subtitle preview
            updateSubtitlePreview();

            // Update preview video during drag by updating boundaries
            // Don't reset the video (which causes position 0 issue)
            if (!isDragging) {
                // Not dragging - do full preview video update
                updatePreviewVideo();
            } else {
                // During drag - only update boundaries, don't reset video
                updatePreviewBoundaries();
            }

            // NOTE: Don't reload subtitle track during drag - only after drag completes
            // This prevents continuous reloading which causes performance issues

            // Update original video to show only buffered range (but not during drag)
            if (!isDragging) {
                updateOriginalVideoRange();
            }
        }

        // Setup drag handlers
        function setupDragHandlers() {
            // Left handle - adjust start time
            handleLeft.addEventListener('mousedown', (e) => {
                isDragging = 'left';
                dragStartX = e.clientX;
                dragStartValue = startSeconds;
                themeStartBeforeDrag = startSeconds; // Track theme start before drag
                e.preventDefault();
                e.stopPropagation();
            });

            // Right handle - adjust end time
            handleRight.addEventListener('mousedown', (e) => {
                isDragging = 'right';
                dragStartX = e.clientX;
                dragStartValue = endSeconds;
                themeEndBeforeDrag = endSeconds; // Track theme end before drag
                e.preventDefault();
                e.stopPropagation();
            });

            // Hover effects - highlight theme box edges
            handleLeft.addEventListener('mouseenter', () => {
                themeBox.classList.add('highlight-left');
            });

            handleLeft.addEventListener('mouseleave', () => {
                themeBox.classList.remove('highlight-left');
            });

            handleRight.addEventListener('mouseenter', () => {
                themeBox.classList.add('highlight-right');
            });

            handleRight.addEventListener('mouseleave', () => {
                themeBox.classList.remove('highlight-right');
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - dragStartX;
                // Scale movement based on zoom level
                const timeScale = timelineZoomed ? bufferedDuration : fullVideoDuration;
                const deltaTime = (deltaX / timelineTrack.offsetWidth) * timeScale;
                
                const midPoint = (originalStartSeconds + originalEndSeconds) / 2;
                
                // Current buffer boundaries
                const bufferStart = Math.max(0, originalStartSeconds - bufferLeftSeconds);
                const bufferEnd = Math.min(fullVideoDuration, originalEndSeconds + bufferRightSeconds);

                if (isDragging === 'left') {
                    let newStart = dragStartValue + deltaTime;
                    // Restriction: between current buffer start and midpoint-1s
                    newStart = Math.max(bufferStart, Math.min(newStart, midPoint - 1.0));
                    startSeconds = newStart;
                } else if (isDragging === 'right') {
                    let newEnd = dragStartValue + deltaTime;
                    // Restriction: between midpoint+1s and current buffer end
                    newEnd = Math.max(midPoint + 1.0, Math.min(newEnd, bufferEnd));
                    endSeconds = newEnd;
                }

                updateUI();
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {

                    // Calculate theme start offset when dragging left handle
                    const timeOffset = startSeconds - themeStartBeforeDrag;

                    if (isDragging === 'left' && timeOffset !== 0) {

                        // CRITICAL: Update timestamps only, don't regenerate keys
                        // Sequence keys are stable and don't change
                        // Update timestamp field for each sequence key
                        for (const [seqKey, formatting] of Object.entries(allCueFormatting)) {
                            const oldSeconds = parseTime(formatting.timestamp);
                            const newSeconds = oldSeconds - timeOffset;  // Subtract offset
                            allCueFormatting[seqKey].timestamp = formatVttTime(newSeconds);
                        }


                        // Save formatting to server with updated timestamps
                        fetch('/api/save-subtitle-formatting', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder: folderNumber,
                                theme: themeNumber,
                                formatting: allCueFormatting
                            })
                        }).then(res => res.json())
                    }

                    // Handle right-side drag (theme end changes)
                    // Formatting keys are relative to themeStart, so they don't need to shift
                    // But we need to save to ensure styles are preserved
                    if (isDragging === 'right') {
                        const themeEndOffset = endSeconds - themeEndBeforeDrag;

                        if (themeEndOffset !== 0) {

                            // For right-side drag, we don't shift keys (they're relative to themeStart)
                            // But we save to ensure styles are preserved even if subtitles are now out of bounds
                            fetch('/api/save-subtitle-formatting', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    folder: folderNumber,
                                    theme: themeNumber,
                                    formatting: allCueFormatting
                                })
                            }).then(res => res.json())
                        }
                    }

                    // Drag ended - clear subtitle state FIRST before any video updates
                    // This prevents old cues from being displayed during the update process
                    currentCueInfo = null;

                    const subtitleText = document.getElementById('subtitle-text');
                    if (subtitleText) {
                        subtitleText.innerHTML = '';
                    }

                    // Seek original video to new theme start position
                    originalVideo.currentTime = startSeconds;

                    // Now that drag is complete, do full preview video update with new time range
                    updatePreviewVideo();

                    // Reload subtitle track with new time range
                    reloadSubtitleTrack();

                    // Note: adjustedCues logic removed, shorts_creator handles trimming

                    // Auto-save theme adjustment
                    autoSaveTheme();

                    // Update time extension inputs to reflect new theme boundaries
                    updateTimeExtensionInputs();
                }
                isDragging = null;
            });

            // Video buffer controls - adjust buffer on each side independently

            // Left side controls - adjust buffer before theme
            const leftDecreaseBtn = document.getElementById('video-buffer-decrease-left');
            const leftIncreaseBtn = document.getElementById('video-buffer-increase-left');
            const rightDecreaseBtn = document.getElementById('video-buffer-decrease-right');
            const rightIncreaseBtn = document.getElementById('video-buffer-increase-right');

            leftDecreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferLeftSeconds = Math.max(0, bufferLeftSeconds - 60);
                updateUI();
            });

            leftIncreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferLeftSeconds += 60;
                updateUI();
            });

            // Right side controls - adjust buffer after theme
            rightDecreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferRightSeconds = Math.max(0, bufferRightSeconds - 60);
                updateUI();
            });

            rightIncreaseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                e.preventDefault();
                bufferRightSeconds += 60;
                updateUI();
            });

            // Toggle timeline zoom
            const toggleZoomBtn = document.getElementById('toggle-zoom-btn');
            if (toggleZoomBtn) {
                toggleZoomBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    timelineZoomed = !timelineZoomed;
                    updateUI();
                });
            }

            // Helper function to convert time input (HH:MM:SS) to seconds
            const timeInputToSeconds = (timeInput) => {
                const parts = timeInput.split(':');
                if (parts.length === 3) {
                    const [h, m, s] = parts.map(Number);
                    return h * 3600 + m * 60 + s;
                }
                return 0;
            };

            // Apply left extension time from input fields
            const applyExtLeftBtn = document.getElementById('apply-ext-left');
            if (applyExtLeftBtn) {
                applyExtLeftBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();

                    const extLeftEnd = document.getElementById('ext-left-end');

                    if (extLeftEnd) {
                        const extensionSeconds = timeInputToSeconds(extLeftEnd.value);
                        const midPoint = (originalStartSeconds + originalEndSeconds) / 2;
                        const bufferStart = Math.max(0, originalStartSeconds - bufferLeftSeconds);

                        // Move theme start earlier by the extension amount
                        // Restriction: between buffer start and midpoint-1s
                        const newStartSeconds = Math.max(bufferStart, Math.min(originalStartSeconds - extensionSeconds, midPoint - 1.0));

                        // Handle formatting timestamp shift when theme start changes
                        const timeOffset = newStartSeconds - startSeconds;

                        if (Object.keys(allCueFormatting).length > 0 && timeOffset !== 0) {
                            // Update timestamps for each sequence key
                            for (const [seqKey, formatting] of Object.entries(allCueFormatting)) {
                                const oldSeconds = parseTime(formatting.timestamp);
                                const newSeconds = oldSeconds - timeOffset;
                                allCueFormatting[seqKey].timestamp = formatVttTime(newSeconds);
                            }

                            // Save formatting to server
                            fetch('/api/save-subtitle-formatting', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    folder: folderNumber,
                                    theme: themeNumber,
                                    formatting: allCueFormatting
                                })
                            }).then(res => res.json())
                        }

                        startSeconds = newStartSeconds;

                        updateUI();
                        updatePreviewVideo();
                        reloadSubtitleTrack();

                        // Save adjusted theme boundaries to server
                        autoSaveTheme();
                    }
                });
            }

            // Apply right extension time from input fields
            const applyExtRightBtn = document.getElementById('apply-ext-right');
            if (applyExtRightBtn) {
                applyExtRightBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();

                    const extRightEnd = document.getElementById('ext-right-end');

                    if (extRightEnd) {
                        const extensionSeconds = timeInputToSeconds(extRightEnd.value);
                        const midPoint = (originalStartSeconds + originalEndSeconds) / 2;
                        const bufferEnd = Math.min(fullVideoDuration, originalEndSeconds + bufferRightSeconds);

                        // Move theme end later by the extension amount
                        // Restriction: between midpoint+1s and current buffer end
                        const newEndSeconds = Math.min(bufferEnd, Math.max(originalEndSeconds + extensionSeconds, midPoint + 1.0));

                        endSeconds = newEndSeconds;

                        updateUI();
                        updatePreviewVideo();
                        reloadSubtitleTrack();

                        // Save adjusted theme boundaries to server
                        autoSaveTheme();
                    }
                });
            }

            // Reset timeline button - reset to original theme time range
            const resetTimelineBtn = document.getElementById('reset-timeline-btn');
            if (resetTimelineBtn) {
                resetTimelineBtn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    e.preventDefault();

                    const currentStart = startSeconds;
                    const timeOffset = originalStartSeconds - currentStart;


                    // CRITICAL: Update timestamps only, don't regenerate keys
                    // Sequence keys are stable and don't change
                    if (Object.keys(allCueFormatting).length > 0 && timeOffset !== 0) {
                        // Update timestamp field for each sequence key
                        for (const [seqKey, formatting] of Object.entries(allCueFormatting)) {
                            const oldSeconds = parseTime(formatting.timestamp);
                            const newSeconds = oldSeconds - timeOffset;  // Subtract offset
                            allCueFormatting[seqKey].timestamp = formatVttTime(newSeconds);
                        }

                    }

                    // Save formatting to server with updated keys
                    const saveResponse = await fetch('/api/save-subtitle-formatting', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            folder: folderNumber,
                            theme: themeNumber,
                            formatting: allCueFormatting
                        })
                    });

                    if (!saveResponse.ok) {
                    } else {
                        const saveData = await saveResponse.json();
                    }

                    // Reset to original values
                    startSeconds = originalStartSeconds;
                    endSeconds = originalEndSeconds;

                    // Keep currentCueInfo but don't clear formatting - styles should be preserved
                    currentCueInfo = null;

                    // Update UI (includes original video)
                    updateUI();

                    // IMPORTANT: Explicitly seek original video to the reset position
                    // This ensures the original video updates even if it's already in buffer range
                    originalVideo.currentTime = startSeconds;

                    // Update preview video with new time range
                    updatePreviewVideo();

                    // Reload subtitle track with new time range
                    reloadSubtitleTrack();

                    // Update time extension inputs - after reset they should be 00:00:00
                    updateTimeExtensionInputs();

                    // Delete the adjust file on server
                    try {
                        const response = await fetch('/api/reset-theme', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder: folderNumber,
                                theme: themeNumber
                            })
                        });

                        if (!response.ok) throw new Error('Failed to reset theme');

                        // Visual feedback
                        resetTimelineBtn.textContent = '‚úì Reset Complete';
                        setTimeout(() => {
                            resetTimelineBtn.innerHTML = '‚Ü∫ Reset to Original';
                        }, 1500);
                    } catch (error) {
                        resetTimelineBtn.textContent = '‚úó Reset Failed';
                        setTimeout(() => {
                            resetTimelineBtn.innerHTML = '‚Ü∫ Reset to Original';
                        }, 1500);
                    }
                });
            }
        }

        // Setup custom video controls
        function setupVideoControls() {
            // Set initial volume
            originalVideo.volume = volumeSlider.value;

            // Play/Pause button
            playPauseBtn.addEventListener('click', () => {
                if (originalVideo.paused) {
                    originalVideo.play();
                    playPauseBtn.textContent = '‚è∏';
                } else {
                    originalVideo.pause();
                    playPauseBtn.textContent = '‚ñ∂';
                }
            });

            // Update play/pause button when video state changes
            originalVideo.addEventListener('play', () => {
                playPauseBtn.textContent = '‚è∏';
            });

            originalVideo.addEventListener('pause', () => {
                playPauseBtn.textContent = '‚ñ∂';
            });

            // Update seekbar as video plays
            originalVideo.addEventListener('timeupdate', () => {
                // Calculate position within buffer range
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);

                // Keep video within buffer range
                if (originalVideo.currentTime < bufferStart) {
                    originalVideo.currentTime = bufferStart;
                } else if (originalVideo.currentTime > bufferEnd) {
                    originalVideo.currentTime = bufferEnd;
                    originalVideo.pause();
                }

                // Update seekbar (0-100% of buffer)
                const positionInBuffer = originalVideo.currentTime - bufferStart;
                const percent = (positionInBuffer / bufferedDuration) * 100;
                seekbar.value = percent;

                // Update time display (showing time relative to buffer start)
                timeDisplay.textContent = `${formatTime(positionInBuffer)} / ${formatTime(bufferedDuration)}`;

                // Render subtitles on original video side if enabled
                const subsEnabled = document.getElementById('subtitles-toggle')?.checked;
                if (subsEnabled && originalCanvasRenderer) {
                    try {
                        let subtitleText = '';
                        if (allThemeCues && allThemeCues.length > 0) {
                            const currentTime = originalVideo.currentTime;
                            const currentCue = allThemeCues.find(cue => {
                                const cueStart = parseTime(cue.start);
                                const cueEnd = parseTime(cue.end);
                                return currentTime >= cueStart && currentTime <= cueEnd;
                            });
                            if (currentCue) {
                                subtitleText = currentCue.text;
                            }
                        }
                        
                        // We don't do real-time editor preview on original side, just show stable cues
                        originalCanvasRenderer.renderFrame(originalVideo.currentTime, subtitleText);
                    } catch (error) {
                        console.error("Original canvas render error:", error);
                    }
                } else if (originalCanvas) {
                    // Clear canvas if subtitles disabled
                    const ctx = originalCanvas.getContext('2d');
                    ctx.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
                }
            });

            // Seek when user drags seekbar
            seekbar.addEventListener('input', () => {
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const percent = seekbar.value;
                const positionInBuffer = (percent / 100) * bufferedDuration;
                originalVideo.currentTime = bufferStart + positionInBuffer;
            });

            // Jump to theme start
            jumpStartBtn.addEventListener('click', () => {
                originalVideo.currentTime = startSeconds;
            });

            // Jump to theme end
            jumpEndBtn.addEventListener('click', () => {
                originalVideo.currentTime = endSeconds;
            });

            // Volume control
            volumeSlider.addEventListener('input', () => {
                originalVideo.volume = volumeSlider.value;
            });

            // Click on video to play/pause
            originalVideo.addEventListener('click', () => {
                if (originalVideo.paused) {
                    originalVideo.play();
                } else {
                    originalVideo.pause();
                }
            });

            // Update seekbar theme markers
            const updateSeekbarTheme = () => {
                const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
                const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);

                // Calculate theme position within buffer (as percentage)
                const themeStartPercent = ((startSeconds - bufferStart) / bufferedDuration) * 100;
                const themeEndPercent = ((endSeconds - bufferStart) / bufferedDuration) * 100;

                // Set CSS custom properties for gradient
                seekbar.style.setProperty('--theme-start', `${themeStartPercent}%`);
                seekbar.style.setProperty('--theme-end', `${themeEndPercent}%`);
                seekbar.classList.add('theme-marked');

                // Position marker at center of theme range
                const themeCenterPercent = (themeStartPercent + themeEndPercent) / 2;
                themeMarker.style.left = `${themeCenterPercent}%`;

                // Update theme duration text
                const themeDuration = endSeconds - startSeconds;
                themeDurationText.textContent = formatTime(themeDuration);
            };

            // Set initial seekbar and time display
            seekbar.max = 100;

            // Calculate initial position in buffer (theme start position)
            const bufferStart = Math.max(0, startSeconds - bufferLeftSeconds);
            const bufferEnd = Math.min(fullVideoDuration, endSeconds + bufferRightSeconds);
            const positionInBuffer = originalVideo.currentTime - bufferStart;
            const seekbarPercent = (positionInBuffer / bufferedDuration) * 100;

            seekbar.value = seekbarPercent;
            timeDisplay.textContent = `${formatTime(positionInBuffer)} / ${formatTime(bufferedDuration)}`;

            // Apply theme markers to seekbar
            updateSeekbarTheme();

            // Update theme markers when theme range changes
            const originalUpdateUI = updateUI;
            updateUI = function() {
                originalUpdateUI();
                updateSeekbarTheme();
            };
        }

        // Update subtitle preview
        function updateSubtitlePreview() {
            const editor = document.getElementById('subtitle-text');
            const previewVideo = document.getElementById('preview-video');
            
            if (!canvasRenderer) return;

            // Sync editor font-weight with global bold setting
            if (editor) {
                editor.style.fontWeight = document.getElementById('subtitle-bold')?.checked ? 'bold' : 'normal';
            }

            // Get current styling settings
            const settings = getCurrentSubtitleSettings();

            // Update both renderer settings
            canvasRenderer.settings = settings;
            if (originalCanvasRenderer) {
                originalCanvasRenderer.settings = settings;
            }

            // Trigger a re-render if videos are paused
            if (previewVideo && previewVideo.paused) {
                previewVideo.dispatchEvent(new Event('timeupdate'));
            }
            if (originalVideo && originalVideo.paused) {
                originalVideo.dispatchEvent(new Event('timeupdate'));
            }
        }

        // Helper: hex to rgb
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '0, 0, 0';
        }

        // Rich text toolbar functions
        function toggleStyle(style) {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            // Use execCommand which properly handles overlapping selections
            // and preserves existing formatting better than manual DOM manipulation
            document.execCommand(style === 'bold' ? 'bold' : 'italic', false, null);

            // Update the preview video overlay to show the change
            updateSubtitlePreview();

            // Save the formatting for the current cue
            saveCurrentCueFormatting();
        }

        function applyColor(color) {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            // Use execCommand which properly handles overlapping selections
            // styleWithCSS=false gives us <b> tags instead of <span style="font-weight: bold;">
            document.execCommand('styleWithCSS', false, false);
            document.execCommand('foreColor', false, color);

            // Update the preview video overlay to show the change
            updateSubtitlePreview();

            // Save the formatting for the current cue
            saveCurrentCueFormatting();
            
            // Ensure focus is restored
            editor.focus();
        }

        function applySize(multiplier) {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;
            const range = selection.getRangeAt(0);
            const selectionText = range.toString();
            if (selectionText.trim().length === 0) return;

            // Find current font size
            let currentSizeEm = 1.0;
            
            // Start searching from the common ancestor of the selection
            let tempNode = range.commonAncestorContainer;
            if (tempNode.nodeType === Node.TEXT_NODE) tempNode = tempNode.parentElement;
            
            let existingSpan = null;
            let checkNode = tempNode;
            
            // Go up until we find a font-size or hit the editor
            while (checkNode && checkNode !== editor.parentNode) {
                if (checkNode.style && checkNode.style.fontSize) {
                    const emMatch = checkNode.style.fontSize.match(/([\d.]+)em/);
                    if (emMatch) {
                        currentSizeEm = parseFloat(emMatch[1]);
                        // If this span matches the selection text, we can update it directly
                        if (checkNode.innerText.trim() === selectionText.trim()) {
                            existingSpan = checkNode;
                        }
                        break;
                    }
                    const pxMatch = checkNode.style.fontSize.match(/([\d.]+)px/);
                    if (pxMatch) {
                        currentSizeEm = parseFloat(pxMatch[1]) / 16;
                        if (checkNode.innerText.trim() === selectionText.trim()) {
                            existingSpan = checkNode;
                        }
                        break;
                    }
                }
                if (checkNode.nodeName === 'FONT' && checkNode.getAttribute('size')) {
                    const sizeMap = { '1': 0.5, '2': 0.7, '3': 0.9, '4': 1.0, '5': 1.2, '6': 1.4, '7': 1.6 };
                    currentSizeEm = sizeMap[checkNode.getAttribute('size')] || 1.0;
                    break;
                }
                if (checkNode === editor) break;
                checkNode = checkNode.parentNode;
            }

            // Calculate new size
            let newSizeEm = currentSizeEm * multiplier;
            // Clamp between 0.5 and 5.0
            newSizeEm = Math.max(0.5, Math.min(5.0, newSizeEm));

            if (existingSpan) {
                // Optimization: Directly update existing span if it perfectly matches selection
                existingSpan.style.fontSize = newSizeEm.toFixed(2) + 'em';
            } else {
                // Use document.execCommand with a unique size value to mark the selection
                // '7' is usually safe as it's rarely used by default
                // We use a reset first to ensure the marker is always applied fresh
                document.execCommand('fontSize', false, '3');
                document.execCommand('fontSize', false, '7');
                
                // Find all newly created font tags and replace them with styled spans
                const fontTags = Array.from(editor.querySelectorAll('font[size="7"]'));
                const newSpans = [];
                fontTags.forEach(font => {
                    const s = document.createElement('span');
                    s.style.fontSize = newSizeEm.toFixed(2) + 'em';
                    while (font.firstChild) s.appendChild(font.firstChild);
                    font.parentNode.replaceChild(s, font);
                    newSpans.push(s);
                });

                // Restore selection to the new spans
                if (newSpans.length > 0) {
                    const newRange = document.createRange();
                    if (newSpans.length === 1) {
                        // Select inside the span to ensure next click finds it
                        newRange.selectNodeContents(newSpans[0]);
                    } else {
                        newRange.setStartBefore(newSpans[0]);
                        newRange.setEndAfter(newSpans[newSpans.length - 1]);
                    }
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                }
            }

            editor.focus();
            updateSubtitlePreview();
            saveCurrentCueFormatting();
        }

        function removeFormatting() {
            const editor = document.getElementById('subtitle-text');
            editor.focus();

            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);

                // Only apply if there's actual text selected
                if (range.toString().trim().length > 0) {
                    // Remove all formatting using execCommand
                    document.execCommand('removeFormat', false, null);
                }
            }

            // Update the preview video overlay to show the change
            updateSubtitlePreview();

            // Save the formatting for the current cue
            saveCurrentCueFormatting();
        }

        // Save formatting for the current cue
        async function saveCurrentCueFormatting() {
            if (!currentCueInfo) {
                return;
            }

            const editor = document.getElementById('subtitle-text');

            // Save the actual HTML as the source of truth
            // We'll store the HTML and parse it when needed
            // Use sequence as key (stable SRT sequence number)
            const key = currentCueInfo.sequence;

            // CRITICAL: Cannot save without sequence number (cue matching failed)
            if (key === null) {
                // Try to reload cues and retry once
                if (allThemeCues.length === 0) {
                    await loadThemeCues();
                    // Retry after loading
                    const retryCue = allThemeCues.find(cue =>
                        cue.start === currentCueInfo.timestamp &&
                        cue.end === currentCueInfo.end &&
                        cue.text === currentCueInfo.text
                    );
                    if (retryCue && retryCue.sequence) {
                        currentCueInfo.sequence = retryCue.sequence;
                        // Recursively call save after updating sequence
                        return await saveCurrentCueFormatting();
                    }
                }
                return; // Cannot save without sequence
            }

            allCueFormatting[key] = {
                sequence: key,
                timestamp: currentCueInfo.timestamp,
                html: editor.innerHTML,
                _text: currentCueInfo.text  // Store text for debugging
            };


            // Also extract simplified formatting info for preview
            const bold = editor.querySelector('strong') !== null;
            const italic = editor.querySelector('em') !== null;

            // Extract color - check both font tags and span styles
            let color = null;
            const colorSpan = editor.querySelector('span[style*="color"]');
            if (colorSpan && colorSpan.style.color) {
                color = colorSpan.style.color;
            } else {
                // Check for font tag with color attribute
                const fontTag = editor.querySelector('font[color]');
                if (fontTag && fontTag.color) {
                    color = fontTag.color;
                }
            }

            // Check for font size in multiple formats
            let size = null;

            // Check span elements with font-size in em
            const sizeSpan = editor.querySelector('span[style*="font-size"]');
            if (sizeSpan && sizeSpan.style.fontSize) {
                // Check for em units first
                const emMatch = sizeSpan.style.fontSize.match(/([\d.]+)em/);
                if (emMatch) {
                    size = parseFloat(emMatch[1]);
                } else {
                    // If not em, it's probably pixels - convert back to em relative to base font size
                    // Base font size is typically 16px in browsers
                    const pxMatch = sizeSpan.style.fontSize.match(/([\d.]+)px/);
                    if (pxMatch) {
                        size = parseFloat(pxMatch[1]) / 16; // Convert to em (relative to 16px base)
                    }
                }
            }

            // Also check for HTML font tags (fallback from execCommand)
            if (!size) {
                const fontTag = editor.querySelector('font[size]');
                if (fontTag && fontTag.size) {
                    // HTML font size is 1-7, map to multipliers: 1=0.5, 2=0.7, 3=0.9, 4=1.0, 5=1.2, 6=1.4, 7=1.6
                    const fontSizeMap = { '1': 0.5, '2': 0.7, '3': 0.9, '4': 1.0, '5': 1.2, '6': 1.4, '7': 1.6 };
                    size = fontSizeMap[fontTag.size];
                }
            }

            allCueFormatting[key].bold = bold;
            allCueFormatting[key].italic = italic;
            allCueFormatting[key].color = color;
            allCueFormatting[key].size = size;

            // Get current position from dropdown
            const positionSelect = document.getElementById('subtitle-position');
            const position = positionSelect ? positionSelect.value : null;
            allCueFormatting[key].position = position;

            // Save custom position and alignment if set
            if (customPosition) {
                // Scale coordinates from preview to output resolution
                const previewVideo = document.getElementById('preview-video');
                const scaleX = 1080 / (previewVideo?.offsetWidth || 281);
                const scaleY = 1920 / (previewVideo?.offsetHeight || 500);

                allCueFormatting[key].customPosition = {
                    left: customPosition.left * scaleX,
                    top: customPosition.top * scaleY,
                    centerX: customPosition.centerX ? customPosition.centerX * scaleX : null,
                    width: customPosition.width ? customPosition.width * scaleX : null
                };
            }
            allCueFormatting[key].horizontalAlign = horizontalAlign;
            allCueFormatting[key].verticalAlign = verticalAlign;

            subtitleFormatting = { ...allCueFormatting[key] };

            // Debug: log what's being saved

            // Show saving indicator
            const indicator = document.getElementById('preview-autosave-indicator');
            indicator.textContent = '‚è≥ Saving...';
            indicator.classList.add('show', 'saving');

            // Save to server
            try {
                const response = await fetch('/api/save-subtitle-formatting', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        formatting: allCueFormatting
                    })
                });

                if (!response.ok) throw new Error('Failed to save formatting');

                indicator.textContent = '‚úì Saved';
                indicator.classList.remove('saving');

                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 2000);
            } catch (error) {
                indicator.textContent = '‚úó Save failed';
                indicator.classList.remove('saving');
                setTimeout(() => {
                    indicator.classList.remove('show');
                }, 2000);
            }
        }

        // Event listeners for subtitle settings
        document.getElementById('subtitle-text').addEventListener('input', () => {
            updateSubtitlePreview();
            // Only auto-save if this is a user edit, not a programmatic update
            if (!isProgrammaticUpdate) {
                autoSaveSubtitle(); // Auto-save subtitle edits
            }
        });
        document.getElementById('subtitle-font').addEventListener('change', () => { updateSubtitlePreview(); saveGlobalPosition(globalPosition); });
        document.getElementById('subtitle-size').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-size').addEventListener('change', () => { saveGlobalPosition(globalPosition); });
        document.getElementById('subtitle-bold').addEventListener('change', () => { updateSubtitlePreview(); saveGlobalPosition(globalPosition); });
        document.getElementById('subtitle-color').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-color').addEventListener('change', () => { saveGlobalPosition(globalPosition); });
        document.getElementById('subtitle-bg').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-bg').addEventListener('change', () => { saveGlobalPosition(globalPosition); });
        document.getElementById('subtitle-bg-opacity').addEventListener('input', updateSubtitlePreview);
        document.getElementById('subtitle-bg-opacity').addEventListener('change', () => { saveGlobalPosition(globalPosition); });
        document.getElementById('subtitle-position').addEventListener('change', async () => {
            const newPosition = document.getElementById('subtitle-position').value;
            await handlePositionChange(newPosition);
        });

        // Position mode button event listeners
        document.querySelectorAll('.position-mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const mode = btn.dataset.mode;
                setPositionMode(mode);
            });
        });

        // Horizontal align button event listeners
        document.querySelectorAll('.align-btn[data-align]').forEach(btn => {
            btn.addEventListener('click', async () => {
                const align = btn.dataset.align;
                horizontalAlign = align;
                updateAlignButtons(align, verticalAlign);
                updateSubtitlePreview();
                await saveGlobalPosition(globalPosition);
            });
        });

        // Vertical align button event listeners
        document.querySelectorAll('.align-btn[data-valign]').forEach(btn => {
            btn.addEventListener('click', async () => {
                const valign = btn.dataset.valign;
                verticalAlign = valign;
                updateAlignButtons(horizontalAlign, valign);
                updateSubtitlePreview();
                await saveGlobalPosition(globalPosition);
            });
        });

        // Custom color picker event listener
        const customColorPicker = document.getElementById('custom-color-picker');
        customColorPicker.addEventListener('input', (e) => {
            const color = e.target.value;
            applyColor(color);
            // Update CSS variable for color preview
            document.querySelector('.color-picker-wrapper').style.setProperty('--current-color', color);
            
            // Restore editor focus
            document.getElementById('subtitle-text').focus();
        });

        customColorPicker.addEventListener('change', (e) => {
            // Save formatting when color selection is complete
            saveCurrentCueFormatting();
        });

        // Update align button visual states
        function updateAlignButtons(hAlign, vAlign) {
            horizontalAlign = hAlign;
            verticalAlign = vAlign;

            // Update horizontal buttons
            document.querySelectorAll('.align-btn[data-align]').forEach(btn => {
                if (btn.dataset.align === hAlign) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Update vertical buttons
            document.querySelectorAll('.align-btn[data-valign]').forEach(btn => {
                if (btn.dataset.valign === vAlign) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        // Theme name editing
        const themeNameElement = document.getElementById('theme-name');
        let originalThemeName = '';

        themeNameElement.addEventListener('focus', () => {
            originalThemeName = themeNameElement.textContent;
        });

        themeNameElement.addEventListener('blur', () => {
            const newName = themeNameElement.textContent.trim();
            if (newName && newName !== originalThemeName) {
                // Save the new name
                themeData.title = newName;
                autoSaveTheme();
                // Update header too
                document.getElementById('header-theme-name').textContent = newName;
            } else if (!newName) {
                // Revert if empty
                themeNameElement.textContent = originalThemeName;
            }
        });

        themeNameElement.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                themeNameElement.blur();
            } else if (e.key === 'Escape') {
                themeNameElement.textContent = originalThemeName;
                themeNameElement.blur();
            }
        });

        // Subtitles toggle
        document.getElementById('subtitles-toggle').addEventListener('change', (e) => {
            const track = originalVideo.textTracks[0];
            if (track) {
                track.mode = e.target.checked ? 'showing' : 'hidden';
            }
        });

        // Overlay toggle
        document.getElementById('overlay-toggle').addEventListener('change', (e) => {
            const overlay = document.getElementById('shorts-overlay');
            if (e.target.checked) {
                overlay.classList.remove('hidden');
            } else {
                overlay.classList.add('hidden');
            }
        });

        // Karaoke highlighting toggle
        async function toggleKaraoke(enabled) {
            // Show/hide style controls based on karaoke state
            const karaokeControlsDiv = document.getElementById('karaoke-style-controls');
            if (enabled) {
                karaokeControlsDiv.style.display = 'flex';
            } else {
                karaokeControlsDiv.style.display = 'none';
            }

            // If enabling karaoke, check if word timestamps exist
            if (enabled) {
                try {
                    const response = await fetch(`/api/check-word-timestamps?folder=${folderNumber}`);
                    const data = await response.json();

                    if (!data.exists) {
                        // Word timestamps don't exist - ask user to create them
                        const message = `Word timestamps are required for karaoke highlighting.\n\n` +
                                       `This will transcribe the video again to extract word-level timing data.\n\n` +
                                       `‚è±Ô∏è Estimated time: ${data.video_duration || 'a few minutes'}\n\n` +
                                       `Create word timestamps now?`;

                        if (!confirm(message)) {
                            // User cancelled - reset toggle and return
                            document.getElementById('karaoke-toggle').checked = false;
                            return;
                        }

                        // User confirmed - show progress and start transcription
                        const loadingDiv = document.getElementById('loading');
                        const contentDiv = document.getElementById('content');
                        loadingDiv.classList.remove('hidden');
                        loadingDiv.innerHTML = 'üé§ Creating word timestamps...<br><small>This may take a few minutes depending on video length.</small>';
                        contentDiv.classList.add('hidden');

                        try {
                            const transcribeResponse = await fetch('/api/create-word-timestamps', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ folder: folderNumber })
                            });

                            if (!transcribeResponse.ok) {
                                throw new Error('Failed to create word timestamps');
                            }

                            const transcribeData = await transcribeResponse.json();
                            if (transcribeData.error) {
                                throw new Error(transcribeData.error);
                            }

                            loadingDiv.innerHTML = '‚úÖ Word timestamps created!<br>Regenerating subtitles with karaoke...';
                            // Reload word timestamps for preview
                            await loadWordTimestamps();
                        } catch (error) {
                            loadingDiv.innerHTML = '‚ùå Failed to create word timestamps:<br>' + error.message;
                            setTimeout(() => {
                                loadingDiv.classList.add('hidden');
                                contentDiv.classList.remove('hidden');
                                document.getElementById('karaoke-toggle').checked = false;
                            }, 3000);
                            return;
                        }
                    }
                } catch (error) {
                    // Continue anyway - the server will handle missing timestamps
                }
            }

            karaokeEnabled = enabled;

            // Show/hide style controls based on karaoke state
            if (karaokeEnabled) {
                karaokeControlsDiv.style.display = 'flex';
                // Load the saved highlight style
                await loadHighlightStyle();
            } else {
                karaokeControlsDiv.style.display = 'none';
            }

            // Save karaoke setting to server
            try {
                await fetch('/api/save-karaoke-setting', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        enabled: enabled
                    })
                });
                
                // Re-render preview
                updateSubtitlePreview();
                showToast(`‚úÖ Karaoke ${enabled ? 'enabled' : 'disabled'} successfully!`, 'success');
            } catch (error) {
                showToast('‚ùå Failed to update karaoke setting', 'error');
            }
        }

        // ============================================
        // Canvas + FFmpeg Karaoke Export Functions
        // ============================================

        // Export video using server-side Flask mode
        async function exportCanvasKaraokeVideo() {
            console.log('üé¨ exportCanvasKaraokeVideo triggered');
            if (!folderNumber || !themeNumber) {
                console.error('‚ùå Missing folder or theme info', {folderNumber, themeNumber});
                showToast('Missing folder or theme info', 'error');
                return;
            }

            try {
                // Show progress toast
                const progressToast = document.createElement('div');
                progressToast.className = 'karaoke-toast';
                progressToast.id = 'export-progress-toast';
                progressToast.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #333; color: white; padding: 15px 20px; border-radius: 8px; z-index: 10000; max-width: 400px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); border-left: 4px solid #4CAF50;';
                progressToast.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div class="spinner" style="width: 20px; height: 20px; border: 2px solid #ffffff33; border-top-color: #4CAF50; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                        <div style="flex: 1;">
                            <div style="font-weight: 600; margin-bottom: 4px;">üé¨ Server-Side Export</div>
                            <div id="export-stage" style="font-size: 12px; opacity: 0.8;">Starting export on server...</div>
                            <div style="background: rgba(255,255,255,0.1); height: 4px; border-radius: 2px; margin-top: 8px; overflow: hidden;">
                                <div id="export-progress-bar" style="background: #4CAF50; height: 100%; width: 0%; transition: width 0.3s;"></div>
                            </div>
                            <div id="export-progress-text" style="font-size: 11px; opacity: 0.6; margin-top: 4px;">Connecting...</div>
                        </div>
                    </div>
                `;
                document.body.appendChild(progressToast);

                const stageEl = document.getElementById('export-stage');
                const progressTextEl = document.getElementById('export-progress-text');
                const progressBarEl = document.getElementById('export-progress-bar');

                const updateProgress = (stage, percent, text) => {
                    if (stageEl) stageEl.textContent = stage;
                    if (progressTextEl) progressTextEl.textContent = text || `${Math.round(percent)}%`;
                    if (progressBarEl) progressBarEl.style.width = `${percent}%`;
                };

                // Get current styling settings
                const settings = getCurrentSubtitleSettings();

                // Request export
                console.log('üì° Sending export request to /api/export-canvas-karaoke', {folder: folderNumber, theme: themeNumber, settings: settings});
                const response = await fetch('/api/export-canvas-karaoke', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        themeStart: startSeconds,
                        themeEnd: endSeconds,
                        settings: settings
                    })
                }).catch(err => {
                    console.error('‚ùå Fetch error:', err);
                    throw err;
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Export failed');
                }

                const result = await response.json();
                
                // If the server returns a job_id, we should poll for progress
                if (result.job_id) {
                    const pollProgress = async () => {
                        try {
                            const progRes = await fetch(`/api/canvas-karaoke-progress/${result.job_id}`);
                            if (progRes.ok) {
                                const progData = await progRes.json();
                                updateProgress(progData.message || 'Processing...', progData.progress, `${progData.progress}%`);
                                
                                if (progData.status === 'complete') {
                                    finalizeExport(progData.output_path || 'the shorts folder');
                                } else if (progData.status === 'error') {
                                    throw new Error(progData.error || 'Server processing error');
                                } else {
                                    setTimeout(pollProgress, 1000);
                                }
                            }
                        } catch (err) {
                            if (progressToast) progressToast.remove();
                            showToast('Export failed: ' + err.message, 'error');
                        }
                    };
                    pollProgress();
                } else if (result.success) {
                    // Immediate success
                    finalizeExport(result.output_path || 'the shorts folder');
                }

                function finalizeExport(savedPath) {
                    updateProgress('Done!', 100, 'Video saved to server');
                    showToast(`‚úÖ Export complete! Saved to: ${savedPath}`, 'success');
                    setTimeout(() => {
                        if (progressToast) progressToast.remove();
                    }, 5000);
                }

            } catch (error) {
                if (document.getElementById('export-progress-toast')) {
                    document.getElementById('export-progress-toast').remove();
                }
                console.error("Export error:", error);
                showToast('Export error: ' + error.message, 'error');
            }
        }

        // Export button event listener
        document.getElementById('export-canvas-video')?.addEventListener('click', exportCanvasKaraokeVideo);

        // Toast notification system
        function showToast(message, type = 'info') {
            // Remove existing toast if any
            const existingToast = document.querySelector('.karaoke-toast');
            if (existingToast) {
                existingToast.remove();
            }

            // Create toast element
            const toast = document.createElement('div');
            toast.className = 'karaoke-toast';
            toast.textContent = message;

            // Style based on type
            const styles = {
                info: { background: '#2196F3', icon: '‚ÑπÔ∏è' },
                success: { background: '#4CAF50', icon: '‚úÖ' },
                error: { background: '#f44336', icon: '‚ùå' }
            };

            const style = styles[type] || styles.info;
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${style.background};
                color: white;
                padding: 16px 24px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 10000;
                font-size: 14px;
                font-weight: 500;
                animation: slideIn 0.3s ease-out;
                max-width: 400px;
            `;

            // Add to page
            document.body.appendChild(toast);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Add CSS for toast animations
        const toastStyle = document.createElement('style');
        toastStyle.textContent = `
            @keyframes slideIn {
                from {
                    transform: translateX(100%);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            @keyframes slideOut {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(100%);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(toastStyle);

        // Subtitle Effect Selection handler
        document.getElementById('effect-type').addEventListener('change', async (e) => {
            const enabled = e.target.value !== 'none';
            karaokeEnabled = enabled;
            
            const karaokeControlsDiv = document.getElementById('karaoke-style-controls');
            if (enabled) {
                karaokeControlsDiv.style.display = 'flex';
            } else {
                karaokeControlsDiv.style.display = 'none';
            }

            await saveHighlightStyle();
            updateSubtitlePreview();
            
            // Save karaoke state to server
            try {
                await fetch('/api/save-karaoke-setting', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder: folderNumber,
                        theme: themeNumber,
                        enabled: enabled
                    })
                });
            } catch (error) {}
        });

        // Load karaoke setting on page load
        async function loadKaraokeSetting() {
            try {
                // Check if word timestamps exist first
                const checkResponse = await fetch(`/api/check-word-timestamps?folder=${folderNumber}`);
                let wordTimestampsExist = false;
                if (checkResponse.ok) {
                    const checkData = await checkResponse.json();
                    wordTimestampsExist = checkData.exists;
                }

                // Get karaoke setting from server
                const response = await fetch(`/api/get-karaoke-setting?folder=${folderNumber}&theme=${themeNumber}`);
                if (response.ok) {
                    const data = await response.json();
                    // Load the saved highlight style first to get the effect type
                    await loadHighlightStyle();
                    
                    const effectType = document.getElementById('effect-type').value;
                    karaokeEnabled = effectType !== 'none' && wordTimestampsExist;

                    // Show/hide style controls based on karaoke state
                    const karaokeControlsDiv = document.getElementById('karaoke-style-controls');
                    if (karaokeEnabled) {
                        karaokeControlsDiv.style.display = 'flex';
                    } else {
                        karaokeControlsDiv.style.display = 'none';
                    }
                }
            } catch (error) {
                karaokeEnabled = false;
            }
        }

        // Load word timestamps for preview karaoke highlighting
        async function loadWordTimestamps() {
            if (wordTimestamps !== null) {
                return wordTimestamps; // Already loaded
            }

            try {
                const response = await fetch(`/api/word-timestamps/${folderNumber}`);
                if (response.ok) {
                    const data = await response.json();
                    wordTimestamps = data.words || [];
                    return wordTimestamps;
                }
            } catch (error) {
            }

            wordTimestamps = [];
            return wordTimestamps;
        }

        // Update word highlighting in preview based on current video time
        // This uses a POSITIONAL approach, not text matching:
        // - Counts how many word timestamps occur during the current subtitle
        // - Highlights the Nth word in the subtitle based on that count
        // - Works regardless of language mismatches between audio and subtitles
        let lastSubtitleText = ''; // Track subtitle changes
        let subtitleWordCount = 0; // How many words have been spoken during current subtitle
        let lastProcessedWordIndex = -1; // Last word timestamp index we processed

        // Update word highlighting state
        async function updatePreviewWordHighlighting(currentTime) {
            // State is now handled within wordHighlightHandler and renderFrame
            return;
        }

        // Add CSS for word highlighting (using CSS variables for dynamic updates)
        const style = document.createElement('style');
        style.id = 'highlight-style';
        style.textContent = `
            .word-highlight {
                color: var(--highlight-text-color, #ffff00) !important;
                text-shadow: 0 0 var(--highlight-glow-blur, 10px) var(--highlight-glow-color, rgba(255, 255, 0, 0.8));
                font-weight: var(--highlight-font-weight, bold);
                transition: all 0.1s ease-in-out;
            }
        `;
        document.head.appendChild(style);

        // Update highlight style dynamically
        function updateHighlightStyle() {
            const textColor = document.getElementById('highlight-text-color').value;
            const glowColor = document.getElementById('highlight-glow-color').value;
            const glowBlur = document.getElementById('highlight-glow-blur').value;
            const fontWeight = document.getElementById('highlight-font-weight').value;

            // Convert hex glow color to rgba with opacity
            const r = parseInt(glowColor.slice(1, 3), 16);
            const g = parseInt(glowColor.slice(3, 5), 16);
            const b = parseInt(glowColor.slice(5, 7), 16);
            const glowColorRgba = `rgba(${r}, ${g}, ${b}, 0.8)`;

            // Update CSS variables on the root
            document.documentElement.style.setProperty('--highlight-text-color', textColor);
            document.documentElement.style.setProperty('--highlight-glow-color', glowColorRgba);
            document.documentElement.style.setProperty('--highlight-glow-blur', glowBlur + 'px');
            document.documentElement.style.setProperty('--highlight-font-weight', fontWeight);
        }

        // Save highlight style to server
        async function saveHighlightStyle() {
            const styleData = {
                folder: folderNumber,
                preset: document.getElementById('highlight-preset').value,
                textColor: document.getElementById('highlight-text-color').value,
                glowColor: document.getElementById('highlight-glow-color').value,
                glowBlur: document.getElementById('highlight-glow-blur').value,
                fontWeight: document.getElementById('highlight-font-weight').value,
                // Karaoke mode and effect settings
                karaokeMode: document.getElementById('karaoke-mode').value,
                effectType: document.getElementById('effect-type').value,
                autoEmoji: document.getElementById('auto-emoji').checked,
                keywordScaling: document.getElementById('keyword-scaling').checked,
                fontSizeScale: 1.0, // Fixed at 1.0 as we use the global font size instead
                pastColor: document.getElementById('past-color').value
            };

            try {
                const response = await fetch('/api/save-highlight-style', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(styleData)
                });

                if (!response.ok) {
                }
            } catch (error) {
            }
        }

        // Load highlight style from server
        async function loadHighlightStyle() {
            try {
                const response = await fetch(`/api/get-highlight-style?folder=${folderNumber}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.style) {
                        // Apply loaded style to inputs
                        document.getElementById('highlight-text-color').value = data.style.textColor || '#ffff00';
                        document.getElementById('highlight-glow-color').value = data.style.glowColor || '#ffff00';
                        document.getElementById('highlight-glow-blur').value = data.style.glowBlur || '10';
                        document.getElementById('highlight-font-weight').value = data.style.fontWeight || 'bold';

                        // Load karaoke mode and effect settings
                        document.getElementById('karaoke-mode').value = data.style.karaoke_mode || 'normal';
                        if (data.style.effectType) document.getElementById('effect-type').value = data.style.effectType;
                        if (data.style.autoEmoji !== undefined) document.getElementById('auto-emoji').checked = data.style.autoEmoji;
                        if (data.style.keywordScaling !== undefined) document.getElementById('keyword-scaling').checked = data.style.keywordScaling;

                        // Load past color
                        document.getElementById('past-color').value = data.style.past_color || '#808080';

                        // Use saved preset if available, otherwise try to match
                        if (data.style.preset && highlightPresets[data.style.preset]) {
                            document.getElementById('highlight-preset').value = data.style.preset;
                        } else {
                            // Check if loaded style matches any preset
                            let matchedPreset = 'custom';
                            for (const [presetName, presetValues] of Object.entries(highlightPresets)) {
                                if (data.style.textColor === presetValues.textColor &&
                                    data.style.glowColor === presetValues.glowColor &&
                                    data.style.glowBlur === presetValues.glowBlur &&
                                    data.style.fontWeight === presetValues.fontWeight) {
                                    matchedPreset = presetName;
                                    break;
                                }
                            }
                            document.getElementById('highlight-preset').value = matchedPreset;
                        }

                        // Update the actual CSS
                        updateHighlightStyle();
                    }
                }
            } catch (error) {
            }
        }

        // Reset highlight style to defaults
        function resetHighlightStyle() {
            document.getElementById('highlight-text-color').value = '#ffff00';
            document.getElementById('highlight-glow-color').value = '#ffff00';
            document.getElementById('highlight-glow-blur').value = '10';
            document.getElementById('highlight-font-weight').value = 'normal';
            document.getElementById('highlight-preset').value = 'yellow-glow';
            document.getElementById('karaoke-mode').value = 'normal';
            document.getElementById('effect-type').value = 'none';
            document.getElementById('auto-emoji').checked = false;
            document.getElementById('keyword-scaling').checked = false;
            document.getElementById('past-color').value = '#808080';
            updateHighlightStyle();
            saveHighlightStyle();
            updateSubtitlePreview();
        }

        // Preset style definitions
        const highlightPresets = {
            'yellow-glow': { textColor: '#ffff00', glowColor: '#ffff00', glowBlur: '10', fontWeight: 'bold' },
            'red-bold': { textColor: '#ff3333', glowColor: '#ff0000', glowBlur: '8', fontWeight: 'bold' },
            'cyan-neon': { textColor: '#00ffff', glowColor: '#00ffff', glowBlur: '20', fontWeight: 'bold' },
            'green-glow': { textColor: '#00ff00', glowColor: '#00ff00', glowBlur: '12', fontWeight: 'bold' },
            'pink-soft': { textColor: '#ff69b4', glowColor: '#ff1493', glowBlur: '15', fontWeight: '500' },
            'orange-fire': { textColor: '#ff8c00', glowColor: '#ff4500', glowBlur: '18', fontWeight: 'bold' },
            'white-clean': { textColor: '#ffffff', glowColor: '#ffffff', glowBlur: '5', fontWeight: 'normal' },
            'purple-vibe': { textColor: '#da70d6', glowColor: '#9932cc', glowBlur: '16', fontWeight: 'bold' }
        };

        // Apply preset style
        function applyPresetStyle(presetName) {
            if (presetName === 'custom') return; // Don't change if custom is selected

            const preset = highlightPresets[presetName];
            if (preset) {
                document.getElementById('highlight-text-color').value = preset.textColor;
                document.getElementById('highlight-glow-color').value = preset.glowColor;
                document.getElementById('highlight-glow-blur').value = preset.glowBlur;
                document.getElementById('highlight-font-weight').value = preset.fontWeight;
                updateHighlightStyle();
                saveHighlightStyle();
                updateSubtitlePreview();
            }
        }

        // Setup event listeners for karaoke controls

        const karaokeModeSelect = document.getElementById('karaoke-mode');
        const fontSizeScaleInput = document.getElementById('font-size-scale');
        const pastColorInput = document.getElementById('past-color');

        if (karaokeModeSelect) {
        } else {
        }

        if (fontSizeScaleInput) {
        } else {
        }

        if (pastColorInput) {
        } else {
        }

        // Add event listeners for new karaoke controls
        document.getElementById('karaoke-mode').addEventListener('change', async (e) => {
            await saveHighlightStyle();
            updateSubtitlePreview();
        });
        document.getElementById('effect-type').addEventListener('change', async (e) => {
            await saveHighlightStyle();
            updateSubtitlePreview();
        });
        document.getElementById('auto-emoji').addEventListener('change', async (e) => {
            await saveHighlightStyle();
            updateSubtitlePreview();
        });
        document.getElementById('keyword-scaling').addEventListener('change', async (e) => {
            await saveHighlightStyle();
            updateSubtitlePreview();
        });
        document.getElementById('past-color').addEventListener('change', async (e) => {
            await saveHighlightStyle();
            updateSubtitlePreview();
        });

        // Add event listeners for style controls
        document.getElementById('highlight-preset').addEventListener('change', (e) => {
            applyPresetStyle(e.target.value);
        });

        document.getElementById('highlight-text-color').addEventListener('input', () => {
            document.getElementById('highlight-preset').value = 'custom';
            updateHighlightStyle();
            saveHighlightStyle();
            updateSubtitlePreview();
        });
        document.getElementById('highlight-glow-color').addEventListener('input', () => {
            document.getElementById('highlight-preset').value = 'custom';
            updateHighlightStyle();
            saveHighlightStyle();
            updateSubtitlePreview();
        });
        document.getElementById('highlight-glow-blur').addEventListener('change', () => {
            document.getElementById('highlight-preset').value = 'custom';
            updateHighlightStyle();
            saveHighlightStyle();
            updateSubtitlePreview();
        });
        document.getElementById('highlight-font-weight').addEventListener('change', () => {
            document.getElementById('highlight-preset').value = 'custom';
            updateHighlightStyle();
            saveHighlightStyle();
            updateSubtitlePreview();
        });
        document.getElementById('reset-highlight-style').addEventListener('click', () => {
            resetHighlightStyle();
            updateSubtitlePreview();
        });

        // Initialize renderer on load
        async function initializeUniversalRenderer() {
            if (!canvas || !previewVideo || !originalCanvas || !originalVideo) return;

            // Ensure word timestamps are loaded
            await loadWordTimestamps();

            // Setup preview canvas size
            const wrapper = canvas.parentElement;
            const rect = wrapper.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;

            // Setup original canvas size
            const originalWrapper = originalCanvas.parentElement;
            const originalRect = originalWrapper.getBoundingClientRect();
            originalCanvas.width = originalRect.width;
            originalCanvas.height = originalRect.height;

            // Get settings
            const settings = getCurrentSubtitleSettings();

            // Initialize both renderers
            canvasRenderer = new UniversalSubtitleRenderer(canvas, previewVideo, wordTimestamps, settings);
            originalCanvasRenderer = new UniversalSubtitleRenderer(originalCanvas, originalVideo, wordTimestamps, settings);

            // Initial preview update to apply correct scaling
            updateSubtitlePreview();
        }

        // Add initialization call to existing load sequence
        const oldLoadTheme = loadTheme;
        loadTheme = async function() {
            await oldLoadTheme();
            await initializeUniversalRenderer();
        };

        // Lock video controls button
        document.getElementById('lock-video-btn').addEventListener('click', () => {
            videoControlsLocked = !videoControlsLocked;
            const lockBtn = document.getElementById('lock-video-btn');
            const lockIcon = document.getElementById('lock-icon');
            const wrappers = document.querySelectorAll('.video-wrapper, .preview-wrapper');

            if (videoControlsLocked) {
                lockBtn.classList.add('locked');
                wrappers.forEach(w => w.classList.add('controls-locked'));
                lockIcon.textContent = 'üîí';
                // Update button text
                lockBtn.innerHTML = '<span id="lock-icon">üîí</span> Unlock';
                lockBtn.title = 'Unlock video controls to disable dragging';

                // Pause video if playing when locked
                if (!previewVideo.paused) {
                    previewVideo.pause();
                }
            } else {
                lockBtn.classList.remove('locked');
                wrappers.forEach(w => w.classList.remove('controls-locked'));
                lockIcon.textContent = 'üîì';
                // Update button text
                lockBtn.innerHTML = '<span id="lock-icon">üîì</span> Lock';
                lockBtn.title = 'Lock video controls to enable dragging';
            }
        });

        // Subtitle dragging functionality
        let isDraggingSubtitle = false;
        let subtitleDragStart = { x: 0, y: 0 };
        let subtitleStartPos = { left: 0, top: 0 };
        let hasManualPosition = false; // Flag to indicate manual positioning

        canvas.addEventListener('mousedown', (e) => {
            if (!videoControlsLocked) return;

            isDraggingSubtitle = true;
            hasManualPosition = true; // Mark as having manual position

            subtitleDragStart = { x: e.clientX, y: e.clientY };

            const wrapper = canvas.parentElement;
            const rect = canvas.getBoundingClientRect();
            
            const previewVideo = document.getElementById('preview-video');
            const previewWidth = previewVideo.offsetWidth || canvas.width;
            const previewHeight = previewVideo.offsetHeight || canvas.height;

            if (customPosition) {
                // Scale from logical 1080x1920 back to current view pixels
                subtitleStartPos = {
                    left: (customPosition.centerX / 1080) * previewWidth,
                    top: (customPosition.top / 1920) * previewHeight
                };
            } else {
                // Initialize from actual vertical center point based on current globalPosition
                let initialTopView;
                if (globalPosition === 'top') initialTopView = (100 * (previewHeight / 1920));
                else if (globalPosition === 'middle') initialTopView = previewHeight / 2;
                else initialTopView = previewHeight - (100 * (previewHeight / 1920));
                
                subtitleStartPos = {
                    left: previewWidth / 2,
                    top: initialTopView
                };
            }

            e.preventDefault();
            e.stopPropagation();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingSubtitle || !videoControlsLocked) return;

            const deltaX = e.clientX - subtitleDragStart.x;
            const deltaY = e.clientY - subtitleDragStart.y;

            // Get preview video dimensions for scaling
            const previewVideo = document.getElementById('preview-video');
            const previewWidth = previewVideo.offsetWidth || canvas.width;
            const previewHeight = previewVideo.offsetHeight || canvas.height;
            
            // Current center point in preview pixels
            const viewCenterX = subtitleStartPos.left + deltaX;
            const viewCenterY = subtitleStartPos.top + deltaY;
            
            // Convert to logical 1080x1920 coordinates
            const logicalCenterX = (viewCenterX / previewWidth) * 1080;
            const logicalCenterY = (viewCenterY / previewHeight) * 1920;

            // Update position (state-driven) - ALWAYS store in logical coordinates
            customPosition = {
                left: logicalCenterX,
                top: logicalCenterY,
                centerX: logicalCenterX,
                width: 0 
            };

            // Auto-switch dropdown to 'custom' if not already
            const positionSelect = document.getElementById('subtitle-position');
            if (positionSelect && positionSelect.value !== 'custom') {
                positionSelect.value = 'custom';
                globalPosition = 'custom';
            }

            // Re-render immediately
            updateSubtitlePreview();
        });

        document.addEventListener('mouseup', async () => {
            if (isDraggingSubtitle) {
                isDraggingSubtitle = false;

                // Save based on current position mode
                if (positionMode === 'global') {
                    await saveGlobalPosition('custom');
                } else {
                    await saveCurrentCueFormatting();
                }
            }
        });

        // Subtitle Editor Modal
        let themeSubtitles = []; // Store all subtitles for the theme
        const subtitleModal = document.getElementById('subtitle-modal');
        const editAllSubsBtn = document.getElementById('edit-all-subs-btn');
        const closeSubsModal = subtitleModal.querySelector('.close');
        const cancelSubsBtn = document.getElementById('cancel-subs-btn');
        const saveSubsBtn = document.getElementById('save-subs-btn');

        // Open subtitle editor modal
        editAllSubsBtn.addEventListener('click', async () => {
            const messageDiv = document.getElementById('message');
            messageDiv.textContent = 'Loading subtitles...';
            messageDiv.className = '';

            try {
                const response = await fetch(`/api/theme-subtitles/${folderNumber}/${themeNumber}`);
                if (!response.ok) throw new Error('Failed to load subtitles');

                const data = await response.json();
                themeSubtitles = data.cues;

                // Load edits from server response into cache (for persistence)
                if (data.edits && Object.keys(data.edits).length > 0) {
                    subtitleEdits = {};
                    for (const [key, editData] of Object.entries(data.edits)) {
                        subtitleEdits[key] = typeof editData === 'string' ? editData : editData.text;
                    }
                }

                // Store original text before applying edits (for comparison when saving)
                themeSubtitles.forEach(cue => {
                    cue._originalText = cue.text;
                });

                // Apply any cached subtitle edits to the loaded cues
                for (const [key, editText] of Object.entries(subtitleEdits)) {
                    const [start, end] = key.split('_');
                    const cueIndex = themeSubtitles.findIndex(cue => cue.start === start && cue.end === end);
                    if (cueIndex !== -1) {
                        themeSubtitles[cueIndex].text = editText;
                    }
                }

                renderSubtitleCues();
                subtitleModal.style.display = 'block';
                messageDiv.textContent = '';
                messageDiv.className = '';
            } catch (error) {
                messageDiv.textContent = `Error: ${error.message}`;
                messageDiv.className = 'error';
            }
        });

        // Close modal handlers
        closeSubsModal.addEventListener('click', () => {
            subtitleModal.style.display = 'none';
        });

        cancelSubsBtn.addEventListener('click', () => {
            subtitleModal.style.display = 'none';
        });

        window.addEventListener('click', (e) => {
            if (e.target === subtitleModal) {
                subtitleModal.style.display = 'none';
            }
        });

        // Render subtitle cues in the modal
        function renderSubtitleCues() {
            const container = document.getElementById('subtitle-cues-container');
            container.innerHTML = '';

            themeSubtitles.forEach((cue, index) => {
                const cueDiv = document.createElement('div');
                cueDiv.className = 'subtitle-cue-item';
                cueDiv.innerHTML = `
                    <div class="cue-header">
                        <strong>#${cue.sequence}</strong>
                        <label>Start:
                            <input type="text" class="cue-time-input" data-index="${index}" data-field="start" value="${cue.start}">
                        </label>
                        <label>End:
                            <input type="text" class="cue-time-input" data-index="${index}" data-field="end" value="${cue.end}">
                        </label>
                    </div>
                    <textarea class="cue-textarea" data-index="${index}" data-field="text">${cue.text}</textarea>
                `;
                container.appendChild(cueDiv);
            });

            // Add event listeners to inputs
            container.querySelectorAll('.cue-time-input, .cue-textarea').forEach(input => {
                input.addEventListener('input', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const field = e.target.dataset.field;
                    themeSubtitles[index][field] = e.target.value;
                });
            });
        }

        // Central sync function - ensures all subtitle sources stay in sync
        // Updates: text area, canvas (via allThemeCues)
        function syncAllSubtitleSources(start, end, newText) {
            const textArea = document.getElementById('subtitle-text');
            if (!textArea) return;

            // Always update the text area with the edited text
            // The user just edited a subtitle, they want to see the result
            textArea.innerHTML = newText;

            // Update currentCueInfo to match this edited subtitle
            const editedCue = allThemeCues.find(c => c.start === start && c.end === end);
            if (editedCue) {
                currentCueInfo = {
                    sequence: editedCue.sequence,
                    timestamp: editedCue.timestamp,
                    start: editedCue.start,
                    end: editedCue.end,
                    text: newText
                };

                // Seek to the start of this subtitle in the preview video
                // This ensures the preview shows the edited subtitle
                if (previewVideo) {
                    const cueStartTime = parseTime(start);
                    previewVideo.currentTime = cueStartTime;
                }
            }

            // Note: Canvas updates automatically from allThemeCues
        }

        // Save subtitles
        saveSubsBtn.addEventListener('click', async () => {
            // Collect all edited subtitle texts
            const cueItems = document.querySelectorAll('.subtitle-cue-item');
            const edits = [];

            cueItems.forEach((cueItem, index) => {
                const textArea = cueItem.querySelector('.cue-textarea');
                const startInput = cueItem.querySelector('input[data-field="start"]');
                const endInput = cueItem.querySelector('input[data-field="end"]');

                if (textArea && startInput && endInput) {
                    const cue = themeSubtitles[index];
                    const newText = textArea.value;

                    // Only save if text was changed from original
                    if (cue._originalText !== newText) {
                        edits.push({
                            sequence: cue.sequence,
                            start: startInput.value,
                            end: endInput.value,
                            oldText: cue.text,
                            newText: newText
                        });

                        // Update local cache
                        const editKey = `${cue.start}_${cue.end}`;
                        subtitleEdits[editKey] = newText;

                        // Update allThemeCues
                        const cueIndex = allThemeCues.findIndex(c =>
                            c.start === cue.start && c.end === cue.end
                        );
                        if (cueIndex !== -1) {
                            allThemeCues[cueIndex].text = newText;
                        }

                        // Update themeSubtitles
                        cue.text = newText;
                        cue._originalText = newText; // Update original text too
                    }
                }
            });

            if (edits.length > 0) {
                // Save all edits to server
                try {
                    for (const edit of edits) {
                        await fetch('/api/save-cue-text', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                folder: folderNumber,
                                theme: themeNumber,
                                cue_start: edit.start,
                                cue_end: edit.end,
                                text: edit.newText
                            })
                        });
                    }

                    // Re-initialize renderer settings to pick up potential changes
                    updateSubtitlePreview();

                    const messageDiv = document.getElementById('message');
                    messageDiv.textContent = `Saved ${edits.length} subtitle edit(s)`;
                    messageDiv.className = 'success';
                } catch (error) {
                    const messageDiv = document.getElementById('message');
                    messageDiv.textContent = `Error saving: ${error.message}`;
                    messageDiv.className = 'error';
                }
            } else {
                const messageDiv = document.getElementById('message');
                messageDiv.textContent = 'No changes to save';
                messageDiv.className = 'success';
            }

            subtitleModal.style.display = 'none';

            const messageDiv = document.getElementById('message');
            if (messageDiv) {
                setTimeout(() => {
                    messageDiv.textContent = '';
                    messageDiv.className = '';
                }, 3000);
            }
        });

        // Initialize
        if (folderNumber && themeNumber) {
            loadTheme().then(() => {
                // Initialize position mode buttons after theme loads
                setPositionMode('global'); // Default to global mode
                // Load karaoke setting
                loadKaraokeSetting();
                // Load word timestamps for preview highlighting
                loadWordTimestamps();
                
                // Initialize collapsible sections from localStorage
                const sections = ['global-settings-section', 'karaoke-section', 'subtitle-text-section'];
                sections.forEach(id => {
                    const isCollapsed = localStorage.getItem(`collapsed_${id}`) === 'true';
                    if (isCollapsed) {
                        document.getElementById(id)?.classList.add('collapsed');
                    }
                });
            });
        } else {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('error').textContent = 'Missing folder or theme number';
            document.getElementById('error').classList.remove('hidden');
        }

        function toggleSection(id) {
            const section = document.getElementById(id);
            if (section) {
                const isCollapsed = section.classList.toggle('collapsed');
                localStorage.setItem(`collapsed_${id}`, isCollapsed);
            }
        }
    </script>
</body>
</html>
