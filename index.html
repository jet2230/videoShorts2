<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Shorts Creator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0f0f0f;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #252525;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --accent: #ff0050;
            --accent-hover: #ff2060;
            --border: #333;
            --success: #2ba640;
            --error: #ff4444;
            --warning: #ffaa00;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 0;
            border-bottom: 1px solid var(--border);
            margin-bottom: 30px;
        }

        h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            background: var(--bg-tertiary);
        }

        .status-badge.online {
            background: var(--success);
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border);
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Forms */
        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        input[type="text"],
        input[type="url"],
        input[type="file"],
        select {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
        }

        input:focus,
        select:focus {
            outline: none;
            border-color: var(--accent);
        }

        /* YouTube Search Results */
        .search-results-container {
            position: relative;
        }

        .search-results-dropdown {
            position: absolute;
            top: 100%;
            left: -7.5px;
            width: calc(100% + 15px);
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            margin-top: 4px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .search-results-dropdown.hidden {
            display: none;
        }

        .search-result-item {
            display: flex;
            gap: 12px;
            padding: 12px;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s;
            text-decoration: none;
            color: inherit;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background: var(--bg-secondary);
        }

        .search-result-item.selected {
            background: rgba(255, 0, 80, 0.1);
            border-color: var(--accent);
        }

        .search-result-thumbnail {
            width: 120px;
            height: 68px;
            border-radius: 4px;
            object-fit: cover;
            flex-shrink: 0;
            background: var(--bg-primary);
        }

        .search-result-info {
            flex: 1;
            min-width: 0;
        }

        .search-result-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .search-result-meta {
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            gap: 8px;
        }

        .search-result-channel {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .search-result-channel-avatar {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--bg-primary);
        }

        .search-loading,
        .search-error {
            padding: 20px;
            text-align: center;
            color: var(--text-secondary);
        }

        .search-error {
            color: var(--error);
        }

        .search-pagination {
            display: flex;
            justify-content: space-between;
            padding: 12px;
            border-top: 1px solid var(--border);
        }

        .search-pagination button {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        .search-pagination button:hover:not(:disabled) {
            background: var(--border);
        }

        .search-pagination button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Buttons */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Cards */
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
        }

        .card-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        /* Folder List */
        .folder-list {
            display: grid;
            gap: 12px;
        }

        .folder-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .folder-item:hover {
            border-color: var(--accent);
        }

        .folder-item.selected {
            border-color: var(--accent);
            background: rgba(255, 0, 80, 0.1);
        }

        .folder-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            gap: 12px;
        }

        .folder-number {
            font-weight: 600;
            color: var(--accent);
            display: flex;
            align-items: center;
            gap: 8px;
            position: relative;
        }

        .play-video-btn {
            background: rgba(255, 0, 80, 0.2);
            border: 1px solid rgba(255, 0, 80, 0.5);
            color: var(--accent);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
            line-height: 1;
        }

        .play-video-btn:hover {
            background: rgba(255, 0, 80, 0.4);
            transform: scale(1.1);
        }

        .delete-folder-btn {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid rgba(255, 68, 68, 0.5);
            color: var(--error);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            line-height: 1;
            margin-left: auto;
            flex-shrink: 0;
            position: relative;
        }

        .delete-folder-btn:hover {
            background: rgba(255, 68, 68, 0.4);
            transform: scale(1.1);
        }

        .retranscribe-folder-btn {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.5);
            color: var(--success);
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            line-height: 1;
            flex-shrink: 0;
        }

        .retranscribe-folder-btn:hover {
            background: rgba(76, 175, 80, 0.4);
            transform: scale(1.1);
        }

        #folder-stats {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .delete-confirmation {
            position: fixed;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            z-index: 99999;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
            min-width: 320px;
            max-width: 450px;
            text-align: left;
        }

        .delete-confirmation-text {
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        .delete-confirmation-files {
            max-height: 250px;
            overflow-y: auto;
            margin-bottom: 16px;
            background: var(--bg-primary);
            border-radius: 6px;
            padding: 10px;
            font-size: 12px;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
        }

        .delete-confirmation-files::-webkit-scrollbar {
            width: 8px;
        }

        .delete-confirmation-files::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .delete-confirmation-files::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        .delete-confirmation-files::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        .delete-file-summary {
            color: var(--text-primary);
            font-weight: 600;
            margin-bottom: 10px;
            padding: 6px 8px;
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        .delete-file-item {
            padding: 6px 8px;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 8px;
            line-height: 1.4;
        }

        .delete-file-item:last-child {
            border-bottom: none;
        }

        .delete-file-directory {
            color: var(--accent);
            font-weight: 600;
        }

        .delete-file-loading {
            color: var(--text-secondary);
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        .delete-confirmation-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .delete-confirmation-buttons button {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        .delete-confirm-btn {
            background: var(--error);
            color: white;
        }

        .delete-confirm-btn:hover {
            background: #ff4444;
            transform: translateY(-1px);
        }

        .delete-cancel-btn {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .delete-cancel-btn:hover {
            background: var(--bg-primary);
            border-color: var(--text-secondary);
        }

        .library-video-player {
            width: 100%;
            max-height: 75vh;
            display: block;
        }

        .folder-name {
            font-size: 14px;
            color: var(--text-secondary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 100%;
            position: relative;
            cursor: help;
        }

        /* Custom tooltip for folder names */
        .folder-name-tooltip {
            position: fixed;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            z-index: 9999;
            pointer-events: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
        }

        .folder-meta {
            display: flex;
            gap: 16px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Themes List */
        .themes-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 12px;
        }

        .theme-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 10px;
            display: flex;
            align-items: flex-start;
            gap: 8px;
            cursor: pointer;
            transition: border-color 0.2s, box-shadow 0.2s;
            user-select: none;
        }

        .theme-item:hover {
            border-color: #00bfff;
            box-shadow: 0 0 10px rgba(0, 191, 255, 0.3);
        }

        .theme-checkbox {
            margin-top: 2px;
            width: 16px;
            height: 18px;
            accent-color: var(--accent);
            pointer-events: none;
        }

        .theme-content {
            flex: 1;
        }

        .theme-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .theme-number {
            font-weight: 600;
            color: var(--accent);
            font-size: 13px;
        }

        .theme-duration {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .theme-title {
            font-weight: 600;
            margin-bottom: 2px;
            font-size: 14px;
        }

        .theme-time {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .theme-created-badge {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            padding: 3px 8px;
            background: var(--success);
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            color: white;
        }

        .theme-created-badge::before {
            content: '✓';
        }

        .theme-play-btn {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            padding: 3px 8px;
            background: var(--success);
            border: none;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            color: white;
            cursor: pointer;
            margin-top: 4px;
            transition: background 0.2s;
        }

        .theme-play-btn:hover {
            background: #238a36;
        }

        .theme-play-btn::before {
            content: '▶';
            font-size: 8px;
        }

        .theme-adjust-btn {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            background: #2b4a8a;
            border: none;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            color: white;
            cursor: pointer;
            margin-left: 8px;
            transition: background 0.2s;
        }

        .theme-adjust-btn:hover {
            background: #3a5fad;
        }

        .theme-header-row {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 4px;
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 400px;
            word-break: break-all;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .tooltip.show {
            display: block;
        }

        /* Video modal */
        .video-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .video-modal.show,
        #video-modal.show {
            display: flex;
        }

        .video-modal video {
            max-width: 90%;
            max-height: 90%;
            border-radius: 8px;
        }

        .video-modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Shorts Grid */
        .shorts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
        }

        .short-item {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            overflow: hidden;
            transition: transform 0.2s, border-color 0.2s;
            cursor: pointer;
        }

        .short-item:hover {
            transform: translateY(-4px);
            border-color: var(--accent);
        }

        .short-thumbnail {
            width: 100%;
            aspect-ratio: 9/16;
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .short-thumbnail video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .short-thumbnail:hover video {
            opacity: 1;
        }

        .short-thumbnail .play-icon {
            position: absolute;
            font-size: 48px;
            color: white;
            opacity: 0;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
        }

        .short-thumbnail:hover .play-icon {
            opacity: 0.9;
            transform: scale(1.1);
        }

        .short-thumbnail canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .short-info {
            padding: 12px;
        }

        .short-title {
            font-weight: 600;
            margin-bottom: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .short-meta {
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .short-filename {
            font-family: monospace;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .short-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .short-actions button {
            flex: 1;
            padding: 6px 12px;
            font-size: 12px;
            text-align: center;
        }

        .short-actions .btn-play {
            border-color: #2ba640;
            border: 2px solid #2ba640;
        }

        .short-actions .btn-download {
            border-color: #0066cc;
            border: 2px solid #0066cc;
        }

        .short-actions .btn-edit {
            border-color: #ffaa00;
            border: 2px solid #ffaa00;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Progress */
        .progress-container {
            display: none;
            margin-top: 20px;
        }

        .progress-container.active {
            display: block;
        }

        /* Keep visible when there's an error */
        .progress-container.error {
            display: block;
        }

        .progress-bar {
            height: 20px;
            background: var(--bg-tertiary);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            animation: progress 2s ease-in-out infinite;
        }

        @keyframes progress {
            0% { width: 0%; margin-left: 0; }
            50% { width: 50%; margin-left: 25%; }
            100% { width: 0%; margin-left: 100%; }
        }

        .progress-text {
            font-size: 14px;
            color: var(--text-secondary);
            text-align: center;
        }

        .process-log {
            margin-top: 16px;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: var(--text-secondary);
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
            line-height: 1.5;
            display: none;
        }

        .process-log.active {
            display: block;
        }

        .process-log:empty {
            display: none;
        }

        .progress-cancel {
            text-align: center;
            margin-top: 12px;
        }

        .btn-cancel {
            background: var(--error);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: background 0.2s;
            display: none;
        }

        .btn-cancel:hover {
            background: #cc0000;
        }

        /* Notifications */
        .notification {
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }

        .notification.show {
            display: block;
        }

        .notification.success {
            background: rgba(43, 166, 64, 0.2);
            border: 1px solid var(--success);
        }

        .notification.error {
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid var(--error);
        }

        /* Video Modal */
        #video-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .video-modal-content {
            position: relative;
            width: 100%;
            max-width: 900px;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .video-modal-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 68, 68, 0.2);
            border: 1px solid var(--error);
            color: var(--error);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            z-index: 10;
        }

        #video-modal video,
        #video-modal [data-video-modal-player] {
            width: 100%;
            max-height: 75vh;
            display: block;
            position: relative;
            z-index: 1;
        }

        .video-modal-close:hover {
            background: rgba(255, 68, 68, 0.4);
            transform: scale(1.1);
        }

        #video-modal video,
        #video-modal [data-video-modal-player] {
            width: 100%;
            max-height: 75vh;
            display: block;
        }

        /* Two column layout for themes */
        .two-column {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        .actions-bar {
            display: flex;
            gap: 12px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .stats {
            display: flex;
            gap: 24px;
            margin-bottom: 20px;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 600;
            color: var(--accent);
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            background-color: #1e1e1e;
            margin: 5% auto;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header h2 {
            margin: 0;
            font-size: 20px;
        }

        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover,
        .close:focus {
            color: #fff;
        }

        .modal-body {
            padding: 20px;
        }

        .modal-footer {
            padding: 16px;
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>YouTube Shorts Creator</h1>
            <span class="status-badge online">Server Online</span>
        </header>

        <div class="tabs">
            <button class="tab active" data-tab="library">Theme Library</button>
            <button class="tab" data-tab="add">Add Video</button>
            <button class="tab" data-tab="edit-shorts">Edit Shorts</button>
            <button class="tab" data-tab="settings">Settings</button>
        </div>

        <!-- Library Tab -->
        <div id="library-tab" class="tab-content active">
            <div class="card">
                <div class="card-title">Theme Library</div>
                <div class="folder-list" id="folder-list">
                    <div class="empty-state">Loading...</div>
                </div>
            </div>
        </div>

        <!-- Add Video Tab -->
        <div id="add-tab" class="tab-content">
            <div class="card">
                <div class="card-title">Add New Video</div>

                <div style="display: flex; gap: 20px;">
                    <div class="form-group search-results-container" style="flex: 1;">
                        <label>YouTube Search or URL</label>
                        <input type="text" id="url-input" placeholder="Search YouTube or paste URL..." autocomplete="off">
                        <div class="search-results-dropdown hidden" id="search-results"></div>
                    </div>

                    <div class="form-group" style="flex: 1;">
                        <label>Local Video File</label>
                        <input type="file" id="file-input" accept="video/*">
                    </div>
                </div>

                <div class="form-group">
                    <label>Video Resolution</label>
                    <select id="resolution-input">
                        <option value="best" selected>Best Quality</option>
                        <option value="1080">1080p (Full HD)</option>
                        <option value="720">720p (HD)</option>
                        <option value="480">480p</option>
                        <option value="360">360p</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Whisper Model</label>
                    <select id="model-input">
                        <option value="base" selected>Base (Recommended)</option>
                        <option value="tiny">Tiny (Fastest)</option>
                        <option value="small">Small</option>
                        <option value="medium">Medium (More Accurate)</option>
                        <option value="large">Large (Most Accurate)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Language</label>
                    <select id="language-input">
                        <option value="en" selected>English</option>
                        <option value="ar">Arabic</option>
                        <option value="auto">Auto Detect</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                    </select>
                </div>

                <button class="btn btn-primary" id="process-btn" style="width: 100%; text-align: center;">
                    Process Video
                </button>

                <div class="progress-container" id="process-progress">
                    <div class="progress-bar">
                        <div class="progress-fill" id="main-progress-fill"></div>
                    </div>
                    <div class="progress-text" id="process-text">Processing...</div>
                    <!-- Second progress bar for subtitle generation -->
                    <div class="progress-bar" id="subtitle-progress-container" style="margin-top: 8px; height: 20px; opacity: 0.3;">
                        <div class="progress-fill" id="subtitle-progress-fill"></div>
                    </div>
                    <div class="progress-text" id="subtitle-text" style="font-size: 12px; color: var(--text-secondary);"></div>
                    <!-- Third progress bar for theme generation -->
                    <div class="progress-bar" style="margin-top: 8px; height: 12px; opacity: 0.3;">
                        <div class="progress-fill" id="theme-progress-fill"></div>
                    </div>
                    <div class="progress-text" id="theme-text" style="font-size: 12px; color: var(--text-secondary);"></div>
                    <div class="process-log" id="process-log"></div>
                    <div class="progress-cancel">
                        <button class="btn-cancel" id="cancel-process-btn">Cancel</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Tab -->
        <div id="settings-tab" class="tab-content">
            <div class="card">
                <div class="card-title">Settings</div>

                <div class="form-group">
                    <label>Whisper Model</label>
                    <select id="setting-whisper-model">
                        <option value="tiny">Tiny (fastest)</option>
                        <option value="base">Base</option>
                        <option value="small">Small</option>
                        <option value="medium">Medium</option>
                        <option value="large">Large (best)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Whisper Language</label>
                    <select id="setting-whisper-language">
                        <option value="en">English</option>
                        <option value="ar">Arabic</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                        <option value="auto">Auto-detect</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Video Output Directory</label>
                    <input type="text" id="setting-video-output-dir">
                </div>

                <div class="form-group">
                    <label>Aspect Ratio</label>
                    <select id="setting-video-aspect-ratio">
                        <option value="9:16">9:16 (Vertical/Shorts)</option>
                        <option value="16:9">16:9 (Horizontal)</option>
                        <option value="1:1">1:1 (Square)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>
                        <input type="checkbox" id="setting-ai-enabled">
                        Enable AI Theme Detection
                    </label>
                </div>

                <div class="form-group">
                    <label>AI Model</label>
                    <select id="setting-ai-model">
                        <option value="llama3">Llama 3</option>
                        <option value="mistral">Mistral</option>
                        <option value="gemma">Gemma</option>
                    </select>
                </div>

                <button class="btn btn-primary" id="save-settings-btn">Save Settings</button>
            </div>
        </div>

        <!-- Edit Shorts Tab -->
        <div id="edit-shorts-tab" class="tab-content">
            <div class="card">
                <div class="card-title">All Shorts</div>

                <div style="display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap;">
                    <select id="shorts-folder-filter" style="flex: 1; min-width: 200px;">
                        <option value="">All Videos</option>
                    </select>
                    <input type="text" id="shorts-search" placeholder="Search shorts..." style="flex: 1; min-width: 200px;">
                    <button class="btn btn-secondary" id="refresh-shorts-btn">Refresh</button>
                </div>

                <div class="shorts-grid" id="shorts-grid">
                    <div class="empty-state">Loading shorts...</div>
                </div>
            </div>
        </div>

        <!-- Themes Panel (shown when folder selected) -->
        <div id="themes-panel" class="card" style="display: none;">
            <div class="two-column">
                <div>
                    <div class="card-title" id="selected-folder-title">Themes</div>
                    <div class="stats" id="folder-stats"></div>
                    <div class="themes-list" id="themes-list"></div>
                    <div class="actions-bar">
                        <button class="btn btn-secondary" id="select-all-btn" disabled>Select All</button>
                        <button class="btn btn-secondary" id="deselect-all-btn" disabled>Deselect All</button>
                        <button class="btn btn-secondary" id="regenerate-btn" disabled>Regenerate Themes</button>
                        <button class="btn btn-primary" id="create-shorts-btn" disabled>Create Shorts</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="progress-container" id="task-progress" style="display: none;">
            <div class="progress-bar">
                <div class="progress-fill"></div>
            </div>
            <div class="progress-text" id="task-progress-text">Processing...</div>
            <div class="progress-cancel">
                <button class="btn-cancel" id="cancel-task-btn">Cancel</button>
            </div>
        </div>

        <div class="notification" id="notification"></div>

        <!-- Tooltip for file path -->
        <div class="tooltip" id="tooltip"></div>

        <!-- Video modal -->
        <div class="video-modal" id="video-modal">
            <div class="video-modal-content">
                <button class="video-modal-close" id="video-modal-close">&times;</button>
                <video id="video-player" controls></video>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://127.0.0.1:5000/api';
        let selectedFolder = null;
        let currentTaskId = null;
        let taskCheckInterval = null;

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');

                // Hide themes panel when switching tabs
                document.getElementById('themes-panel').style.display = 'none';

                if (tab.dataset.tab === 'library') {
                    loadFolders();
                } else if (tab.dataset.tab === 'settings') {
                    loadSettings();
                } else if (tab.dataset.tab === 'edit-shorts') {
                    loadShorts();
                }
            });
        });

        // Load folders
        async function loadFolders() {
            try {
                const response = await fetch(`${API_BASE}/folders`);
                const folders = await response.json();

                const container = document.getElementById('folder-list');
                if (folders.length === 0) {
                    container.innerHTML = '<div class="empty-state">No videos found. Add one to get started!</div>';
                    return;
                }

                container.innerHTML = folders.map(folder => {
                    const displayName = folder.name.length > 50 ? folder.name.substring(0, 50) + '...' : folder.name;
                    return `
                    <div class="folder-item" data-folder="${folder.number}" data-video="${folder.video_file}" data-folder-name="${folder.name}" data-folder-path="${folder.name}">
                        <div class="folder-header">
                            <span class="folder-number">
                                #${folder.number}
                                <button class="play-video-btn" data-play-folder="${folder.name}" data-play-video="${folder.video_file}" title="Play video">▶</button>
                            </span>
                            <span class="folder-name" data-full-name="${folder.name}">${displayName}</span>
                            <button class="delete-folder-btn" data-delete-folder="${folder.number}" title="Delete Library for #${folder.number}">✕</button>
                        </div>
                        <div class="folder-meta">
                            <span>${folder.video_file}</span>
                            ${folder.has_themes ? '<span>✓ Themes</span>' : '<span>No themes</span>'}
                            ${folder.shorts_count > 0 ? `<span>${folder.shorts_count} shorts</span>` : ''}
                        </div>
                    </div>
                    `;
                }).join('');

                // Add click handlers
                container.querySelectorAll('.folder-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        // Check if play button was clicked
                        if (e.target.classList.contains('play-video-btn')) {
                            const folderName = e.target.dataset.playFolder;
                            const videoFile = e.target.dataset.playVideo;
                            playFolderVideo(e, folderName, videoFile);
                            return;
                        }

                        // Check if delete button was clicked
                        if (e.target.classList.contains('delete-folder-btn')) {
                            e.stopPropagation();
                            const folderNumber = e.target.dataset.deleteFolder;
                            showDeleteConfirmation(e.target, folderNumber);
                            return;
                        }

                        // Regular folder selection
                        document.querySelectorAll('.folder-item').forEach(i => i.classList.remove('selected'));
                        item.classList.add('selected');
                        selectFolder(item.dataset.folder);
                    });
                });

                // Add hover handlers for folder name tooltips
                container.querySelectorAll('.folder-name').forEach(nameEl => {
                    const fullName = nameEl.getAttribute('data-full-name');

                    nameEl.addEventListener('mouseenter', (e) => {
                        if (!fullName || fullName === nameEl.textContent) return;

                        // Create tooltip
                        const tooltip = document.createElement('div');
                        tooltip.className = 'folder-name-tooltip';
                        tooltip.textContent = fullName;
                        document.body.appendChild(tooltip);

                        // Position tooltip below
                        const rect = nameEl.getBoundingClientRect();
                        tooltip.style.top = (rect.bottom + 5) + 'px';
                        tooltip.style.left = rect.left + 'px';

                        nameEl._tooltip = tooltip;
                    });

                    nameEl.addEventListener('mouseleave', () => {
                        if (nameEl._tooltip) {
                            nameEl._tooltip.remove();
                            nameEl._tooltip = null;
                        }
                    });
                });
            } catch (error) {
                showNotification('Error loading folders: ' + error.message, 'error');
            }
        }

        // Play folder video
        async function playFolderVideo(event, folderName, videoFile) {
            event.stopPropagation(); // Prevent folder selection

            // URL encode both folder name and filename to handle special characters
            const videoUrl = `/videos/${encodeURIComponent(folderName)}/${encodeURIComponent(videoFile)}`;

            // Use the existing video modal from the HTML
            const modal = document.getElementById('video-modal');
            const player = document.getElementById('video-player');

            if (!player) {
                showNotification('Error: Video player not found', 'error');
                return;
            }

            player.src = videoUrl;
            modal.classList.add('show');

            try {
                await player.play();
            } catch (error) {
            }
        }

        // Delete folder
        async function deleteFolder(folderNumber) {
            try {
                const response = await fetch(`${API_BASE}/folder/${folderNumber}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to delete folder');
                }

                showNotification(`Folder #${folderNumber} deleted successfully`, 'success');

                // Reload folders
                loadFolders();

                // Clear themes panel if the deleted folder was selected
                if (selectedFolder === folderNumber) {
                    selectedFolder = null;
                    document.getElementById('themes-panel').style.display = 'none';
                }
            } catch (error) {
                showNotification('Error deleting folder: ' + error.message, 'error');
            }
        }

        // Show inline delete confirmation
        async function showDeleteConfirmation(button, folderNumber) {
            // Remove any existing confirmations
            document.querySelectorAll('.delete-confirmation').forEach(el => el.remove());

            // Create confirmation popup
            const confirmation = document.createElement('div');
            confirmation.className = 'delete-confirmation';
            confirmation.innerHTML = `
                <div class="delete-confirmation-text">Delete folder #${folderNumber}?</div>
                <div class="delete-confirmation-files">
                    <div class="delete-file-loading">Loading files...</div>
                </div>
                <div class="delete-confirmation-buttons">
                    <button class="delete-confirm-btn">Yes</button>
                    <button class="delete-cancel-btn">No</button>
                </div>
            `;

            // Add to body and position relative to button
            document.body.appendChild(confirmation);

            // Position the popup to the left of the button
            const buttonRect = button.getBoundingClientRect();
            confirmation.style.left = (buttonRect.left - 10) + 'px';

            // Position vertically - center on button, but ensure it doesn't go off screen
            const viewportHeight = window.innerHeight;
            const topPosition = buttonRect.top + (buttonRect.height / 2);
            confirmation.style.top = topPosition + 'px';
            confirmation.style.transform = 'translate(-100%, -50%)';

            // Function to adjust position to stay in viewport
            const adjustPosition = () => {
                const popupRect = confirmation.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                const bottomOverflow = popupRect.bottom - viewportHeight + 40; // More padding from bottom

                if (bottomOverflow > 0) {
                    // Calculate new top position accounting for transform
                    const currentTransformY = popupRect.height / 2; // The -50% transform
                    // Move up by overflow amount minus a larger offset so it appears lower
                    const adjustAmount = bottomOverflow - 30;
                    const newTop = popupRect.top - adjustAmount - currentTransformY;
                    confirmation.style.top = newTop + 'px';
                }
            };

            // Check and adjust position after render and after files are loaded
            requestAnimationFrame(adjustPosition);

            // Fetch files list
            try {
                const response = await fetch(`${API_BASE}/folder/${folderNumber}`);
                if (response.ok) {
                    const data = await response.json();
                    const filesContainer = confirmation.querySelector('.delete-confirmation-files');

                    let filesHtml = `<div class="delete-file-summary">📊 ${data.total_count} items • ${data.total_size_human}</div>`;

                    data.files.forEach(file => {
                        if (file.type === 'directory') {
                            filesHtml += `<div class="delete-file-item delete-file-directory">📁 ${file.path}</div>`;
                        } else {
                            filesHtml += `<div class="delete-file-item">📄 ${file.path} <span style="color: var(--text-secondary); font-size: 11px;">(${file.size_human})</span></div>`;
                        }
                    });

                    filesContainer.innerHTML = filesHtml;
                    // Adjust position after files are loaded
                    setTimeout(adjustPosition, 50);
                } else {
                    const filesContainer = confirmation.querySelector('.delete-confirmation-files');
                    filesContainer.innerHTML = '<div class="delete-file-loading">Could not load files list</div>';
                }
            } catch (error) {
                const filesContainer = confirmation.querySelector('.delete-confirmation-files');
                filesContainer.innerHTML = '<div class="delete-file-loading">Could not load files list</div>';
            }

            // Handle Yes click
            confirmation.querySelector('.delete-confirm-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                confirmation.remove();
                deleteFolder(button.dataset.deleteFolder);
            });

            // Handle No click
            confirmation.querySelector('.delete-cancel-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                confirmation.remove();
            });

            // Close on click outside
            setTimeout(() => {
                const closeHandler = (e) => {
                    if (!confirmation.contains(e.target) && e.target !== button) {
                        confirmation.remove();
                        document.removeEventListener('click', closeHandler);
                    }
                };
                document.addEventListener('click', closeHandler);
            }, 100);
        }

        // Re-transcribe modal
        let retranscribeTaskId = null;
        let retranscribePolling = null;
        let currentFolderNumber = null;

        function openRetranscribeModal(folderNumber, folderName) {
            currentFolderNumber = folderNumber;
            const retranscribeModal = document.getElementById('re-transcribe-modal');
            const startRetranscribeBtn = document.getElementById('start-retranscribe-btn');
            const cancelRetranscribeBtn = document.getElementById('cancel-retranscribe-btn');

            // Reset state
            retranscribeModal.style.display = 'block';
            document.getElementById('retranscribe-progress-container').style.display = 'none';
            document.getElementById('retranscribe-message').textContent = '';
            document.getElementById('retranscribe-message').style.color = '#aaa';
            document.getElementById('retranscribe-progress-text').textContent = 'Initializing...';
            document.getElementById('retranscribe-progress-percent').textContent = '0%';
            document.getElementById('retranscribe-progress-fill').style.width = '0%';
            startRetranscribeBtn.disabled = false;
            cancelRetranscribeBtn.disabled = false;

            // Fetch current settings from theme.md
            fetch(`/api/re-transcribe-settings/${folderNumber}`)
                .then(response => response.json())
                .then(data => {
                    updateDropdownWithCurrent('retranscribe-model', data.current_model);
                    updateDropdownWithCurrent('retranscribe-language', data.current_language);
                    displayVideoInfo(data.video_info);
                })
                .catch(error => {
                    console.error('Failed to fetch current settings:', error);
                });
        }

        function displayVideoInfo(videoInfo) {
            const detailsDiv = document.getElementById('retranscribe-video-details');
            if (!videoInfo) {
                detailsDiv.innerHTML = '<span style="color: #ff6b6b;">Video information not available</span>';
                return;
            }

            detailsDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: auto 1fr; gap: 4px 12px;">
                    <span style="color: #888;">File:</span>
                    <span>${videoInfo.filename}</span>

                    <span style="color: #888;">Duration:</span>
                    <span>${videoInfo.duration_formatted} (${Math.round(videoInfo.duration_seconds)}s)</span>

                    <span style="color: #888;">Size:</span>
                    <span>${videoInfo.size_formatted}</span>

                    <span style="color: #888;">Resolution:</span>
                    <span>${videoInfo.resolution}</span>

                    <span style="color: #888;">FPS:</span>
                    <span>${videoInfo.fps}</span>
                </div>
                <div id="retranscribe-estimate" style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(100, 149, 237, 0.2);">
                    ${getEstimateText(videoInfo.duration_seconds, document.getElementById('retranscribe-model')?.value || 'small')}
                </div>
            `;

            // Update estimate when model changes
            const modelSelect = document.getElementById('retranscribe-model');
            modelSelect?.addEventListener('change', () => {
                updateEstimate(videoInfo.duration_seconds);
            });
        }

        function getEstimateText(durationSeconds, model) {
            // Estimated transcription times (multipliers relative to video duration on GPU)
            const modelMultipliers = {
                'base': 0.05,   // ~1/20th of video length
                'small': 0.10,  // ~1/10th of video length
                'medium': 0.25, // ~1/4th of video length
                'large': 0.50   // ~1/2 of video length
            };

            const multiplier = modelMultipliers[model] || modelMultipliers['small'];
            const estimatedSeconds = Math.round(durationSeconds * multiplier);

            // Format time
            if (estimatedSeconds < 60) {
                return `<span style="color: #4CAF50;">⏱️ Estimated time: ~${estimatedSeconds} seconds</span>`;
            } else {
                const minutes = Math.ceil(estimatedSeconds / 60);
                return `<span style="color: #4CAF50;">⏱️ Estimated time: ~${minutes} minute${minutes > 1 ? 's' : ''}</span>`;
            }
        }

        function updateEstimate(durationSeconds) {
            const model = document.getElementById('retranscribe-model')?.value || 'small';
            const estimateDiv = document.getElementById('retranscribe-estimate');
            if (estimateDiv && durationSeconds) {
                estimateDiv.innerHTML = getEstimateText(durationSeconds, model);
            }
        }

        function updateDropdownWithCurrent(selectId, currentValue) {
            const select = document.getElementById(selectId);
            if (!select) return;

            // Remove any existing " (current)" from all options
            Array.from(select.options).forEach(opt => {
                opt.text = opt.text.replace(' (current)', '');
            });

            // If currentValue is not empty/undefined, add " (current)" to matching option
            if (currentValue) {
                const matchingOption = Array.from(select.options).find(opt => opt.value === currentValue);
                if (matchingOption) {
                    matchingOption.text = matchingOption.text + ' (current)';
                    select.value = currentValue;
                }
            }
        }

        function pollRetranscribeProgress() {
            retranscribePolling = setInterval(async () => {
                if (!retranscribeTaskId) {
                    clearInterval(retranscribePolling);
                    retranscribePolling = null;
                    return;
                }

                try {
                    const response = await fetch(`/api/re-transcribe-status/${retranscribeTaskId}`);
                    const data = await response.json();

                    if (data.status === 'processing' || data.status === 'pending') {
                        // Update progress
                        const progress = data.progress || 0;
                        document.getElementById('retranscribe-message').textContent = data.log || 'Processing...';
                        document.getElementById('retranscribe-progress-text').textContent = data.log || 'Processing...';
                        document.getElementById('retranscribe-progress-percent').textContent = `${progress}%`;
                        document.getElementById('retranscribe-progress-fill').style.width = `${progress}%`;
                    } else if (data.status === 'complete') {
                        // Done!
                        clearInterval(retranscribePolling);
                        retranscribePolling = null;

                        document.getElementById('retranscribe-progress-text').textContent = 'Complete!';
                        document.getElementById('retranscribe-progress-percent').textContent = '100%';
                        document.getElementById('retranscribe-progress-fill').style.width = '100%';
                        document.getElementById('retranscribe-message').textContent = 'Transcription complete! Reloading page...';
                        document.getElementById('retranscribe-message').style.color = '#4CAF50';

                        // Reload page after showing completion
                        setTimeout(() => {
                            window.location.reload();
                        }, 2000);
                    } else if (data.status === 'error') {
                        // Error
                        clearInterval(retranscribePolling);
                        retranscribePolling = null;

                        document.getElementById('retranscribe-message').textContent = 'Error: ' + (data.error || 'Unknown error');
                        document.getElementById('retranscribe-message').style.color = '#ff6b6b';
                        document.getElementById('start-retranscribe-btn').disabled = false;
                        document.getElementById('cancel-retranscribe-btn').disabled = false;
                    }
                } catch (error) {
                    console.error('Polling error:', error);
                }
            }, 1000);
        }

        // Re-transcribe modal event listeners
        document.addEventListener('DOMContentLoaded', () => {
            const retranscribeModal = document.getElementById('re-transcribe-modal');
            const closeBtn = retranscribeModal?.querySelector('.close');
            const startRetranscribeBtn = document.getElementById('start-retranscribe-btn');
            const cancelRetranscribeBtn = document.getElementById('cancel-retranscribe-btn');

            // Close button
            closeBtn?.addEventListener('click', () => {
                retranscribeModal.style.display = 'none';
                if (retranscribePolling) {
                    clearInterval(retranscribePolling);
                    retranscribePolling = null;
                }
            });

            // Cancel button
            cancelRetranscribeBtn?.addEventListener('click', () => {
                retranscribeModal.style.display = 'none';
                if (retranscribePolling) {
                    clearInterval(retranscribePolling);
                    retranscribePolling = null;
                }
            });

            // Start transcription button
            startRetranscribeBtn?.addEventListener('click', async () => {
                const model = document.getElementById('retranscribe-model').value;
                const language = document.getElementById('retranscribe-language').value;

                // Show progress
                document.getElementById('retranscribe-progress-container').style.display = 'block';
                document.getElementById('retranscribe-message').textContent = 'Starting transcription...';
                document.getElementById('retranscribe-message').style.color = '#aaa';
                document.getElementById('retranscribe-progress-text').textContent = 'Starting...';
                document.getElementById('retranscribe-progress-percent').textContent = '0%';
                document.getElementById('retranscribe-progress-fill').style.width = '0%';

                startRetranscribeBtn.disabled = true;
                cancelRetranscribeBtn.disabled = true;

                try {
                    const response = await fetch('/api/re-transcribe', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            folder: currentFolderNumber,
                            model: model,
                            language: language
                        })
                    });

                    const data = await response.json();

                    if (data.task_id) {
                        // Start polling for progress
                        retranscribeTaskId = data.task_id;
                        pollRetranscribeProgress();
                    } else {
                        throw new Error(data.error || 'Failed to start transcription');
                    }
                } catch (error) {
                    document.getElementById('retranscribe-message').textContent = 'Error: ' + error.message;
                    document.getElementById('retranscribe-message').style.color = '#ff6b6b';
                    document.getElementById('start-retranscribe-btn').disabled = false;
                    document.getElementById('cancel-retranscribe-btn').disabled = false;
                }
            });

            // Close modal when clicking outside
            retranscribeModal.addEventListener('click', (e) => {
                if (e.target === retranscribeModal) {
                    retranscribeModal.style.display = 'none';
                    if (retranscribePolling) {
                        clearInterval(retranscribePolling);
                        retranscribePolling = null;
                    }
                }
            });
        });

        // Select folder and load themes
        async function selectFolder(folderNumber) {
            selectedFolder = folderNumber;

            try {
                const response = await fetch(`${API_BASE}/folder/${folderNumber}/themes`);
                if (!response.ok) {
                    throw new Error('No themes found for this folder');
                }

                const data = await response.json();
                displayThemes(data);
            } catch (error) {
                showNotification(error.message, 'error');
                document.getElementById('themes-panel').style.display = 'none';
            }
        }

        // Load settings
        async function loadSettings() {
            try {
                const response = await fetch(`${API_BASE}/settings`);
                const settings = await response.json();

                document.getElementById('setting-whisper-model').value = settings.whisper.model;
                document.getElementById('setting-whisper-language').value = settings.whisper.language;
                document.getElementById('setting-video-output-dir').value = settings.video.output_dir;
                document.getElementById('setting-video-aspect-ratio').value = settings.video.aspect_ratio;
                document.getElementById('setting-ai-enabled').checked = settings.theme.ai_enabled;
                document.getElementById('setting-ai-model').value = settings.theme.ai_model;
            } catch (error) {
                showNotification('Error loading settings: ' + error.message, 'error');
            }
        }

        // Save settings
        document.getElementById('save-settings-btn').addEventListener('click', async () => {
            const settings = {
                whisper: {
                    model: document.getElementById('setting-whisper-model').value,
                    language: document.getElementById('setting-whisper-language').value,
                },
                video: {
                    output_dir: document.getElementById('setting-video-output-dir').value,
                    aspect_ratio: document.getElementById('setting-video-aspect-ratio').value,
                },
                theme: {
                    ai_enabled: document.getElementById('setting-ai-enabled').checked,
                    ai_model: document.getElementById('setting-ai-model').value,
                }
            };

            try {
                const response = await fetch(`${API_BASE}/settings`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });

                if (!response.ok) {
                    throw new Error('Failed to save settings');
                }

                showNotification('Settings saved successfully!', 'success');
            } catch (error) {
                showNotification('Error saving settings: ' + error.message, 'error');
            }
        });

        // Store shorts data globally
        let allShorts = [];

        // Load shorts
        async function loadShorts() {
            try {
                const response = await fetch(`${API_BASE}/shorts`);
                allShorts = await response.json();

                // Populate folder filter dropdown
                const folderFilter = document.getElementById('shorts-folder-filter');
                const folders = [...new Set(allShorts.map(s => s.folder))];

                // Save current selection
                const currentSelection = folderFilter.value;

                folderFilter.innerHTML = '<option value="">All Videos</option>' +
                    folders.map(folder => `<option value="${folder}">${folder.replace(/^\d+_/, '').replace(/_/g, ' ')}</option>`).join('');

                // Restore selection if still valid
                if (folders.includes(currentSelection)) {
                    folderFilter.value = currentSelection;
                }

                // Apply filters and display
                filterAndDisplayShorts();

            } catch (error) {
                showNotification('Error loading shorts: ' + error.message, 'error');
            }
        }

        // Filter and display shorts based on folder and search
        function filterAndDisplayShorts() {
            const folderFilter = document.getElementById('shorts-folder-filter').value;
            const searchTerm = document.getElementById('shorts-search').value.toLowerCase();

            // Filter shorts
            const filteredShorts = allShorts.filter(short => {
                const matchesFolder = !folderFilter || short.folder === folderFilter;
                const matchesSearch = !searchTerm ||
                    short.filename.toLowerCase().includes(searchTerm) ||
                    short.folder.toLowerCase().includes(searchTerm) ||
                    `theme ${short.theme_number}`.includes(searchTerm);

                return matchesFolder && matchesSearch;
            });

            const container = document.getElementById('shorts-grid');
            container.innerHTML = '';

            if (filteredShorts.length === 0) {
                container.innerHTML = '<div class="empty-state">No shorts found matching your filters.</div>';
                return;
            }

            // Create short items using DOM methods to avoid escaping issues
            filteredShorts.forEach(short => {
                const videoUrl = '/videos/' + short.url_path;
                const displayName = short.filename.replace(/_/g, ' ').replace('.mp4', '');
                const folderName = short.folder.replace(/^\d+_/, '').replace(/_/g, ' ');

                // Encode URL path components separately to handle all special characters
                const pathParts = videoUrl.split('/');
                const encodedPath = pathParts.map(part => encodeURIComponent(part)).join('/');

                const itemDiv = document.createElement('div');
                itemDiv.className = 'short-item';
                itemDiv.dataset.videoUrl = videoUrl;
                itemDiv.dataset.filename = short.filename;

                const thumbnail = document.createElement('div');
                thumbnail.className = 'short-thumbnail';

                const video = document.createElement('video');
                video.src = encodedPath;
                video.preload = 'metadata';
                video.muted = true;
                video.loop = true;
                video.playsInline = true;

                const playIcon = document.createElement('div');
                playIcon.className = 'play-icon';
                playIcon.textContent = '▶';

                thumbnail.appendChild(video);
                thumbnail.appendChild(playIcon);

                const info = document.createElement('div');
                info.className = 'short-info';

                const title = document.createElement('div');
                title.className = 'short-title';
                title.textContent = displayName;
                title.title = displayName;

                const meta = document.createElement('div');
                meta.className = 'short-meta';
                meta.innerHTML = `
                    <span>📁 ${folderName}</span>
                    <span>🎬 Theme ${short.theme_number}</span>
                    <span>📦 ${short.size} MB</span>
                `;

                const filename = document.createElement('div');
                filename.className = 'short-filename';
                filename.textContent = short.filename;

                const actions1 = document.createElement('div');
                actions1.className = 'short-actions';

                const playBtn = document.createElement('button');
                playBtn.className = 'btn btn-secondary btn-play';
                playBtn.textContent = 'Play';
                playBtn.dataset.url = encodedPath;

                const downloadBtn = document.createElement('button');
                downloadBtn.className = 'btn btn-secondary btn-download';
                downloadBtn.textContent = 'Download';
                downloadBtn.dataset.url = encodedPath;
                downloadBtn.dataset.filename = short.filename;

                actions1.appendChild(playBtn);
                actions1.appendChild(downloadBtn);

                const actions2 = document.createElement('div');
                actions2.className = 'short-actions';

                const editBtn = document.createElement('button');
                editBtn.className = 'btn btn-secondary btn-edit';
                editBtn.textContent = 'Edit';
                editBtn.dataset.path = short.url_path;
                editBtn.dataset.filename = short.filename;
                editBtn.dataset.folderNumber = short.folder_number;
                editBtn.dataset.themeNumber = short.theme_number;
                editBtn.style.width = '100%';

                actions2.appendChild(editBtn);

                info.appendChild(title);
                info.appendChild(meta);
                info.appendChild(filename);
                info.appendChild(actions1);
                info.appendChild(actions2);

                itemDiv.appendChild(thumbnail);
                itemDiv.appendChild(info);

                container.appendChild(itemDiv);
            });

            // Add play button handlers
            container.querySelectorAll('.btn-play').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Find the video in this card and play/pause it
                    const card = btn.closest('.short-item');
                    const video = card.querySelector('video');
                    const playIcon = card.querySelector('.play-icon');
                    if (video) {
                        if (video.paused) {
                            stopAllVideos(video);
                            video.muted = false;
                            video.play();
                            if (playIcon) playIcon.style.display = 'none';
                        } else {
                            video.pause();
                            if (playIcon) playIcon.style.display = 'block';
                        }
                    }
                });
            });

            // Add download button handlers
            container.querySelectorAll('.btn-download').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const a = document.createElement('a');
                    a.href = btn.dataset.url;
                    a.download = btn.dataset.filename;
                    a.click();
                });
            });

            // Add edit button handlers
            container.querySelectorAll('.btn-edit').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const videoPath = btn.dataset.path;
                    const folderNumber = btn.dataset.folderNumber;
                    const themeNumber = btn.dataset.themeNumber;
                    window.open(`edit.html?video=${encodeURIComponent(videoPath)}&folder=${folderNumber}&theme=${themeNumber}`, '_blank');
                });
            });

            // Add click handler to play/pause video in thumbnail
            container.querySelectorAll('.short-thumbnail').forEach(thumbnail => {
                const video = thumbnail.querySelector('video');
                const playIcon = thumbnail.querySelector('.play-icon');

                // Toggle play/pause on click
                thumbnail.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (video.paused) {
                        stopAllVideos(video);
                        // Only reset to 0 if video hasn't started or has ended
                        if (video.currentTime === 0 || video.ended) {
                            video.currentTime = 0;
                        }
                        video.muted = false;
                        video.play();
                        if (playIcon) playIcon.style.display = 'none';
                    } else {
                        video.pause();
                        if (playIcon) playIcon.style.display = 'block';
                    }
                });

                // Show play icon when video ends
                video.addEventListener('ended', () => {
                    if (playIcon) playIcon.style.display = 'block';
                });
            });

            // Remove hover playback since click now controls it
            // Add click handler for the whole card (but not video or buttons)
            container.querySelectorAll('.short-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    // Don't trigger if clicking on video, buttons, or actions
                    if (e.target.closest('.short-thumbnail') ||
                        e.target.closest('.short-actions') ||
                        e.target.closest('button')) {
                        return;
                    }

                    // Toggle play/pause the video in the thumbnail
                    const video = item.querySelector('video');
                    const playIcon = item.querySelector('.play-icon');
                    if (video) {
                        if (video.paused) {
                            stopAllVideos(video);
                            // Only reset to 0 if video hasn't started or has ended
                            if (video.currentTime === 0 || video.ended) {
                                video.currentTime = 0;
                            }
                            video.muted = false;
                            video.play();
                            if (playIcon) playIcon.style.display = 'none';
                        } else {
                            video.pause();
                            if (playIcon) playIcon.style.display = 'block';
                        }
                    }
                });
            });
        }

        // Stop all videos except the one being played
        function stopAllVideos(exceptVideo) {
            document.querySelectorAll('.short-thumbnail video').forEach(video => {
                if (video !== exceptVideo) {
                    video.pause();
                    video.currentTime = 0;
                    video.muted = true;
                    const playIcon = video.parentElement.querySelector('.play-icon');
                    if (playIcon) playIcon.style.display = 'block';
                }
            });
        }

        // Refresh shorts button
        document.getElementById('refresh-shorts-btn').addEventListener('click', () => {
            loadShorts();
        });

        // Folder filter change
        document.getElementById('shorts-folder-filter').addEventListener('change', () => {
            filterAndDisplayShorts();
        });

        // Search input
        document.getElementById('shorts-search').addEventListener('input', () => {
            filterAndDisplayShorts();
        });

        // Display themes
        function displayThemes(data) {
            const panel = document.getElementById('themes-panel');
            panel.style.display = 'block';

            document.getElementById('selected-folder-title').textContent = data.title;
            document.getElementById('folder-stats').innerHTML = `
                <div class="stat">
                    <div class="stat-value">${data.themes.length}</div>
                    <div class="stat-label">Themes</div>
                </div>
                <button class="retranscribe-folder-btn" data-retranscribe-folder="${selectedFolder}" data-folder-number="${selectedFolder}" title="Re-transcribe video">🔄</button>
            `;

            // Attach click handler to the re-transcribe button
            const retranscribeBtn = document.getElementById('folder-stats')?.querySelector('.retranscribe-folder-btn');
            if (retranscribeBtn) {
                retranscribeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const folderNumber = e.target.dataset.folderNumber;
                    const folderName = e.target.dataset.retranscribeFolder;
                    openRetranscribeModal(folderNumber, folderName);
                });
            }

            const container = document.getElementById('themes-list');
            container.innerHTML = data.themes.map(theme => `
                <label class="theme-item" data-theme="${theme.number}">
                    <input type="checkbox" class="theme-checkbox" data-theme="${theme.number}">
                    <div class="theme-content">
                        <div class="theme-header">
                            <span class="theme-number">Theme ${theme.number} <button class="theme-adjust-btn" data-theme-number="${theme.number}" data-folder="${selectedFolder}">Adjust</button> ${theme.short_created ? `<button class="theme-play-btn" data-video-path="${theme.short_info.path}">Play</button>` : ''}</span>
                            <div class="theme-header-row">
                                ${theme.short_created ? '<span class="theme-created-badge">Short Created</span>' : `<span class="theme-duration">${theme.end}</span>`}
                            </div>
                        </div>
                        <div class="theme-title">${theme.title}</div>
                        <div class="theme-time">${theme.start} - ${theme.end}</div>
                        <div class="theme-progress-bar" id="theme-progress-${theme.number}" style="display: none; margin-top: 8px;">
                            <div class="progress-bar" style="height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                                <div class="progress-fill" style="height: 100%; width: 0%; background: linear-gradient(90deg, #00ff9d, #00bfff); transition: width 0.3s ease;"></div>
                            </div>
                            <div class="theme-progress-text" style="font-size: 10px; color: #00ff9d; margin-top: 2px;"></div>
                        </div>
                    </div>
                </label>
            `).join('');

            // Update create button state
            container.querySelectorAll('.theme-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', updateCreateButton);
            });

            // Add hover and click handlers for play buttons
            const tooltip = document.getElementById('tooltip');
            const videoModal = document.getElementById('video-modal');
            const videoPlayer = document.getElementById('video-player');

            container.querySelectorAll('.theme-play-btn').forEach(btn => {
                const videoPath = btn.dataset.videoPath;
                // Properly encode the URL path
                const pathParts = videoPath.split('/');
                const encodedPath = pathParts.map(part => encodeURIComponent(part)).join('/');
                const videoUrl = '/' + encodedPath.replace(/^\/+/, '');

                // Store encoded URL on the button
                btn.dataset.encodedUrl = videoUrl;

                // Hover tooltip
                btn.addEventListener('mouseenter', (e) => {
                    tooltip.textContent = videoPath;
                    tooltip.classList.add('show');
                    updateTooltipPosition(e);
                });

                btn.addEventListener('mousemove', updateTooltipPosition);

                btn.addEventListener('mouseleave', () => {
                    tooltip.classList.remove('show');
                });

                // Click to play video
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    videoPlayer.src = videoUrl;
                    videoModal.classList.add('show');
                    videoPlayer.play();
                });
            });

            // Add click handlers for Adjust buttons
            container.querySelectorAll('.theme-adjust-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const themeNumber = btn.dataset.themeNumber;
                    const folder = btn.dataset.folder;
                    // Open adjust.html in new tab with theme details
                    window.open(`/adjust.html?folder=${encodeURIComponent(folder)}&theme=${encodeURIComponent(themeNumber)}`, '_blank');
                });
            });

            // Scroll to themes panel
            panel.scrollIntoView({ behavior: 'smooth' });
        }

        function updateTooltipPosition(e) {
            const tooltip = document.getElementById('tooltip');
            const x = e.clientX + 15;
            const y = e.clientY + 15;

            // Keep tooltip within viewport
            const maxX = window.innerWidth - tooltip.offsetWidth - 10;
            const maxY = window.innerHeight - tooltip.offsetHeight - 10;

            tooltip.style.left = Math.min(x, maxX) + 'px';
            tooltip.style.top = Math.min(y, maxY) + 'px';
        }

        // YouTube Search functionality
        const urlInput = document.getElementById('url-input');
        const searchResults = document.getElementById('search-results');
        let searchTimeout = null;
        let currentSearchQuery = '';
        let currentSearchResults = [];
        let currentPage = 0;
        const resultsPerPage = 5;

        // YouTube URL patterns
        const youtubeUrlPatterns = [
            /^(https?:\/\/)?(www\.)?(youtube\.com\/watch\?v=[\w-]+)/,
            /^(https?:\/\/)?(www\.)?(youtu\.be\/[\w-]+)/,
            /^(https?:\/\/)?(www\.)?(youtube\.com\/embed\/[\w-]+)/,
        ];

        // Check if input is a direct YouTube URL
        function isYouTubeUrl(text) {
            return youtubeUrlPatterns.some(pattern => pattern.test(text));
        }

        // Search YouTube using Invidious API
        async function searchYouTube(query) {
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }

            // Hide results if query is too short or is a direct URL
            if (query.length < 3 || isYouTubeUrl(query)) {
                searchResults.classList.add('hidden');
                return;
            }

            searchTimeout = setTimeout(async () => {
                try {
                    searchResults.innerHTML = '<div class="search-loading">Searching...</div>';
                    searchResults.classList.remove('hidden');

                    // Use server-side proxy to avoid CORS
                    const response = await fetch(`${API_BASE}/youtube-search?q=${encodeURIComponent(query)}`);

                    if (!response.ok) {
                        throw new Error('Search failed');
                    }

                    const results = await response.json();

                    if (!results || results.length === 0) {
                        searchResults.innerHTML = '<div class="search-error">No results found</div>';
                        return;
                    }

                    currentSearchQuery = query;
                    currentSearchResults = results;
                    currentPage = 0;
                    displaySearchResults();
                } catch (error) {
                    console.error('Search error:', error);
                    searchResults.innerHTML = '<div class="search-error">Search failed. Please try again.</div>';
                }
            }, 400); // Debounce: wait 400ms after typing stops
        }

        function displaySearchResults() {
            const totalPages = Math.ceil(currentSearchResults.length / resultsPerPage);
            const start = currentPage * resultsPerPage;
            const end = start + resultsPerPage;
            const pageResults = currentSearchResults.slice(start, end);

            let html = pageResults.map(video => {
                const thumbnails = video.videoThumbnails || [];
                const initialThumb = thumbnails.find(t => t.quality === 'hqdefault')?.url ||
                                     thumbnails.find(t => t.quality === 'mqdefault')?.url ||
                                     thumbnails[0]?.url ||
                                     '';
                const videoUrl = `https://www.youtube.com/watch?v=${video.videoId}`;

                return `
                <a href="${videoUrl}" target="_blank" class="search-result-item" data-thumbnails='${JSON.stringify(thumbnails)}' onclick="event.preventDefault(); window.selectVideo('${videoUrl}');">
                    <img class="search-result-thumbnail" src="${initialThumb}" alt="" onerror="window.handleThumbnailError(this)">
                    <div class="search-result-info">
                        <div class="search-result-title">${video.title || 'Untitled'}</div>
                        <div class="search-result-meta">
                            <span>${formatDuration(video.lengthSeconds || 0)}</span>
                            <span>•</span>
                            <span class="search-result-channel">
                                ${video.author || 'Unknown'}
                            </span>
                        </div>
                    </div>
                </a>
                `;
            }).join('');

            // Add pagination controls
            if (totalPages > 1) {
                html += `
                <div class="search-pagination">
                    <button onclick="event.stopPropagation(); window.prevSearchPage()" ${currentPage === 0 ? 'disabled' : ''}>← Previous</button>
                    <span style="color: var(--text-secondary); font-size: 13px;">Page ${currentPage + 1} of ${totalPages}</span>
                    <button onclick="event.stopPropagation(); window.nextSearchPage()" ${currentPage >= totalPages - 1 ? 'disabled' : ''}>Next →</button>
                </div>
                `;
            }

            searchResults.innerHTML = html;
        }

        window.selectVideo = function(videoUrl) {
            urlInput.value = videoUrl;
            searchResults.classList.add('hidden');
            urlInput.dispatchEvent(new Event('input'));
        };

        window.nextSearchPage = function() {
            const totalPages = Math.ceil(currentSearchResults.length / resultsPerPage);
            if (currentPage < totalPages - 1) {
                currentPage++;
                displaySearchResults();
                searchResults.scrollTop = 0;
            }
        };

        window.prevSearchPage = function() {
            if (currentPage > 0) {
                currentPage--;
                displaySearchResults();
                searchResults.scrollTop = 0;
            }
        };

        // Handle thumbnail errors by trying next quality
        window.handleThumbnailError = function(img) {
            const item = img.closest('.search-result-item');
            if (!item) return;

            const thumbnails = JSON.parse(item.dataset.thumbnails || '[]');
            const currentSrc = img.src;
            const currentIndex = thumbnails.findIndex(t => t.url === currentSrc);

            // Try next thumbnail quality
            if (currentIndex < thumbnails.length - 1) {
                img.src = thumbnails[currentIndex + 1].url;
            } else {
                // All failed, use placeholder
                img.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 120 68"><rect fill="%23252525" width="120" height="68"/><text fill="%23808080" x="50%" y="50%" text-anchor="middle" dominant-baseline="middle" font-size="12">No Image</text></svg>';
            }
        }

        // Format duration (seconds to MM:SS)
        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Input event handler
        urlInput.addEventListener('input', () => {
            const value = urlInput.value.trim();

            if (isYouTubeUrl(value)) {
                // Direct URL - hide search results
                searchResults.classList.add('hidden');
            } else if (value.length > 0) {
                // Search query
                searchYouTube(value);
            } else {
                // Empty input
                searchResults.classList.add('hidden');
            }
        });

        // Focus event handler - show cached results if available
        urlInput.addEventListener('focus', () => {
            const value = urlInput.value.trim();
            // Show cached results if we have them and input hasn't changed to a URL
            if (currentSearchResults.length > 0 && value === currentSearchQuery && !isYouTubeUrl(value)) {
                searchResults.classList.remove('hidden');
            }
        });

        // Hide search results when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-results-container')) {
                searchResults.classList.add('hidden');
            }
        });

        // Hide search results on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                searchResults.classList.add('hidden');
            }
        });

        // Update create shorts button
        function updateCreateButton() {
            const checked = document.querySelectorAll('.theme-checkbox:checked').length;
            const hasSelection = checked > 0;
            document.getElementById('create-shorts-btn').disabled = !hasSelection;
            document.getElementById('select-all-btn').disabled = !hasSelection;
            document.getElementById('deselect-all-btn').disabled = !hasSelection;
            document.getElementById('regenerate-btn').disabled = !hasSelection;
        }

        // Select/Deselect all
        document.getElementById('select-all-btn').addEventListener('click', () => {
            document.querySelectorAll('.theme-checkbox').forEach(cb => cb.checked = true);
            updateCreateButton();
        });

        document.getElementById('deselect-all-btn').addEventListener('click', () => {
            document.querySelectorAll('.theme-checkbox').forEach(cb => cb.checked = false);
            updateCreateButton();
        });

        // Process video
        document.getElementById('process-btn').addEventListener('click', async () => {
            const url = document.getElementById('url-input').value.trim();
            const file = document.getElementById('file-input').files[0];
            const resolution = document.getElementById('resolution-input').value;
            const model = document.getElementById('model-input').value;
            const language = document.getElementById('language-input').value;

            if (!url && !file) {
                showNotification('Please enter a URL or select a file', 'error');
                return;
            }

            const progressContainer = document.getElementById('process-progress');
            const progressBar = document.getElementById('main-progress-fill');
            const subtitleProgressBar = document.getElementById('subtitle-progress-fill');
            const subtitleProgressContainer = document.getElementById('subtitle-progress-container');
            const themeProgressBar = document.getElementById('theme-progress-fill');
            const progressText = document.getElementById('process-text');
            const subtitleText = document.getElementById('subtitle-text');
            const themeText = document.getElementById('theme-text');
            const processLog = document.getElementById('process-log');
            const cancelBtn = document.getElementById('cancel-process-btn');
            progressContainer.classList.add('active');
            processLog.classList.add('active');
            processLog.textContent = '';
            progressBar.style.width = '0%';
            progressBar.style.animation = 'none';
            subtitleProgressBar.style.width = '0%';
            themeProgressBar.style.width = '0%';
            if (subtitleProgressContainer) {
                subtitleProgressContainer.style.opacity = '0.3';
            }
            if (themeProgressBar && themeProgressBar.parentElement) {
                themeProgressBar.parentElement.style.opacity = '0.3';
            }
            document.getElementById('process-btn').disabled = true;
            cancelBtn.style.display = 'inline-block';

            try {
                const payload = { model, language };
                if (url) {
                    payload.url = url;
                    payload.resolution = resolution;
                }
                if (file) payload.local_file = file.path || file.name;

                const response = await fetch(`${API_BASE}/process`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error('Failed to start processing');
                }

                const { task_id } = await response.json();
                currentTaskId = task_id;
                await monitorTask(task_id, (status) => {
                    if (status.log) {
                        processLog.textContent = status.log;
                        processLog.scrollTop = processLog.scrollHeight;

                        // Detect current stage and update progress text
                        const log = status.log.toLowerCase();

                        // Theme generation stage (check FIRST - has priority for "Progress:" during generation)
                        if (log.includes('theme') || log.includes('generating')) {
                            // Keep main download bar at 100% and full opacity
                            progressBar.style.width = '100%';
                            if (progressBar.parentElement) {
                                progressBar.parentElement.style.opacity = '1';
                            }

                            // Keep subtitle bar at 100% (complete) and show theme bar
                            if (subtitleProgressContainer) {
                                subtitleProgressContainer.style.opacity = '1';
                                subtitleProgressBar.style.width = '100%';
                            }
                            subtitleText.textContent = '✅ Subtitles complete';
                            if (themeProgressBar && themeProgressBar.parentElement) {
                                themeProgressBar.parentElement.style.opacity = '1';
                            }

                            // Find all progress percentages and use the last one
                            const themeMatches = [...status.log.matchAll(/Progress:\s*(\d+)%/gi)];
                            // Find the last theme title
                            const titleMatches = [...status.log.matchAll(/Theme\s+\d+:\s*(.+?)(?:\.\.\.|$)/gim)];
                            if (themeMatches.length > 0) {
                                const lastMatch = themeMatches[themeMatches.length - 1];
                                const percent = parseInt(lastMatch[1]);
                                themeProgressBar.style.width = `${percent}%`;
                                themeProgressBar.style.animation = 'none';
                                // Show theme title if available
                                if (titleMatches.length > 0) {
                                    const lastTitle = titleMatches[titleMatches.length - 1];
                                    const titleText = lastTitle[1].trim();
                                    progressText.textContent = `⬇️ Download: Complete | 🎤 Subtitles: Complete | ✨ Themes: ${percent}%`;
                                    themeText.textContent = `✨ ${titleText}`;
                                } else {
                                    progressText.textContent = `⬇️ Download: Complete | 🎤 Subtitles: Complete | ✨ Themes: ${percent}%`;
                                    themeText.textContent = `✨ Generating: ${percent}%`;
                                }
                            } else if (log.includes('identified') || log.includes('ai identified')) {
                                progressText.textContent = '✨ Identifying themes with AI...';
                                themeText.textContent = 'AI analyzing...';
                            } else {
                                progressText.textContent = '✨ Generating themes...';
                                themeText.textContent = 'Processing...';
                            }
                        }
                        // Whisper/subtitle stage (checks for "Progress:" when not generating themes)
                        else if (log.includes('progress:') || log.includes('whisper') || log.includes('transcrib') || log.includes('subtitle')) {
                            // Keep main download bar at 100% and full opacity
                            progressBar.style.width = '100%';
                            if (progressBar.parentElement) {
                                progressBar.parentElement.style.opacity = '1';
                            }

                            // Show subtitle bar, hide theme bar
                            if (subtitleProgressContainer) {
                                subtitleProgressContainer.style.opacity = '1';
                            }
                            if (themeProgressBar && themeProgressBar.parentElement) {
                                themeProgressBar.parentElement.style.opacity = '0.3';
                            }

                            // Find all whisper percentages and use the last one
                            const whisperMatches = [...status.log.matchAll(/(\d+)%/gi)];
                            if (log.includes('subtitles: complete') || log.includes('created subtitles')) {
                                // Subtitles are complete - keep bar at 100%
                                subtitleProgressBar.style.width = '100%';
                                subtitleProgressBar.style.animation = 'none';
                                progressText.textContent = `⬇️ Download: Complete | 🎤 Subtitles: Complete`;
                                subtitleText.textContent = '✅ Subtitles complete';
                            } else if (whisperMatches.length > 0) {
                                const lastMatch = whisperMatches[whisperMatches.length - 1];
                                const percent = parseInt(lastMatch[1]);
                                subtitleProgressBar.style.width = `${percent}%`;
                                subtitleProgressBar.style.animation = 'none';
                                progressText.textContent = `⬇️ Download: Complete | 🎤 Subtitles: ${percent}%`;
                                subtitleText.textContent = `🎤 Processing: ${percent}%`;
                            } else if (log.includes('loading')) {
                                progressText.textContent = `⬇️ Download: Complete | 🎤 Loading Whisper...`;
                                subtitleText.textContent = '🎤 Loading Whisper model...';
                            } else {
                                progressText.textContent = `⬇️ Download: Complete | 🎤 Generating subtitles...`;
                                subtitleText.textContent = '🎤 Starting...';
                            }
                        }
                        // Download stage - look for [download] with percentage
                        else if (log.includes('[download]')) {
                            // Find all download percentages and use the last one
                            const downloadMatches = [...status.log.matchAll(/\[download\]\s+(\d+\.?\d*)%/gi)];
                            if (downloadMatches.length > 0) {
                                const lastMatch = downloadMatches[downloadMatches.length - 1];
                                const percent = parseFloat(lastMatch[1]);
                                progressBar.style.width = `${percent}%`;
                                progressBar.style.animation = 'none';
                                progressText.textContent = `⬇️ Downloading: ${percent}%`;
                                // Hide other bars
                                if (subtitleProgressContainer) {
                                    subtitleProgressContainer.style.opacity = '0.3';
                                }
                                if (themeProgressBar && themeProgressBar.parentElement) {
                                    themeProgressBar.parentElement.style.opacity = '0.3';
                                }
                            } else {
                                progressText.textContent = '⬇️ Downloading...';
                            }
                        }
                        // Creating shorts stage
                        else if (log.includes('short') || log.includes('creating shorts')) {
                            // Check for which theme is being processed
                            const shortMatch = log.match(/Short\s+(\d+)\/\d+:\s+Theme\s+(\d+)/);
                            if (shortMatch) {
                                const currentShort = parseInt(shortMatch[1]);
                                const totalShorts = parseInt(shortMatch[2]);
                                const themeNum = shortMatch[3];
                                const progress = Math.round(((currentShort - 1) / totalShorts) * 100);

                                // Show and update this theme's progress bar
                                const themeProgressBar = document.getElementById(`theme-progress-${themeNum}`);
                                if (themeProgressBar) {
                                    const progressBar = themeProgressBar.querySelector('.progress-fill');
                                    const progressText = themeProgressBar.querySelector('.theme-progress-text');

                                    themeProgressBar.style.display = 'block';
                                    if (progressBar) {
                                        progressBar.style.width = `${progress}%`;
                                    }
                                    if (progressText) {
                                        progressText.textContent = `Creating short... ${progress}%`;
                                    }

                                    // Mark as in-progress by adding a class
                                    themeProgressBar.classList.add('processing');
                                }
                            }

                            // Update overall task progress text
                            const progressMatches = status.log.matchAll(/Progress:\s*(\d+)%/g);
                            if (progressMatches.length > 0) {
                                const lastMatch = progressMatches[progressMatches.length - 1];
                                const fullLine = lastMatch[0];  // Full match including "(X/Y done)"
                                const percent = parseInt(lastMatch[1]);
                                // Extract the "(X/Y done)" part if present
                                const donePart = fullLine.match(/\((\d+\/\d+)\s+done\)/);
                                if (donePart) {
                                    taskProgressText.textContent = `Creating shorts... ${percent}% (${donePart[1]} done)`;
                                } else {
                                    taskProgressText.textContent = `Creating shorts... ${percent}%`;
                                }
                            }

                            // Check for theme completion
                            if (log.includes('✓ Short created successfully') || log.includes('✗ Failed to create short')) {
                                // Find which theme just completed
                                const shortMatch = log.match(/Short\s+(\d+)\/\d+:\s+Theme\s+(\d+)/);
                                if (shortMatch) {
                                    const themeNum = shortMatch[3];
                                    const themeProgressBar = document.getElementById(`theme-progress-${themeNum}`);
                                    if (themeProgressBar) {
                                        const progressBar = themeProgressBar.querySelector('.progress-fill');
                                        const progressText = themeProgressBar.querySelector('.theme-progress-text');

                                        themeProgressBar.classList.remove('processing');
                                        if (progressBar && progressText) {
                                            if (log.includes('✓ Short created successfully')) {
                                                progressBar.style.width = '100%';
                                                progressBar.style.background = 'linear-gradient(90deg, #00ff9d, #00ff9d)';
                                                progressText.textContent = '✓ Short created!';
                                                progressText.style.color = '#00ff9d';
                                            } else {
                                                progressBar.style.width = '100%';
                                                progressBar.style.background = 'linear-gradient(90deg, #ff6b6b, #ff4444)';
                                                progressText.textContent = '✗ Failed';
                                                progressText.style.color = '#ff6b6b';
                                            }
                                        }
                                    }

                                    // Hide the progress bar after a delay
                                    setTimeout(() => {
                                        if (themeProgressBar) {
                                            themeProgressBar.style.display = 'none';
                                            themeProgressBar.classList.remove('processing');
                                        }
                                    }, 2000);
                                }
                            }
                        }
                        // Processing stage
                        else if (log.includes('processing')) {
                            progressText.textContent = '⚙️ Processing...';
                        }
                        // Default/fallback
                        else {
                            progressText.textContent = 'Processing: ' + (status.type || 'unknown') + '...';
                        }
                    } else {
                        progressText.textContent = 'Processing: ' + (status.type || 'unknown') + '...';
                    }
                });

                const result = await monitorTask(task_id, (status) => {
                    if (status.log) {
                        processLog.textContent = status.log;
                        processLog.scrollTop = processLog.scrollHeight;

                        // Detect current stage and update progress text
                        const log = status.log.toLowerCase();

                        // Theme generation stage (check FIRST - has priority for "Progress:" during generation)
                        if (log.includes('theme') || log.includes('generating')) {
                            // Keep main download bar at 100% and full opacity
                            progressBar.style.width = '100%';
                            if (progressBar.parentElement) {
                                progressBar.parentElement.style.opacity = '1';
                            }

                            // Keep subtitle bar at 100% (complete) and show theme bar
                            if (subtitleProgressContainer) {
                                subtitleProgressContainer.style.opacity = '1';
                                subtitleProgressBar.style.width = '100%';
                            }
                            subtitleText.textContent = '✅ Subtitles complete';
                            if (themeProgressBar && themeProgressBar.parentElement) {
                                themeProgressBar.parentElement.style.opacity = '1';
                            }

                            // Find all progress percentages and use the last one
                            const themeMatches = [...status.log.matchAll(/Progress:\s*(\d+)%/gi)];
                            // Find the last theme title
                            const titleMatches = [...status.log.matchAll(/Theme\s+\d+:\s*(.+?)(?:\.\.\.|$)/gim)];
                            if (themeMatches.length > 0) {
                                const lastMatch = themeMatches[themeMatches.length - 1];
                                const percent = parseInt(lastMatch[1]);
                                themeProgressBar.style.width = `${percent}%`;
                                themeProgressBar.style.animation = 'none';
                                // Show theme title if available
                                if (titleMatches.length > 0) {
                                    const lastTitle = titleMatches[titleMatches.length - 1];
                                    const titleText = lastTitle[1].trim();
                                    progressText.textContent = `⬇️ Download: Complete | 🎤 Subtitles: Complete | ✨ Themes: ${percent}%`;
                                    themeText.textContent = `✨ ${titleText}`;
                                } else {
                                    progressText.textContent = `⬇️ Download: Complete | 🎤 Subtitles: Complete | ✨ Themes: ${percent}%`;
                                }
                            }
                        }
                        // Whisper/subtitle stage (checks for "Progress:" when not generating themes)
                        else if (log.includes('progress:') || log.includes('whisper') || log.includes('transcrib') || log.includes('subtitle')) {
                            // Keep main download bar at 100% and full opacity
                            progressBar.style.width = '100%';
                            if (progressBar.parentElement) {
                                progressBar.parentElement.style.opacity = '1';
                            }

                            // Find all progress percentages and use the last one
                            const whisperMatches = [...status.log.matchAll(/Progress:\s*(\d+)%/gi)];
                            if (whisperMatches.length > 0) {
                                const lastMatch = whisperMatches[whisperMatches.length - 1];
                                const percent = parseInt(lastMatch[1]);
                                subtitleProgressBar.style.width = `${percent}%`;
                                subtitleProgressBar.style.animation = 'none';
                                progressText.textContent = `⬇️ Download: Complete | 🎤 Subtitles: ${percent}%`;
                                subtitleText.textContent = `🎤 Generating subtitles... ${percent}%`;
                            }

                            // Show subtitle progress bar
                            if (subtitleProgressContainer) {
                                subtitleProgressContainer.style.opacity = '1';
                            }
                            if (themeProgressBar && themeProgressBar.parentElement) {
                                themeProgressBar.parentElement.style.opacity = '0.3';
                            }
                        }
                        // Download stage - comes AFTER theme and whisper checks
                        else if (log.includes('[download]')) {
                            // Find all download percentages and use the last one
                            const downloadMatches = [...status.log.matchAll(/\[download\]\s+(\d+\.?\d*)%/gi)];
                            if (downloadMatches.length > 0) {
                                const lastMatch = downloadMatches[downloadMatches.length - 1];
                                const percent = parseFloat(lastMatch[1]);
                                progressBar.style.width = `${percent}%`;
                                progressBar.style.animation = 'none';
                                progressText.textContent = `⬇️ Downloading: ${percent}%`;
                                // Hide other bars
                                if (subtitleProgressContainer) {
                                    subtitleProgressContainer.style.opacity = '0.3';
                                }
                                if (themeProgressBar && themeProgressBar.parentElement) {
                                    themeProgressBar.parentElement.style.opacity = '0.3';
                                }
                            } else {
                                progressText.textContent = '⬇️ Downloading...';
                            }
                        }
                        // Processing stage
                        else if (log.includes('processing')) {
                            progressText.textContent = '⚙️ Processing...';
                        }
                        // Default/fallback
                        else {
                            progressText.textContent = 'Processing: ' + (status.type || 'unknown') + '...';
                        }
                    } else {
                        progressText.textContent = 'Processing: ' + (status.type || 'unknown') + '...';
                    }
                });

                // Handle cancelled tasks
                if (result && result.cancelled) {
                    showNotification('Cancelled Successfully', 'success', 5000);
                    progressContainer.classList.remove('active');
                    processLog.classList.remove('active');
                    document.getElementById('process-btn').disabled = false;
                    cancelBtn.style.display = 'none';
                    currentTaskId = null;
                    return;
                }

                showNotification('Video processed successfully!', 'success');

                // Hide progress container and clear all progress indicators
                progressContainer.classList.remove('active');
                processLog.classList.remove('active');
                progressBar.style.width = '0%';
                subtitleProgressBar.style.width = '0%';
                themeProgressBar.style.width = '0%';
                progressText.textContent = 'Processing...';
                subtitleText.textContent = '';
                themeText.textContent = '';

                // Reset form
                document.getElementById('url-input').value = '';
                document.getElementById('file-input').value = '';

                // Switch to library tab
                setTimeout(() => {
                    document.querySelector('[data-tab="library"]').click();
                }, 1500);

            } catch (error) {
                // Add error to log and keep it visible
                processLog.textContent += '\n\n❌ ERROR: ' + error.message + '\n\n(Click "Close" to dismiss)';
                processLog.style.color = '#ff6b6b';
                progressText.textContent = '❌ Error occurred';
                progressContainer.classList.add('error');  // Keep visible
                cancelBtn.textContent = 'Close';
                cancelBtn.onclick = () => {
                    progressContainer.classList.remove('active', 'error');
                    processLog.classList.remove('active');
                    processLog.style.color = '';
                    document.getElementById('process-btn').disabled = false;
                    cancelBtn.style.display = 'none';
                    cancelBtn.textContent = 'Cancel';
                    cancelBtn.onclick = null;
                    currentTaskId = null;
                };
                showNotification('Error: ' + error.message, 'error');
            } finally {
                // Only hide if there's no error
                if (!processContainer.classList.contains('error')) {
                    progressContainer.classList.remove('active');
                    processLog.classList.remove('active');
                    document.getElementById('process-btn').disabled = false;
                    cancelBtn.style.display = 'none';
                    currentTaskId = null;
                }
            }
        });

        // Cancel process
        document.getElementById('cancel-process-btn').addEventListener('click', async () => {
            if (!currentTaskId) return;

            try {
                const response = await fetch(`${API_BASE}/task/${currentTaskId}/cancel`, {
                    method: 'POST'
                });

                if (response.ok) {
                    showNotification('Process cancelled', 'success');
                    currentTaskId = null;
                    document.getElementById('process-progress').classList.remove('active');
                    document.getElementById('process-btn').disabled = false;
                    document.getElementById('cancel-process-btn').style.display = 'none';
                }
            } catch (error) {
                showNotification('Error cancelling: ' + error.message, 'error');
            }
        });

        // Regenerate themes
        document.getElementById('regenerate-btn').addEventListener('click', async () => {
            if (!selectedFolder) return;

            const model = 'small'; // Default model
            const taskProgress = document.getElementById('task-progress');
            const taskProgressText = document.getElementById('task-progress-text');
            const cancelTaskBtn = document.getElementById('cancel-task-btn');

            taskProgress.style.display = 'block';
            taskProgressText.textContent = 'Regenerating themes...';
            cancelTaskBtn.style.display = 'inline-block';

            // Disable buttons
            document.getElementById('select-all-btn').disabled = true;
            document.getElementById('deselect-all-btn').disabled = true;
            document.getElementById('regenerate-btn').disabled = true;
            document.getElementById('create-shorts-btn').disabled = true;

            try {
                const response = await fetch(`${API_BASE}/regenerate-themes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ folder_number: selectedFolder, model })
                });

                if (!response.ok) throw new Error('Failed to regenerate themes');

                const { task_id } = await response.json();
                currentTaskId = task_id;

                const result = await monitorTask(task_id);

                // Handle cancelled tasks
                if (result && result.cancelled) {
                    showNotification('Cancelled Successfully', 'success', 5000);
                    return;
                }

                // Reload themes
                selectFolder(selectedFolder);
                showNotification('Themes regenerated!', 'success');
            } catch (error) {
                showNotification('Error: ' + error.message, 'error');
            } finally {
                taskProgress.style.display = 'none';
                cancelTaskBtn.style.display = 'none';
                currentTaskId = null;
                updateCreateButton();
            }
        });

        // Create shorts
        document.getElementById('create-shorts-btn').addEventListener('click', async () => {
            if (!selectedFolder) return;

            const checkedThemes = Array.from(document.querySelectorAll('.theme-checkbox:checked'))
                .map(cb => parseInt(cb.dataset.theme));

            if (checkedThemes.length === 0) return;

            const taskProgress = document.getElementById('task-progress');
            const taskProgressText = document.getElementById('task-progress-text');
            const cancelTaskBtn = document.getElementById('cancel-task-btn');

            taskProgress.style.display = 'block';
            taskProgressText.textContent = 'Creating shorts...';
            cancelTaskBtn.style.display = 'inline-block';

            // Scroll to progress bar
            taskProgress.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // Disable buttons
            document.getElementById('select-all-btn').disabled = true;
            document.getElementById('deselect-all-btn').disabled = true;
            document.getElementById('regenerate-btn').disabled = true;
            document.getElementById('create-shorts-btn').disabled = true;

            try {
                const response = await fetch(`${API_BASE}/create-shorts`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        folder_number: selectedFolder,
                        themes: checkedThemes
                    })
                });

                if (!response.ok) throw new Error('Failed to create shorts');

                const { task_id } = await response.json();
                currentTaskId = task_id;

                const result = await monitorTask(task_id, (status) => {
                    if (status.log) {
                        // Get current theme being processed
                        const themeMatches = [...status.log.matchAll(/Short\s+\d+\/\d+:\s+Theme\s+\d+\s+-\s+(.+?)\.\.\./g)];
                        const currentTheme = themeMatches.length > 0 ? themeMatches[themeMatches.length - 1][1].trim() : '';

                        // Update overall task progress text and bar - capture the full line to get "(X/Y done)"
                        const progressLineMatches = [...status.log.matchAll(/Progress:\s*\d+%\s*(?:\((\d+\/\d+)\s+done\))?/g)];
                        if (progressLineMatches.length > 0) {
                            const lastLine = progressLineMatches[progressLineMatches.length - 1][0];
                            const percentMatch = lastLine.match(/Progress:\s*(\d+)%/);
                            const doneMatch = lastLine.match(/\((\d+\/\d+)\s+done\)/);
                            const percent = percentMatch ? parseInt(percentMatch[1]) : 0;

                            if (currentTheme) {
                                if (doneMatch) {
                                    taskProgressText.textContent = `Creating: ${currentTheme} (${percent}%, ${doneMatch[1]} done)`;
                                } else {
                                    taskProgressText.textContent = `Creating: ${currentTheme} (${percent}%)`;
                                }
                            } else {
                                if (doneMatch) {
                                    taskProgressText.textContent = `Creating shorts... ${percent}% (${doneMatch[1]} done)`;
                                } else {
                                    taskProgressText.textContent = `Creating shorts... ${percent}%`;
                                }
                            }

                            // Also update the visual progress bar at the bottom
                            const taskProgressBar = taskProgress.querySelector('.progress-fill');
                            if (taskProgressBar) {
                                taskProgressBar.style.width = `${percent}%`;
                                taskProgressBar.style.animation = 'none';
                                taskProgressBar.style.background = 'var(--accent)';
                            }
                        }
                    }
                });

                // Handle cancelled tasks
                if (result && result.cancelled) {
                    showNotification('Cancelled Successfully', 'success', 5000);
                    return;
                }

                // Reload folder list and themes to show green badges
                loadFolders();
                selectFolder(selectedFolder);
                showNotification('Shorts created!', 'success');
            } catch (error) {
                showNotification('Error: ' + error.message, 'error');
            } finally {
                taskProgress.style.display = 'none';
                cancelTaskBtn.style.display = 'none';
                currentTaskId = null;
                updateCreateButton();
            }
        });

        // Cancel task (for regenerate/create operations)
        document.getElementById('cancel-task-btn').addEventListener('click', async () => {
            if (!currentTaskId) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/task/${currentTaskId}/cancel`, {
                    method: 'POST'
                });

                if (response.ok) {
                    showNotification('Cancelled Successfully', 'success', 5000);
                    document.getElementById('task-progress').style.display = 'none';
                    document.getElementById('cancel-task-btn').style.display = 'none';
                    currentTaskId = null;
                    updateCreateButton();
                } else {
                    showNotification('Error cancelling: Server returned ' + response.status, 'error');
                }
            } catch (error) {
                showNotification('Error cancelling: ' + error.message, 'error');
            }
        });

        // Monitor background task
        async function monitorTask(taskId, callback) {
            return new Promise((resolve, reject) => {
                const interval = setInterval(async () => {
                    try {
                        const response = await fetch(`${API_BASE}/task/${taskId}`);
                        const task = await response.json();

                        if (callback) callback(task);

                        if (task.status === 'completed') {
                            clearInterval(interval);
                            resolve(task.result);
                        } else if (task.status === 'failed') {
                            clearInterval(interval);
                            // Include log in error for debugging
                            const logInfo = task.log ? '\n\nLog:\n' + task.log.slice(-500) : '';
                            reject(new Error((task.error || 'Task failed') + logInfo));
                        } else if (task.status === 'cancelled') {
                            clearInterval(interval);
                            // Resolve with a special cancelled marker
                            resolve({ cancelled: true });
                        }
                    } catch (error) {
                        clearInterval(interval);
                        reject(error);
                    }
                }, 1000);
            });
        }

        // Show notification
        function showNotification(message, type = 'success', customTimeout = null) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type} show`;

            // Scroll to notification
            notification.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // For error notifications, keep visible and add click to dismiss
            if (type === 'error') {
                notification.style.cursor = 'default';
                notification.style.userSelect = 'text';
                // Add a close button
                let closeBtn = notification.querySelector('.notification-close');
                if (!closeBtn) {
                    closeBtn = document.createElement('span');
                    closeBtn.className = 'notification-close';
                    closeBtn.textContent = ' ✕';
                    closeBtn.style.cssText = 'margin-left: 10px; cursor: pointer; font-weight: bold; color: #ff4444;';
                    notification.appendChild(closeBtn);
                } else {
                    closeBtn.style.display = 'inline';
                }
                closeBtn.onclick = (e) => {
                    e.stopPropagation();
                    notification.classList.remove('show');
                };
            } else {
                // Hide after 3 seconds (or custom timeout) for non-error notifications
                notification.style.cursor = '';
                notification.style.userSelect = '';
                const closeBtn = notification.querySelector('.notification-close');
                if (closeBtn) closeBtn.style.display = 'none';
                const timeout = customTimeout !== null ? customTimeout : 3000;
                setTimeout(() => {
                    notification.classList.remove('show');
                }, timeout);
            }
        }

        // Video modal controls
        document.getElementById('video-modal-close').addEventListener('click', () => {
            const videoModal = document.getElementById('video-modal');
            const videoPlayer = document.getElementById('video-player');
            videoPlayer.pause();
            videoPlayer.src = '';
            videoModal.classList.remove('show');
        });

        document.getElementById('video-modal').addEventListener('click', (e) => {
            if (e.target.id === 'video-modal') {
                const videoPlayer = document.getElementById('video-player');
                videoPlayer.pause();
                videoPlayer.src = '';
                e.target.classList.remove('show');
            }
        });

        // Initial load
        loadFolders();
    </script>

    <!-- Re-transcribe Modal -->
    <div id="re-transcribe-modal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2>Re-transcribe Video</h2>
                <span class="close">&times;</span>
            </div>
            <div class="modal-body">
                <!-- Video Info Section -->
                <div id="retranscribe-video-info" style="background: rgba(100, 149, 237, 0.1); border: 1px solid rgba(100, 149, 237, 0.3); border-left: 4px solid #6495ED; padding: 12px; margin-bottom: 16px; border-radius: 4px;">
                    <div style="color: #6495ED; font-weight: 600; margin-bottom: 8px;">📹 Video Information</div>
                    <div id="retranscribe-video-details" style="font-size: 13px; color: #ccc;">Loading...</div>
                </div>

                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 6px; font-weight: 600;">Whisper Model</label>
                    <select id="retranscribe-model" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #444; background: #222; color: #fff;">
                        <option value="base">base (fastest, less accurate)</option>
                        <option value="small" selected>small (balanced)</option>
                        <option value="medium">medium (more accurate)</option>
                        <option value="large">large (most accurate, slower)</option>
                    </select>
                </div>

                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 6px; font-weight: 600;">Language</label>
                    <select id="retranscribe-language" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #444; background: #222; color: #fff;">
                        <option value="">Auto-detect</option>
                        <option value="en" selected>English</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                        <option value="it">Italian</option>
                        <option value="pt">Portuguese</option>
                        <option value="ru">Russian</option>
                        <option value="ar">Arabic</option>
                        <option value="hi">Hindi</option>
                        <option value="zh">Chinese</option>
                    </select>
                </div>

                <!-- Warning message -->
                <div class="warning-box" style="background: rgba(255, 152, 0, 0.1); border: 1px solid rgba(255, 152, 0, 0.3); border-left: 4px solid #ff9800; padding: 12px; margin-bottom: 16px; border-radius: 4px;">
                    <div style="color: #ff9800; font-weight: 600; margin-bottom: 4px;">⚠️ Warning</div>
                    <div style="font-size: 13px; color: #ccc;">
                        Re-transcribing will <strong>overwrite</strong> the original subtitle file (SRT) and word timestamps.
                        Any manual subtitle edits will be <strong>permanently lost</strong>.
                        <br><br>
                        <strong>Preserved:</strong> Video shorts (MP4) and theme definitions will be kept.
                    </div>
                </div>

                <!-- Progress bar -->
                <div id="retranscribe-progress-container" style="display: none; margin-bottom: 16px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 13px;">
                        <span id="retranscribe-progress-text">Initializing...</span>
                        <span id="retranscribe-progress-percent">0%</span>
                    </div>
                    <div style="height: 8px; background: #333; border-radius: 4px; overflow: hidden;">
                        <div id="retranscribe-progress-fill" style="height: 100%; width: 0%; background: linear-gradient(90deg, #4CAF50, #45a049); transition: width 0.3s ease;"></div>
                    </div>
                </div>

                <div id="retranscribe-message" style="font-size: 13px; color: #aaa; margin-bottom: 0; min-height: 0;"></div>
            </div>
            <div class="modal-footer" style="padding: 16px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; justify-content: flex-end; gap: 12px;">
                <button id="cancel-retranscribe-btn" class="btn btn-secondary">Cancel</button>
                <button id="start-retranscribe-btn" class="btn btn-primary">Start Transcription</button>
            </div>
        </div>
    </div>
</body>
</html>
